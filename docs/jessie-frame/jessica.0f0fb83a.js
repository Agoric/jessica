parcelRequire=function(e,r,t,n){var i,o="function"==typeof parcelRequire&&parcelRequire,u="function"==typeof require&&require;function f(t,n){if(!r[t]){if(!e[t]){var i="function"==typeof parcelRequire&&parcelRequire;if(!n&&i)return i(t,!0);if(o)return o(t,!0);if(u&&"string"==typeof t)return u(t);var c=new Error("Cannot find module '"+t+"'");throw c.code="MODULE_NOT_FOUND",c}p.resolve=function(r){return e[t][1][r]||r},p.cache={};var l=r[t]=new f.Module(t);e[t][0].call(l.exports,p,l,l.exports,this)}return r[t].exports;function p(e){return f(p.resolve(e))}}f.isParcelRequire=!0,f.Module=function(e){this.id=e,this.bundle=f,this.exports={}},f.modules=e,f.cache=r,f.parent=o,f.register=function(r,t){e[r]=[function(e,r){r.exports=t},{}]};for(var c=0;c<t.length;c++)try{f(t[c])}catch(e){i||(i=e)}if(t.length){var l=f(t[t.length-1]);"object"==typeof exports&&"undefined"!=typeof module?module.exports=l:"function"==typeof define&&define.amd?define(function(){return l}):n&&(this[n]=l)}if(parcelRequire=f,i)throw i;return f}({"Pi9h":[function(require,module,exports) {
"use strict";function e(e){const{freeze:t,getOwnPropertyDescriptors:o,getPrototypeOf:n}=Object,{ownKeys:r}=Reflect,s=new WeakSet(e);return function(e){const a=new Set,c=new Map,f=new WeakMap;function i(e,t){if(Object(e)!==e)return;const o=typeof e;if("object"!==o&&"function"!==o)throw new TypeError(`Unexpected typeof: ${o}`);s.has(e)||a.has(e)||(a.add(e),f.set(e,t))}function p(e){t(e);const s=n(e),a=o(e),p=f.get(e)||"unknown";null===s||c.has(s)||(c.set(s,p),f.set(s,`${p}.__proto__`)),r(a).forEach(e=>{const t=`${p}.${String(e)}`,o=a[e];"value"in o?i(o.value,`${t}`):(i(o.get,`${t}(get)`),i(o.set,`${t}(set)`))})}return i(e),a.forEach(p),c.forEach((e,t)=>{if(!a.has(t)&&!s.has(t))throw new TypeError(`prototype ${t} of ${e} is not already in the fringeSet`)}),a.forEach(s.add,s),e}}Object.defineProperty(exports,"__esModule",{value:!0}),exports.default=void 0;var t=e;exports.default=t;
},{}],"IVhz":[function(require,module,exports) {
var r=[].indexOf;module.exports=function(e,n){if(r)return e.indexOf(n);for(var f=0;f<e.length;++f)if(e[f]===n)return f;return-1};
},{}],"boWn":[function(require,module,exports) {
var indexOf=require("indexof"),Object_keys=function(e){if(Object.keys)return Object.keys(e);var t=[];for(var r in e)t.push(r);return t},forEach=function(e,t){if(e.forEach)return e.forEach(t);for(var r=0;r<e.length;r++)t(e[r],r,e)},defineProp=function(){try{return Object.defineProperty({},"_",{}),function(e,t,r){Object.defineProperty(e,t,{writable:!0,enumerable:!1,configurable:!0,value:r})}}catch(e){return function(e,t,r){e[t]=r}}}(),globals=["Array","Boolean","Date","Error","EvalError","Function","Infinity","JSON","Math","NaN","Number","Object","RangeError","ReferenceError","RegExp","String","SyntaxError","TypeError","URIError","decodeURI","decodeURIComponent","encodeURI","encodeURIComponent","escape","eval","isFinite","isNaN","parseFloat","parseInt","undefined","unescape"];function Context(){}Context.prototype={};var Script=exports.Script=function(e){if(!(this instanceof Script))return new Script(e);this.code=e};Script.prototype.runInContext=function(e){if(!(e instanceof Context))throw new TypeError("needs a 'context' argument.");var t=document.createElement("iframe");t.style||(t.style={}),t.style.display="none",document.body.appendChild(t);var r=t.contentWindow,n=r.eval,o=r.execScript;!n&&o&&(o.call(r,"null"),n=r.eval),forEach(Object_keys(e),function(t){r[t]=e[t]}),forEach(globals,function(t){e[t]&&(r[t]=e[t])});var c=Object_keys(r),i=n.call(r,this.code);return forEach(Object_keys(r),function(t){(t in e||-1===indexOf(c,t))&&(e[t]=r[t])}),forEach(globals,function(t){t in e||defineProp(e,t,r[t])}),document.body.removeChild(t),i},Script.prototype.runInThisContext=function(){return eval(this.code)},Script.prototype.runInNewContext=function(e){var t=Script.createContext(e),r=this.runInContext(t);return forEach(Object_keys(t),function(r){e[r]=t[r]}),r},forEach(Object_keys(Script.prototype),function(e){exports[e]=Script[e]=function(t){var r=Script(t);return r[e].apply(r,[].slice.call(arguments,1))}}),exports.createScript=function(e){return exports.Script(e)},exports.createContext=Script.createContext=function(e){var t=new Context;return"object"==typeof e&&forEach(Object_keys(e),function(r){t[r]=e[r]}),t};
},{"indexof":"IVhz"}],"iDNi":[function(require,module,exports) {

"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.default=void 0;var e=n(require("@agoric/make-hardener"));function n(e){return e&&e.__esModule?e:{default:e}}function t(e,n){const t=`please report internal shim error: ${e}`;throw console.error(t),n&&(console.error(`${n}`),console.error(`${n.stack}`)),t}function r(e,n){e||t(n)}function o(e){return e=(e=e.replace(/\(0,[^)]+\)/g,"(0, eval)")).replace(/cov_[^+]+\+\+[;,]/g,"")}function a(e,n){const{initRootRealm:t,initCompartment:r,getRealmGlobal:o,realmEvaluate:a}=n,{create:i,defineProperties:s}=Object,c=new Map([["EvalError",EvalError],["RangeError",RangeError],["ReferenceError",ReferenceError],["SyntaxError",SyntaxError],["TypeError",TypeError],["URIError",URIError]]);function l(e,...n){try{return e(...n)}catch(t){if(Object(t)!==t)throw t;let e,n,a;try{e=`${t.name}`,n=`${t.message}`,a=`${t.stack||n}`}catch(r){throw new Error("unknown error")}const i=c.get(e)||Error;try{throw new i(n)}catch(o){throw o.stack=a,o}}}class p{constructor(){throw new TypeError("Realm is not a constructor")}static makeRootRealm(n){n=Object(n);const r=i(p.prototype);return l(t,e,r,n),r}static makeCompartment(){const n=i(p.prototype);return l(r,e,n),n}get global(){return l(o,this)}evaluate(e,n){return l(a,this,e,n)}}return s(p,{toString:{value:()=>"function Realm() { [shim code] }",writable:!1,enumerable:!1,configurable:!0}}),s(p.prototype,{toString:{value:()=>"[object Realm]",writable:!1,enumerable:!1,configurable:!0}}),p}const i=o(`'use strict'; (${a})`);function s(e,n){const{unsafeEval:t}=e;return t(i)(e,n)}const{assign:c,create:l,freeze:p,defineProperties:u,getOwnPropertyDescriptor:h,getOwnPropertyDescriptors:d,getOwnPropertyNames:y,getPrototypeOf:m,setPrototypeOf:f}=Object,{apply:g,ownKeys:b}=Reflect,w=e=>(n,...t)=>g(e,n,t),E=w(Object.prototype.hasOwnProperty),S=w(Array.prototype.filter),v=w(Array.prototype.pop),I=w(Array.prototype.join),A=w(Array.prototype.concat),j=w(RegExp.prototype.test),O=w(String.prototype.includes),T=["isFinite","isNaN","parseFloat","parseInt","decodeURI","decodeURIComponent","encodeURI","encodeURIComponent","Array","ArrayBuffer","Boolean","DataView","Date","Error","EvalError","Float32Array","Float64Array","Int8Array","Int16Array","Int32Array","Map","Number","Object","Promise","Proxy","RangeError","ReferenceError","RegExp","Set","String","Symbol","SyntaxError","TypeError","Uint8Array","Uint8ClampedArray","Uint16Array","Uint32Array","URIError","WeakMap","WeakSet","JSON","Math","Reflect","escape","unescape","Intl"];function _(e){const n={Infinity:{value:1/0},NaN:{value:NaN},undefined:{value:void 0}};for(const t of T){const o=h(e,t);o&&(r("value"in o,`unexpected accessor on global property: ${t}`),n[t]={value:o.value,writable:!0,configurable:!0})}return n}function P(){const{defineProperty:e,defineProperties:n,getOwnPropertyDescriptor:t,getPrototypeOf:r,prototype:o}=Object;try{(0,o.__lookupGetter__)("x")}catch(c){return}function a(e){if(null==e)throw new TypeError("can't convert undefined or null to object");return Object(e)}function i(e){return"symbol"==typeof e?e:`${e}`}function s(e,n){if("function"!=typeof e)throw TypeError(`invalid ${n} usage`);return e}n(o,{__defineGetter__:{value:function(n,t){const r=a(this);e(r,n,{get:s(t,"getter"),enumerable:!0,configurable:!0})}},__defineSetter__:{value:function(n,t){const r=a(this);e(r,n,{set:s(t,"setter"),enumerable:!0,configurable:!0})}},__lookupGetter__:{value:function(e){let n,o=a(this);for(e=i(e);o&&!(n=t(o,e));)o=r(o);return n&&n.get}},__lookupSetter__:{value:function(e){let n,o=a(this);for(e=i(e);o&&!(n=t(o,e));)o=r(o);return n&&n.set}}})}function x(){const{defineProperties:e,getPrototypeOf:n,setPrototypeOf:t}=Object;function r(r,o){let a;try{a=(0,eval)(o)}catch(c){if(c instanceof SyntaxError)return;throw c}const i=n(a),s=function(){throw new TypeError("Not available")};e(s,{name:{value:r}}),e(i,{constructor:{value:s}}),e(s,{prototype:{value:i}}),s!==Function.prototype.constructor&&t(s,Function.prototype.constructor)}r("Function","(function(){})"),r("GeneratorFunction","(function*(){})"),r("AsyncFunction","(async function(){})"),r("AsyncGeneratorFunction","(async function*(){})")}const R="'use strict'; this",F="(0, eval)(\"'use strict'; this\")";function k(){if(new Function("try {return this===global}catch(e){ return false}")())return require("vm").runInNewContext(F)}function C(){if("undefined"==typeof document)return;const e=document.createElement("iframe");return e.style.display="none",document.body.appendChild(e),e.contentWindow.eval(R)}const N=()=>{const e=C(),n=k();if(!e&&!n||e&&n)throw new Error("unexpected platform, unable to create Realm");return e||n};function M(e,n=[]){const t=_(e);return p({unsafeGlobal:e,sharedGlobalDescs:t,unsafeEval:e.eval,unsafeFunction:e.Function,allShims:n})}const U=o(`"use strict"; (${P})();`),$=o(`"use strict"; (${x})();`);function D(e){const n=N();return n.eval(U),n.eval($),M(n,e)}function G(){const e=(0,eval)(R);return P(),x(),M(e)}const L=/^[a-zA-Z_$][\w$]*$/,H=new Set(["await","break","case","catch","class","const","continue","debugger","default","delete","do","else","export","extends","finally","for","function","if","import","in","instanceof","new","return","super","switch","this","throw","try","typeof","var","void","while","with","yield","let","static","enum","implements","package","protected","interface","private","public","await","null","true","false","this","arguments"]);function W(e){const n=d(e);return S(y(n),e=>{if("eval"===e||H.has(e)||!j(L,e))return!1;const t=n[e];return!1===t.configurable&&!1===t.writable&&E(t,"value")})}const z=new Proxy(p({}),{get(e,n){t(`unexpected scope handler trap called: ${n}`)}});function B(e){const{unsafeGlobal:n,unsafeEval:t}=e;let r=!1;return{__proto__:z,allowUnsafeEvaluatorOnce(){r=!0},unsafeEvaluatorAllowed:()=>r,get:(e,n)=>"eval"===n?!0===r?(r=!1,t):e.eval:n!==Symbol.unscopables&&n in e?e[n]:void 0,set(e,n,t){if(E(e,n))throw new TypeError(`do not modify endowments like ${String(n)}`);return m(e)[n]=t,!0},has:(e,t)=>"eval"===t||t in e||t in n}}const q=/^(.*)\bimport\s*(\(|\/\/|\/\*)/m;function Y(e){const n=q.exec(e);if(n){const e=n[1].split("\n").length;throw new SyntaxError(`possible import expression rejected around line ${e}`)}}function V(e){return 0===e.length?"":`const {${I(e,",")}} = this;`}function J(e,n){const{unsafeFunction:t}=e;return t(`\n    with (arguments[0]) {\n      ${V(n)}\n      return function() {\n        'use strict';\n        return eval(arguments[0]);\n      };\n    }\n  `)}function K(e,n){const{unsafeFunction:o}=e,a=B(e),i=J(e,W(n));return function(e={}){const s=l(n,d(e)),c=new Proxy(s,a),p=g(i,n,[c]),h={eval(e){let r;Y(e=`${e}`),a.allowUnsafeEvaluatorOnce();try{return g(p,n,[e])}catch(o){throw r=o,o}finally{a.unsafeEvaluatorAllowed()&&t("handler did not revoke useUnsafeEvaluator",r)}}}.eval;return f(h,o.prototype),r(m(h).constructor!==Function,"hide Function"),r(m(h).constructor!==o,"hide unsafeFunction"),u(h,{toString:{value:h("() => 'function eval() { [shim code] }'"),writable:!1,enumerable:!1,configurable:!0}}),h}}function Q(e){return e()}function X(e){return(n,t)=>e(t)(n)}function Z(e,n){const{unsafeFunction:t,unsafeGlobal:o}=e,a=function(...e){const r=`${v(e)||""}`;let a=`${I(e,",")}`;if(!j(/^[\w\s,]*$/,a))throw new o.SyntaxError("shim limitation: Function arg must be simple ASCII identifiers, possibly separated by commas: no default values, pattern matches, or non-ASCII parameter names");if(new t(r),O(a,")"))throw new o.SyntaxError("shim limitation: Function arg string contains parenthesis");return a.length>0&&(a+="\n/*``*/"),n(`(function(${a}){\n${r}\n})`)};return f(a,t.prototype),r(m(a).constructor!==Function,"hide Function"),r(m(a).constructor!==t,"hide unsafeFunction"),u(a,{prototype:{value:t.prototype},toString:{value:n("() => 'function Function() { [shim code] }'"),writable:!1,enumerable:!1,configurable:!0}}),a}const ee=new WeakMap;function ne(e){return r(Object(e)===e,"bad object, not a Realm instance"),r(ee.has(e),"Realm instance has no record"),ee.get(e)}function te(e,n){r(Object(e)===e,"bad object, not a Realm instance"),r(!ee.has(e),"Realm instance already has a record"),ee.set(e,n)}function re(e,n,t,r){u(n,e),u(n,{eval:{value:t,writable:!0,configurable:!0},Function:{value:r,writable:!0,configurable:!0}})}function oe(e){const{sharedGlobalDescs:n,unsafeGlobal:t}=e,r=l(t.Object.prototype),o=K(e,r),a=Q(o),i=X(o),s=Z(e,a);return re(n,r,a,s),p({safeGlobal:r,safeEval:a,safeEvalWhichTakesEndowments:i,safeFunction:s})}function ae(e,n,t){const{shims:r}=t,o=A(e.allShims,r),a=D(o),i=s(a,le);a.sharedGlobalDescs.Realm={value:i,writable:!0,configurable:!0};const c=oe(a),{safeEvalWhichTakesEndowments:l}=c;for(const s of o)l(s);te(n,c)}function ie(e,n){te(n,oe(e))}function se(e){const{safeGlobal:n}=ne(e);return n}function ce(e,n,t={}){const{safeEvalWhichTakesEndowments:r}=ne(e);return r(n,t)}const le={initRootRealm:ae,initCompartment:ie,getRealmGlobal:se,realmEvaluate:ce},pe=G(),ue=a(pe,le);function he(){const e=Date,n=function(...n){return void 0===new.target?"Invalid Date":n.length>0?Reflect.construct(e,n,new.target):Reflect.construct(e,[NaN],new.target)};Object.defineProperties(n,Object.getOwnPropertyDescriptors(e)),e.prototype.constructor=n,n.now=(()=>NaN),Date=n}function de(){Math.random=(()=>{throw Error("disabled")})}function ye(){"undefined"!=typeof Intl&&(Intl.DateTimeFormat=(()=>{throw Error("disabled")}),Intl.NumberFormat=(()=>{throw Error("disabled")}),Intl.getCanonicalLocales=(()=>{throw Error("disabled")})),Object.prototype.toLocaleString=(()=>{throw new Error("toLocaleString suppressed")})}function me(){if(!Object.isExtensible(Error))throw Error("huh Error is not extensible");if(delete Error.captureStackTrace,"captureStackTrace"in Error)throw Error("hey we could not remove Error.captureStackTrace")}function fe(){if(delete RegExp.prototype.compile,"compile"in RegExp.prototype)throw Error("hey we could not remove RegExp.prototype.compile");const e=RegExp;if(RegExp=function(...n){return Reflect.construct(e,n,new.target)},RegExp.prototype=e.prototype,e.prototype.constructor=RegExp,"$1"in RegExp)throw Error("hey we could not remove RegExp.$1")}function ge(e,n){const{getOwnPropertyDescriptor:t,getOwnPropertyNames:r,keys:o}=Object,a=new WeakMap,i=Object.getPrototypeOf,s=(e=>(n,...t)=>Reflect.apply(e,n,t))(Object.prototype.hasOwnProperty),c=new WeakMap;function l(e,n){const r=[!0,!1,"*","maybeAccessor"];!function e(n,a){if(n===Object(n))if("object"==typeof a){if(c.has(n))throw new Error("primordial reachable through multiple paths");c.set(n,a),o(a).forEach(r=>{const o=t(n,r);o&&e(o.value,a[r])})}else if(r.indexOf(a)<0)throw new Error(`syntax error in whitelist; unexpected value: ${a}`)}(e,n)}l(e,n.namedIntrinsics),l(getAnonIntrinsics(e),n.anonIntrinsics),function e(n,o,l){if(n!==Object(n))return;if(a.get(n))return;const p=i(n);if(null!==p&&!c.has(p))throw new Error(`unexpected intrinsic ${o}.__proto__`);a.set(n,!0),r(n).forEach(r=>{const a=o+(o?".":"")+r,p=function(e,n){let t=c.get(e);if(t&&s(t,n))return t[n];for(;;){if(null===(e=i(e)))return!1;if((t=c.get(e))&&s(t,n)){const e=t[n];return"*"===e&&e}}}(n,r);if(p){const o=t(n,r);s(o,"value")?e(o.value,a,l+1):"maybeAccessor"!==p?delete n[r]:(e(o.get,`${a}<getter>`,l+1),e(o.set,`${a}<setter>`,l+1))}else delete n[r]})}(e,"",0)}function be(e){const n=Object.getOwnPropertyDescriptor,t=Object.getPrototypeOf;function*r(){}const o=t(r);async function*a(){}const i=t(a);async function s(){}const c=t(s);function l(n,r,o){const a=e.Symbol&&e.Symbol.iterator||"@@iterator";if(r[a]){const e=r[a](),i=t(e);n[o]=i;const s=t(i);if(s!==Object.prototype)if(n.IteratorPrototype){if(n.IteratorPrototype!==s)throw new Error(`unexpected %${o}%.__proto__`)}else{if(t(s)!==Object.prototype)throw new Error("%IteratorPrototype%.__proto__ was not Object.prototype");n.IteratorPrototype=s}}}return[["Object.prototype",Object.prototype,{}],["Function.prototype",Function.prototype,function(){}],["Array.prototype",Array.prototype,[]],["RegExp.prototype",RegExp.prototype,/x/],["Boolean.prototype",Boolean.prototype,!0],["Number.prototype",Number.prototype,1],["String.prototype",String.prototype,"x"],["%Generator%",o,r],["%AsyncGenerator%",i,a],["%AsyncFunction%",c,s]].forEach(e=>{e[0];const n=e[1];let r=e[2];if(void 0!==r&&n!==(r=Object(r))&&n!==t(r))throw new Error(`Unexpected undeniable: ${n}`)}),function(){const r={};if(r.ThrowTypeError=n(arguments,"callee").get,l(r,[],"ArrayIteratorPrototype"),l(r,"","StringIteratorPrototype"),"function"==typeof Map&&l(r,new Map,"MapIteratorPrototype"),"function"==typeof Set&&l(r,new Set,"SetIteratorPrototype"),t(o)!==Function.prototype)throw new Error("Generator.__proto__ was not Function.prototype");const a=o.constructor;if(t(a)!==Function.prototype.constructor)throw new Error("GeneratorFunction.__proto__ was not Function.prototype.constructor");if(r.GeneratorFunction=a,t(o.prototype)!==r.IteratorPrototype)throw new Error("Unexpected Generator.prototype.__proto__");if(t(i)!==Function.prototype)throw new Error("AsyncGenerator.__proto__ was not Function.prototype");const s=i.constructor;if(t(s)!==Function.prototype.constructor)throw new Error("AsyncGeneratorFunction.__proto__ was not Function.prototype.constructor");r.AsyncGeneratorFunction=s;const p=i.prototype;if(r.AsyncIteratorPrototype=t(p),t(r.AsyncIteratorPrototype)!==Object.prototype)throw new Error("AsyncIteratorPrototype.__proto__ was not Object.prototype");if(t(c)!==Function.prototype)throw new Error("AsyncFunctionPrototype.__proto__ was not Function.prototype");const u=c.constructor;if(t(u)!==Function.prototype.constructor)throw new Error("AsyncFunction.__proto__ was not Function.prototype.constructor");return r.AsyncFunction=u,function(){if(!e.Float32Array)return;const n=t(e.Float32Array);if(n!==Function.prototype){if(t(n)!==Function.prototype)throw new Error("TypedArray.__proto__ was not Function.prototype");r.TypedArray=n}}(),Object.keys(r).forEach(e=>{if(void 0===r[e])throw new Error(`Malformed intrinsic: ${e}`)}),r}()}function we(e,n){return{global:e,anonIntrinsics:n}}const Ee=!0,Se=!0;let ve;var Ie={anonIntrinsics:{ThrowTypeError:{},IteratorPrototype:{next:"*",constructor:!1},ArrayIteratorPrototype:{},StringIteratorPrototype:{},MapIteratorPrototype:{},SetIteratorPrototype:{},AsyncIteratorPrototype:{},GeneratorFunction:{length:"*",prototype:{prototype:{next:"*",return:"*",throw:"*",constructor:"*"}}},AsyncGeneratorFunction:{length:"*",prototype:{prototype:{next:"*",return:"*",throw:"*",constructor:"*"}}},AsyncFunction:{length:"*",prototype:"*"},TypedArray:ve={length:"*",name:"*",from:Ee,of:Ee,BYTES_PER_ELEMENT:"*",prototype:{buffer:"maybeAccessor",byteLength:"maybeAccessor",byteOffset:"maybeAccessor",copyWithin:"*",entries:"*",every:"*",fill:"*",filter:"*",find:"*",findIndex:"*",forEach:"*",includes:"*",indexOf:"*",join:"*",keys:"*",lastIndexOf:"*",length:"maybeAccessor",map:"*",reduce:"*",reduceRight:"*",reverse:"*",set:"*",slice:"*",some:"*",sort:"*",subarray:"*",values:"*",BYTES_PER_ELEMENT:"*"}}},namedIntrinsics:{Infinity:Se,NaN:Se,undefined:Se,isFinite:Ee,isNaN:Ee,parseFloat:Ee,parseInt:Ee,decodeURI:Ee,decodeURIComponent:Ee,encodeURI:Ee,encodeURIComponent:Ee,Object:{assign:Ee,create:Ee,defineProperties:Ee,defineProperty:Ee,entries:Ee,freeze:Se,getOwnPropertyDescriptor:Ee,getOwnPropertyDescriptors:Ee,getOwnPropertyNames:Ee,getOwnPropertySymbols:Ee,getPrototypeOf:Ee,is:Se,isExtensible:Ee,isFrozen:Ee,isSealed:Ee,keys:Ee,preventExtensions:Se,seal:Se,setPrototypeOf:Ee,values:Ee,prototype:{__defineGetter__:Ee,__defineSetter__:Ee,__lookupGetter__:Ee,__lookupSetter__:Ee,constructor:"*",hasOwnProperty:Ee,isPrototypeOf:Ee,propertyIsEnumerable:Ee,toLocaleString:"*",toString:"*",valueOf:"*",[Symbol.iterator]:"*",[Symbol.toPrimitive]:"*",[Symbol.toStringTag]:"*",[Symbol.unscopables]:"*"}},Function:{length:Ee,prototype:{apply:Ee,bind:Ee,call:Ee,[Symbol.hasInstance]:"*",length:"*",name:"*",prototype:"*",arity:"*",[Symbol.species]:"maybeAccessor"}},Boolean:{prototype:Ee},Symbol:{asyncIterator:Ee,for:Ee,hasInstance:Ee,isConcatSpreadable:Ee,iterator:Ee,keyFor:Ee,match:Ee,matchAll:Ee,replace:Ee,search:Ee,species:Ee,split:Ee,toPrimitive:Ee,toStringTag:Ee,unscopables:Ee,prototype:Ee},Error:{prototype:{name:"*",message:"*"}},EvalError:{prototype:Ee},RangeError:{prototype:Ee},ReferenceError:{prototype:Ee},SyntaxError:{prototype:Ee},TypeError:{prototype:Ee},URIError:{prototype:Ee},Number:{EPSILON:Ee,isFinite:Se,isInteger:Ee,isNaN:Se,isSafeInteger:Se,MAX_SAFE_INTEGER:Se,MAX_VALUE:Ee,MIN_SAFE_INTEGER:Se,MIN_VALUE:Ee,NaN:Ee,NEGATIVE_INFINITY:Ee,parseFloat:Ee,parseInt:Ee,POSITIVE_INFINITY:Ee,prototype:{toExponential:Ee,toFixed:Ee,toPrecision:Ee}},Math:{E:Se,LN10:Se,LN2:Se,LOG10E:Ee,LOG2E:Ee,PI:Se,SQRT1_2:Ee,SQRT2:Ee,abs:Se,acos:Ee,acosh:Ee,asin:Ee,asinh:Ee,atan:Ee,atanh:Ee,atan2:Ee,cbrt:Ee,ceil:Se,clz32:Ee,cos:Ee,cosh:Ee,exp:Ee,expm1:Ee,floor:Se,fround:Ee,hypot:Ee,imul:Ee,log:Se,log1p:Ee,log10:Se,log2:Se,max:Se,min:Se,pow:Se,random:Ee,round:Se,sign:Ee,sin:Ee,sinh:Ee,sqrt:Se,tan:Ee,tanh:Ee,trunc:Se},Date:{now:Ee,parse:Ee,UTC:Ee,prototype:{getDate:Ee,getDay:Ee,getFullYear:Ee,getHours:Ee,getMilliseconds:Ee,getMinutes:Ee,getMonth:Ee,getSeconds:Ee,getTime:Ee,getTimezoneOffset:Ee,getUTCDate:Ee,getUTCDay:Ee,getUTCFullYear:Ee,getUTCHours:Ee,getUTCMilliseconds:Ee,getUTCMinutes:Ee,getUTCMonth:Ee,getUTCSeconds:Ee,setDate:Ee,setFullYear:Ee,setHours:Ee,setMilliseconds:Ee,setMinutes:Ee,setMonth:Ee,setSeconds:Ee,setTime:Ee,setUTCDate:Ee,setUTCFullYear:Ee,setUTCHours:Ee,setUTCMilliseconds:Ee,setUTCMinutes:Ee,setUTCMonth:Ee,setUTCSeconds:Ee,toDateString:Ee,toISOString:Ee,toJSON:Ee,toLocaleDateString:Ee,toLocaleString:Ee,toLocaleTimeString:Ee,toTimeString:Ee,toUTCString:Ee,getYear:Ee,setYear:Ee,toGMTString:Ee}},String:{fromCharCode:Se,fromCodePoint:Ee,raw:Se,prototype:{charAt:Ee,charCodeAt:Ee,codePointAt:Ee,concat:Ee,endsWith:Se,includes:Ee,indexOf:Se,lastIndexOf:Se,localeCompare:Ee,match:Ee,normalize:Ee,padEnd:Ee,padStart:Ee,repeat:Ee,replace:Ee,search:Ee,slice:Se,split:Ee,startsWith:Se,substring:Ee,toLocaleLowerCase:Ee,toLocaleUpperCase:Ee,toLowerCase:Ee,toUpperCase:Ee,trim:Ee,substr:Ee,anchor:Ee,big:Ee,blink:Ee,bold:Ee,fixed:Ee,fontcolor:Ee,fontsize:Ee,italics:Ee,link:Ee,small:Ee,strike:Ee,sub:Ee,sup:Ee,trimLeft:Ee,trimRight:Ee,length:"*"}},RegExp:{prototype:{exec:Ee,flags:"maybeAccessor",global:"maybeAccessor",ignoreCase:"maybeAccessor",[Symbol.match]:"*",multiline:"maybeAccessor",[Symbol.replace]:"*",[Symbol.search]:"*",source:"maybeAccessor",[Symbol.split]:"*",sticky:"maybeAccessor",test:Ee,unicode:"maybeAccessor",dotAll:"maybeAccessor",compile:!1,lastIndex:"*",options:"*"}},Array:{from:Se,isArray:Ee,of:Se,prototype:{concat:Ee,copyWithin:Ee,entries:Ee,every:Ee,fill:Ee,filter:Se,find:Ee,findIndex:Ee,forEach:Se,includes:Ee,indexOf:Se,join:Ee,keys:Ee,lastIndexOf:Se,map:Se,pop:Se,push:Se,reduce:Se,reduceRight:Se,reverse:Ee,shift:Se,slice:Se,some:Ee,sort:Ee,splice:Ee,unshift:Se,values:Ee,length:"*"}},Int8Array:ve,Uint8Array:ve,Uint8ClampedArray:ve,Int16Array:ve,Uint16Array:ve,Int32Array:ve,Uint32Array:ve,Float32Array:ve,Float64Array:ve,Map:{prototype:{clear:Se,delete:Se,entries:Se,forEach:Se,get:Se,has:Se,keys:Se,set:Se,size:"maybeAccessor",values:Se}},Set:{prototype:{add:Se,clear:Se,delete:Se,entries:Se,forEach:Se,has:Se,keys:Se,size:"maybeAccessor",values:Se}},WeakMap:{prototype:{delete:Se,get:Se,has:Se,set:Se}},WeakSet:{prototype:{add:Se,delete:Se,has:Se}},ArrayBuffer:{isView:Ee,length:Ee,name:Ee,prototype:{byteLength:"maybeAccessor",slice:Ee}},DataView:{length:Ee,name:Ee,BYTES_PER_ELEMENT:"*",prototype:{buffer:"maybeAccessor",byteOffset:"maybeAccessor",byteLength:"maybeAccessor",getFloat32:Ee,getFloat64:Ee,getInt8:Ee,getInt16:Ee,getInt32:Ee,getUint8:Ee,getUint16:Ee,getUint32:Ee,setFloat32:Ee,setFloat64:Ee,setInt8:Ee,setInt16:Ee,setInt32:Ee,setUint8:Ee,setUint16:Ee,setUint32:Ee}},JSON:{parse:Se,stringify:Se},Promise:{all:Se,race:Se,reject:Se,resolve:Se,prototype:{catch:Ee,then:Se,finally:Ee,get:Ee,put:Ee,del:Ee,post:Ee,invoke:Ee,fapply:Ee,fcall:Ee,send:Ee,delete:Ee,end:Ee}},Q:{all:Ee,race:Ee,reject:Ee,resolve:Ee,join:Ee,isPassByCopy:Ee,passByCopy:Ee,makeRemote:Ee,makeFar:Ee,shorten:Ee,isPromise:Ee,async:Ee,rejected:Ee,promise:Ee,delay:Ee,memoize:Ee,defer:Ee},Reflect:{apply:Ee,construct:Ee,defineProperty:Ee,deleteProperty:Ee,get:Ee,getOwnPropertyDescriptor:Ee,getPrototypeOf:Ee,has:Ee,isExtensible:Ee,ownKeys:Ee,preventExtensions:Ee,set:Ee,setPrototypeOf:Ee},Proxy:{revocable:Ee},escape:Ee,unescape:Ee,StringMap:{prototype:{}},Realm:{makeRootRealm:Ee,makeCompartment:Ee,prototype:{global:"maybeAccessor",evaluate:Ee}},SES:{confine:Ee,confineExpr:Ee},Nat:Se,def:Se}};function Ae(e){const n=new Map([["EvalError",EvalError],["RangeError",RangeError],["ReferenceError",ReferenceError],["SyntaxError",SyntaxError],["TypeError",TypeError],["URIError",URIError]]);const t={};return["log","info","warn","error","group","groupEnd","trace","time","timeLog","timeEnd"].forEach(r=>{if(r in e){const o=e[r];t[r]=function(...e){!function(e,...t){try{e(...t)}catch(r){if(Object(r)!==r)throw r;let e,t,i;try{e=`${r.name}`,t=`${r.message}`,i=`${r.stack}`}catch(o){throw new Error("unknown error")}const s=n.get(e)||Error;try{throw new s(t)}catch(a){throw a.stack=i,a}}}(o,...e)}}}),t}function je(e,n){return function(t){const r=new Map;return function(o){const a=`${o}`;return r.has(a)||r.set(a,n(function(r){if(!Object.prototype.hasOwnProperty.call(t,r))throw new Error(`Cannot find module '${r}'`);const o=t[r];if("@agoric/harden"===r)return n;if("function"==typeof o)return e.evaluate(`(${o})`);const a=`(${o.attenuatorSource})`;return e.evaluate(a)(o)}(a))),r.get(a)}}}function Oe(n,t){return{makeSESRootRealm:function(r){r=Object(r);const o=[],a=JSON.parse(JSON.stringify(r.whitelist||Ie));"allow"!==r.dateNowMode&&o.push(`(${he})();`),"allow"!==r.mathRandomMode&&o.push(`(${de})();`),"allow"!==r.intlMode&&o.push(`(${ye})();`),"allow"!==r.errorStackMode?o.push(`(${me})();`):(a.namedIntrinsics.Error.captureStackTrace=!0,a.namedIntrinsics.Error.stackTraceLimit=!0,a.namedIntrinsics.Error.prepareStackTrace=!0),"allow"!==r.regexpMode&&o.push(`(${fe})();`);const i=`const getAnonIntrinsics = (${be});\n               (${ge})(this, ${JSON.stringify(a)})`;o.push(i);const s=t.makeRootRealm({shims:o}),c=`(${e.default})`,l=s.evaluate(c)(void 0,r.hardenerOptions);if(s.evaluate(n).createSESInThisRealm(s.global,n,s),"allow"===r.consoleMode){const e=`(${Ae})`;s.global.console=s.evaluate(e)(console)}const p=s.evaluate(`(${be})`)(s.global);return l(s.evaluate(`(${we})`)(s.global,p)),s.makeRequire=l(s.evaluate(`(${je})`)(s,l)),s}}}const Te="(function (exports) {\n  'use strict';\n\n  // Adapted from SES/Caja - Copyright (C) 2011 Google Inc.\n  // Copyright (C) 2018 Agoric\n\n  // Licensed under the Apache License, Version 2.0 (the \"License\");\n  // you may not use this file except in compliance with the License.\n  // You may obtain a copy of the License at\n  //\n  // http://www.apache.org/licenses/LICENSE-2.0\n  //\n  // Unless required by applicable law or agreed to in writing, software\n  // distributed under the License is distributed on an \"AS IS\" BASIS,\n  // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  // See the License for the specific language governing permissions and\n  // limitations under the License.\n\n  // based upon:\n  // https://github.com/google/caja/blob/master/src/com/google/caja/ses/startSES.js\n  // https://github.com/google/caja/blob/master/src/com/google/caja/ses/repairES5.js\n  // then copied from proposal-frozen-realms deep-freeze.js\n  // then copied from SES/src/bundle/deepFreeze.js\n\n  /**\n   * @typedef HardenerOptions\n   * @type {object}\n   * @property {WeakSet=} fringeSet WeakSet to use for the fringeSet\n   * @property {Function=} naivePrepareObject Call with object before hardening\n   */\n\n  /**\n   * Create a `harden` function.\n   *\n   * @param {Iterable} initialFringe Objects considered already hardened\n   * @param {HardenerOptions=} options Options for creation\n   */\n  function makeHardener(initialFringe, options = {}) {\n    const { freeze, getOwnPropertyDescriptors, getPrototypeOf } = Object;\n    const { ownKeys } = Reflect;\n\n    // Objects that we won't freeze, either because we've frozen them already,\n    // or they were one of the initial roots (terminals). These objects form\n    // the \"fringe\" of the hardened object graph.\n    let { fringeSet } = options;\n    if (fringeSet) {\n      if (\n        typeof fringeSet.add !== 'function' ||\n        typeof fringeSet.has !== 'function'\n      ) {\n        throw new TypeError(\n          `options.fringeSet must have add() and has() methods`,\n        );\n      }\n\n      // Populate the supplied fringeSet with our initialFringe.\n      if (initialFringe) {\n        for (const fringe of initialFringe) {\n          fringeSet.add(fringe);\n        }\n      }\n    } else {\n      // Use a new empty fringe.\n      fringeSet = new WeakSet(initialFringe);\n    }\n\n    const naivePrepareObject = options && options.naivePrepareObject;\n\n    function harden(root) {\n      const toFreeze = new Set();\n      const prototypes = new Map();\n      const paths = new WeakMap();\n\n      // If val is something we should be freezing but aren't yet,\n      // add it to toFreeze.\n      function enqueue(val, path) {\n        if (Object(val) !== val) {\n          // ignore primitives\n          return;\n        }\n        const type = typeof val;\n        if (type !== 'object' && type !== 'function') {\n          // future proof: break until someone figures out what it should do\n          throw new TypeError(`Unexpected typeof: ${type}`);\n        }\n        if (fringeSet.has(val) || toFreeze.has(val)) {\n          // Ignore if this is an exit, or we've already visited it\n          return;\n        }\n        // console.log(`adding ${val} to toFreeze`, val);\n        toFreeze.add(val);\n        paths.set(val, path);\n      }\n\n      function freezeAndTraverse(obj) {\n        // Apply the naive preparer if they specified one.\n        if (naivePrepareObject) {\n          naivePrepareObject(obj);\n        }\n\n        // Now freeze the object to ensure reactive\n        // objects such as proxies won't add properties\n        // during traversal, before they get frozen.\n\n        // Object are verified before being enqueued,\n        // therefore this is a valid candidate.\n        // Throws if this fails (strict mode).\n        freeze(obj);\n\n        // we rely upon certain commitments of Object.freeze and proxies here\n\n        // get stable/immutable outbound links before a Proxy has a chance to do\n        // something sneaky.\n        const proto = getPrototypeOf(obj);\n        const descs = getOwnPropertyDescriptors(obj);\n        const path = paths.get(obj) || 'unknown';\n\n        // console.log(`adding ${proto} to prototypes under ${path}`);\n        if (proto !== null && !prototypes.has(proto)) {\n          prototypes.set(proto, path);\n          paths.set(proto, `${path}.__proto__`);\n        }\n\n        ownKeys(descs).forEach(name => {\n          const pathname = `${path}.${String(name)}`;\n          // todo uncurried form\n          // todo: getOwnPropertyDescriptors is guaranteed to return well-formed\n          // descriptors, but they still inherit from Object.prototype. If\n          // someone has poisoned Object.prototype to add 'value' or 'get'\n          // properties, then a simple 'if (\"value\" in desc)' or 'desc.value'\n          // test could be confused. We use hasOwnProperty to be sure about\n          // whether 'value' is present or not, which tells us for sure that this\n          // is a data property.\n          const desc = descs[name];\n          if ('value' in desc) {\n            // todo uncurried form\n            enqueue(desc.value, `${pathname}`);\n          } else {\n            enqueue(desc.get, `${pathname}(get)`);\n            enqueue(desc.set, `${pathname}(set)`);\n          }\n        });\n      }\n\n      function dequeue() {\n        // New values added before forEach() has finished will be visited.\n        toFreeze.forEach(freezeAndTraverse); // todo curried forEach\n      }\n\n      function checkPrototypes() {\n        prototypes.forEach((path, p) => {\n          if (!(toFreeze.has(p) || fringeSet.has(p))) {\n            // all reachable properties have already been frozen by this point\n            let msg;\n            try {\n              msg = `prototype ${p} of ${path} is not already in the fringeSet`;\n            } catch (e) {\n              // `${(async _=>_).__proto__}` fails in most engines\n              msg =\n                'a prototype of something is not already in the fringeset (and .toString failed)';\n              try {\n                console.log(msg);\n                console.log('the prototype:', p);\n                console.log('of something:', path);\n              } catch (_e) {\n                // console.log might be missing in restrictive SES realms\n              }\n            }\n            throw new TypeError(msg);\n          }\n        });\n      }\n\n      function commit() {\n        // todo curried forEach\n        // we capture the real WeakSet.prototype.add above, in case someone\n        // changes it. The two-argument form of forEach passes the second\n        // argument as the 'this' binding, so we add to the correct set.\n        toFreeze.forEach(fringeSet.add, fringeSet);\n      }\n\n      enqueue(root);\n      dequeue();\n      // console.log(\"fringeSet\", fringeSet);\n      // console.log(\"prototype set:\", prototypes);\n      // console.log(\"toFreeze set:\", toFreeze);\n      checkPrototypes();\n      commit();\n\n      return root;\n    }\n\n    return harden;\n  }\n\n  function tameDate() {\n    const unsafeDate = Date;\n    // Date(anything) gives a string with the current time\n    // new Date(x) coerces x into a number and then returns a Date\n    // new Date() returns the current time, as a Date object\n    // new Date(undefined) returns a Date object which stringifies to 'Invalid Date'\n\n    const newDateConstructor = function Date(...args) {\n      if (new.target === undefined) {\n        // we were not called as a constructor\n        // this would normally return a string with the current time\n        return 'Invalid Date';\n      }\n      // constructor behavior: if we get arguments, we can safely pass them through\n      if (args.length > 0) {\n        return Reflect.construct(unsafeDate, args, new.target);\n        // todo: test that our constructor can still be subclassed\n      }\n      // no arguments: return a Date object, but invalid\n      return Reflect.construct(unsafeDate, [NaN], new.target);\n    };\n\n    Object.defineProperties(\n      newDateConstructor,\n      Object.getOwnPropertyDescriptors(unsafeDate),\n    );\n    // that will copy the .prototype too, so this next line is unnecessary\n    // newDateConstructor.prototype = unsafeDate.prototype;\n    unsafeDate.prototype.constructor = newDateConstructor;\n    // disable Date.now\n    newDateConstructor.now = () => NaN;\n\n    Date = newDateConstructor; // eslint-disable-line no-global-assign\n  }\n\n  function tameMath() {\n    // Math.random = () => 4; // https://www.xkcd.com/221\n    Math.random = () => {\n      throw Error('disabled');\n    };\n  }\n\n  /* global Intl */\n\n  function tameIntl() {\n    // todo: somehow fix these. These almost certainly don't enable the reading\n    // of side-channels, but we want things to be deterministic across\n    // runtimes. Best bet is to just disallow calling these functions without\n    // an explicit locale name.\n\n    // the whitelist may have deleted Intl entirely, so tolerate that\n    if (typeof Intl !== 'undefined') {\n      Intl.DateTimeFormat = () => {\n        throw Error('disabled');\n      };\n      Intl.NumberFormat = () => {\n        throw Error('disabled');\n      };\n      Intl.getCanonicalLocales = () => {\n        throw Error('disabled');\n      };\n    }\n    // eslint-disable-next-line no-extend-native\n    Object.prototype.toLocaleString = () => {\n      throw new Error('toLocaleString suppressed');\n    };\n  }\n\n  function tameError() {\n    if (!Object.isExtensible(Error)) {\n      throw Error('huh Error is not extensible');\n    }\n    /* this worked back when we were running it on a global, but stopped\n    working when we turned it into a shim */\n    /*\n    Object.defineProperty(Error.prototype, \"stack\",\n                          { get() { return 'stack suppressed'; } });\n    */\n    delete Error.captureStackTrace;\n    if ('captureStackTrace' in Error) {\n      throw Error('hey we could not remove Error.captureStackTrace');\n    }\n\n    // we might do this in the future\n    /*\n    const unsafeError = Error;\n    const newErrorConstructor = function Error(...args) {\n      return Reflect.construct(unsafeError, args, new.target);\n    };\n\n    newErrorConstructor.prototype = unsafeError.prototype;\n    newErrorConstructor.prototype.construct = newErrorConstructor;\n\n    Error = newErrorConstructor;\n\n    EvalError.__proto__ = newErrorConstructor;\n    RangeError.__proto__ = newErrorConstructor;\n    ReferenceError.__proto__ = newErrorConstructor;\n    SyntaxError.__proto__ = newErrorConstructor;\n    TypeError.__proto__ = newErrorConstructor;\n    URIError.__proto__ = newErrorConstructor;\n    */\n  }\n\n  function tameRegExp() {\n    delete RegExp.prototype.compile;\n    if ('compile' in RegExp.prototype) {\n      throw Error('hey we could not remove RegExp.prototype.compile');\n    }\n\n    // We want to delete RegExp.$1, as well as any other surprising properties.\n    // On some engines we can't just do 'delete RegExp.$1'.\n    const unsafeRegExp = RegExp;\n\n    // eslint-disable-next-line no-global-assign\n    RegExp = function RegExp(...args) {\n      return Reflect.construct(unsafeRegExp, args, new.target);\n    };\n    RegExp.prototype = unsafeRegExp.prototype;\n    unsafeRegExp.prototype.constructor = RegExp;\n\n    if ('$1' in RegExp) {\n      throw Error('hey we could not remove RegExp.$1');\n    }\n  }\n\n  /* global getAnonIntrinsics */\n\n  // Copyright (C) 2011 Google Inc.\n  // Copyright (C) 2018 Agoric\n  //\n  // Licensed under the Apache License, Version 2.0 (the \"License\");\n  // you may not use this file except in compliance with the License.\n  // You may obtain a copy of the License at\n  //\n  // http://www.apache.org/licenses/LICENSE-2.0\n  //\n  // Unless required by applicable law or agreed to in writing, software\n  // distributed under the License is distributed on an \"AS IS\" BASIS,\n  // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  // See the License for the specific language governing permissions and\n  // limitations under the License.\n\n  /* This is evaluated in an environment in which getAnonIntrinsics() is\n     already defined (by prepending the definition of getAnonIntrinsics to the\n     stringified removeProperties()), hence we don't use the following\n     import */\n  // import { getAnonIntrinsics } from './anonIntrinsics.js';\n\n  function removeProperties(global, whitelist) {\n    // walk global object, test against whitelist, delete\n\n    const uncurryThis = fn => (thisArg, ...args) =>\n      Reflect.apply(fn, thisArg, args);\n    const {\n      getOwnPropertyDescriptor: gopd,\n      getOwnPropertyNames: gopn,\n      keys,\n    } = Object;\n    const cleaning = new WeakMap();\n    const getProto = Object.getPrototypeOf;\n    const hop = uncurryThis(Object.prototype.hasOwnProperty);\n\n    const whiteTable = new WeakMap();\n\n    function addToWhiteTable(rootValue, rootPermit) {\n      /**\n       * The whiteTable should map from each path-accessible primordial\n       * object to the permit object that describes how it should be\n       * cleaned.\n       *\n       * We initialize the whiteTable only so that {@code getPermit} can\n       * process \"*\" inheritance using the whitelist, by walking actual\n       * inheritance chains.\n       */\n      const whitelistSymbols = [true, false, '*', 'maybeAccessor'];\n      function register(value, permit) {\n        if (value !== Object(value)) {\n          return;\n        }\n        if (typeof permit !== 'object') {\n          if (whitelistSymbols.indexOf(permit) < 0) {\n            throw new Error(\n              `syntax error in whitelist; unexpected value: ${permit}`,\n            );\n          }\n          return;\n        }\n        if (whiteTable.has(value)) {\n          throw new Error('primordial reachable through multiple paths');\n        }\n        whiteTable.set(value, permit);\n        keys(permit).forEach(name => {\n          // Use gopd to avoid invoking an accessor property.\n          // Accessor properties for which permit !== 'maybeAccessor'\n          // are caught later by clean().\n          const desc = gopd(value, name);\n          if (desc) {\n            register(desc.value, permit[name]);\n          }\n        });\n      }\n      register(rootValue, rootPermit);\n    }\n\n    /**\n     * Should the property named {@code name} be whitelisted on the\n     * {@code base} object, and if so, with what Permit?\n     *\n     * <p>If it should be permitted, return the Permit (where Permit =\n     * true | \"maybeAccessor\" | \"*\" | Record(Permit)), all of which are\n     * truthy. If it should not be permitted, return false.\n     */\n    function getPermit(base, name) {\n      let permit = whiteTable.get(base);\n      if (permit) {\n        if (hop(permit, name)) {\n          return permit[name];\n        }\n      }\n      // eslint-disable-next-line no-constant-condition\n      while (true) {\n        base = getProto(base); // eslint-disable-line no-param-reassign\n        if (base === null) {\n          return false;\n        }\n        permit = whiteTable.get(base);\n        if (permit && hop(permit, name)) {\n          const result = permit[name];\n          if (result === '*') {\n            return result;\n          }\n          return false;\n        }\n      }\n    }\n\n    /**\n     * Removes all non-whitelisted properties found by recursively and\n     * reflectively walking own property chains.\n     *\n     * <p>Inherited properties are not checked, because we require that\n     * inherited-from objects are otherwise reachable by this traversal.\n     */\n    function clean(value, prefix, num) {\n      if (value !== Object(value)) {\n        return;\n      }\n      if (cleaning.get(value)) {\n        return;\n      }\n\n      const proto = getProto(value);\n      if (proto !== null && !whiteTable.has(proto)) {\n        // reportItemProblem(rootReports, ses.severities.NOT_ISOLATED,\n        //                  'unexpected intrinsic', prefix + '.__proto__');\n        throw new Error(`unexpected intrinsic ${prefix}.__proto__`);\n      }\n\n      cleaning.set(value, true);\n      gopn(value).forEach(name => {\n        const path = prefix + (prefix ? '.' : '') + name;\n        const p = getPermit(value, name);\n        if (p) {\n          const desc = gopd(value, name);\n          if (hop(desc, 'value')) {\n            // Is a data property\n            const subValue = desc.value;\n            clean(subValue, path, num + 1);\n          } else if (p !== 'maybeAccessor') {\n            // We are not saying that it is safe for the prop to be\n            // unexpectedly an accessor; rather, it will be deleted\n            // and thus made safe.\n            // reportProperty(ses.severities.SAFE_SPEC_VIOLATION,\n            //               'Not a data property', path);\n            delete value[name]; // eslint-disable-line no-param-reassign\n          } else {\n            clean(desc.get, `${path}<getter>`, num + 1);\n            clean(desc.set, `${path}<setter>`, num + 1);\n          }\n        } else {\n          delete value[name]; // eslint-disable-line no-param-reassign\n        }\n      });\n    }\n\n    addToWhiteTable(global, whitelist.namedIntrinsics);\n    const intr = getAnonIntrinsics(global);\n    addToWhiteTable(intr, whitelist.anonIntrinsics);\n    clean(global, '', 0);\n  }\n\n  // Copyright (C) 2011 Google Inc.\n  // Copyright (C) 2018 Agoric\n  //\n  // Licensed under the Apache License, Version 2.0 (the \"License\");\n  // you may not use this file except in compliance with the License.\n  // You may obtain a copy of the License at\n  //\n  // https://www.apache.org/licenses/LICENSE-2.0\n  //\n  // Unless required by applicable law or agreed to in writing, software\n  // distributed under the License is distributed on an \"AS IS\" BASIS,\n  // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  // See the License for the specific language governing permissions and\n  // limitations under the License.\n\n  // TODO(erights): We should test for\n  // We now have a reason to omit Proxy from the whitelist.\n  // The makeBrandTester in repairES5 uses Allen's trick at\n  // https://esdiscuss.org/topic/tostringtag-spoofing-for-null-and-undefined#content-59\n  // , but testing reveals that, on FF 35.0.1, a proxy on an exotic\n  // object X will pass this brand test when X will. This is fixed as of\n  // FF Nightly 38.0a1.\n\n  /**\n   * <p>Qualifying platforms generally include all JavaScript platforms\n   * shown on <a href=\"http://kangax.github.com/es5-compat-table/\"\n   * >ECMAScript 5 compatibility table</a> that implement {@code\n   * Object.getOwnPropertyNames}. At the time of this writing,\n   * qualifying browsers already include the latest released versions of\n   * Internet Explorer (9), Firefox (4), Chrome (11), and Safari\n   * (5.0.5), their corresponding standalone (e.g., server-side) JavaScript\n   * engines, Rhino 1.73, and BESEN.\n   *\n   * <p>On such not-quite-ES5 platforms, some elements of these\n   * emulations may lose SES safety, as enumerated in the comment on\n   * each problem record in the {@code baseProblems} and {@code\n   * supportedProblems} array below. The platform must at least provide\n   * {@code Object.getOwnPropertyNames}, because it cannot reasonably be\n   * emulated.\n   *\n   * <p>This file is useful by itself, as it has no dependencies on the\n   * rest of SES. It creates no new global bindings, but merely repairs\n   * standard globals or standard elements reachable from standard\n   * globals. If the future-standard {@code WeakMap} global is present,\n   * as it is currently on FF7.0a1, then it will repair it in place. The\n   * one non-standard element that this file uses is {@code console} if\n   * present, in order to report the repairs it found necessary, in\n   * which case we use its {@code log, info, warn}, and {@code error}\n   * methods. If {@code console.log} is absent, then this file performs\n   * its repairs silently.\n   *\n   * <p>Generally, this file should be run as the first script in a\n   * JavaScript context (i.e. a browser frame), as it relies on other\n   * primordial objects and methods not yet being perturbed.\n   *\n   * <p>TODO(erights): This file tries to protect itself from some\n   * post-initialization perturbation by stashing some of the\n   * primordials it needs for later use, but this attempt is currently\n   * incomplete. We need to revisit this when we support Confined-ES5,\n   * as a variant of SES in which the primordials are not frozen. See\n   * previous failed attempt at <a\n   * href=\"https://codereview.appspot.com/5278046/\" >Speeds up\n   * WeakMap. Preparing to support unfrozen primordials.</a>. From\n   * analysis of this failed attempt, it seems that the only practical\n   * way to support CES is by use of two frames, where most of initSES\n   * runs in a SES frame, and so can avoid worrying about most of these\n   * perturbations.\n   */\n  function getAnonIntrinsics$1(global) {\n\n    const gopd = Object.getOwnPropertyDescriptor;\n    const getProto = Object.getPrototypeOf;\n\n    // ////////////// Undeniables and Intrinsics //////////////\n\n    /**\n     * The undeniables are the primordial objects which are ambiently\n     * reachable via compositions of strict syntax, primitive wrapping\n     * (new Object(x)), and prototype navigation (the equivalent of\n     * Object.getPrototypeOf(x) or x.__proto__). Although we could in\n     * theory monkey patch primitive wrapping or prototype navigation,\n     * we won't. Hence, without parsing, the following are undeniable no\n     * matter what <i>other</i> monkey patching we do to the primordial\n     * environment.\n     */\n\n    // The first element of each undeniableTuple is a string used to\n    // name the undeniable object for reporting purposes. It has no\n    // other programmatic use.\n    //\n    // The second element of each undeniableTuple should be the\n    // undeniable itself.\n    //\n    // The optional third element of the undeniableTuple, if present,\n    // should be an example of syntax, rather than use of a monkey\n    // patchable API, evaluating to a value from which the undeniable\n    // object in the second element can be reached by only the\n    // following steps:\n    // If the value is primitve, convert to an Object wrapper.\n    // Is the resulting object either the undeniable object, or does\n    // it inherit directly from the undeniable object?\n\n    function* aStrictGenerator() {} // eslint-disable-line no-empty-function\n    const Generator = getProto(aStrictGenerator);\n    async function* aStrictAsyncGenerator() {} // eslint-disable-line no-empty-function\n    const AsyncGenerator = getProto(aStrictAsyncGenerator);\n    async function aStrictAsyncFunction() {} // eslint-disable-line no-empty-function\n    const AsyncFunctionPrototype = getProto(aStrictAsyncFunction);\n\n    // TODO: this is dead code, but could be useful: make this the\n    // 'undeniables' object available via some API.\n\n    const undeniableTuples = [\n      ['Object.prototype', Object.prototype, {}],\n      ['Function.prototype', Function.prototype, function foo() {}],\n      ['Array.prototype', Array.prototype, []],\n      ['RegExp.prototype', RegExp.prototype, /x/],\n      ['Boolean.prototype', Boolean.prototype, true],\n      ['Number.prototype', Number.prototype, 1],\n      ['String.prototype', String.prototype, 'x'],\n      ['%Generator%', Generator, aStrictGenerator],\n      ['%AsyncGenerator%', AsyncGenerator, aStrictAsyncGenerator],\n      ['%AsyncFunction%', AsyncFunctionPrototype, aStrictAsyncFunction],\n    ];\n\n    undeniableTuples.forEach(tuple => {\n      const name = tuple[0];\n      const undeniable = tuple[1];\n      let start = tuple[2];\n      if (start === undefined) {\n        return;\n      }\n      start = Object(start);\n      if (undeniable === start) {\n        return;\n      }\n      if (undeniable === getProto(start)) {\n        return;\n      }\n      throw new Error(`Unexpected undeniable: ${undeniable}`);\n    });\n\n    function registerIteratorProtos(registery, base, name) {\n      const iteratorSym =\n        (global.Symbol && global.Symbol.iterator) || '@@iterator'; // used instead of a symbol on FF35\n\n      if (base[iteratorSym]) {\n        const anIter = base[iteratorSym]();\n        const anIteratorPrototype = getProto(anIter);\n        registery[name] = anIteratorPrototype; // eslint-disable-line no-param-reassign\n        const anIterProtoBase = getProto(anIteratorPrototype);\n        if (anIterProtoBase !== Object.prototype) {\n          if (!registery.IteratorPrototype) {\n            if (getProto(anIterProtoBase) !== Object.prototype) {\n              throw new Error(\n                '%IteratorPrototype%.__proto__ was not Object.prototype',\n              );\n            }\n            registery.IteratorPrototype = anIterProtoBase; // eslint-disable-line no-param-reassign\n          } else if (registery.IteratorPrototype !== anIterProtoBase) {\n            throw new Error(`unexpected %${name}%.__proto__`);\n          }\n        }\n      }\n    }\n\n    /**\n     * Get the intrinsics not otherwise reachable by named own property\n     * traversal. See\n     * https://people.mozilla.org/~jorendorff/es6-draft.html#sec-well-known-intrinsic-objects\n     * and the instrinsics section of whitelist.js\n     *\n     * <p>Unlike getUndeniables(), the result of sampleAnonIntrinsics()\n     * does depend on the current state of the primordials, so we must\n     * run this again after all other relevant monkey patching is done,\n     * in order to properly initialize cajaVM.intrinsics\n     */\n\n    // TODO: we can probably unwrap this into the outer function, and stop\n    // using a separately named 'sampleAnonIntrinsics'\n    function sampleAnonIntrinsics() {\n      const result = {};\n\n      // If there are still other ThrowTypeError objects left after\n      // noFuncPoison-ing, this should be caught by\n      // test_THROWTYPEERROR_NOT_UNIQUE below, so we assume here that\n      // this is the only surviving ThrowTypeError intrinsic.\n      // eslint-disable-next-line prefer-rest-params\n      result.ThrowTypeError = gopd(arguments, 'callee').get;\n\n      // Get the ES6 %ArrayIteratorPrototype%,\n      // %StringIteratorPrototype%, %MapIteratorPrototype%,\n      // %SetIteratorPrototype% and %IteratorPrototype% intrinsics, if\n      // present.\n      registerIteratorProtos(result, [], 'ArrayIteratorPrototype');\n      registerIteratorProtos(result, '', 'StringIteratorPrototype');\n      if (typeof Map === 'function') {\n        registerIteratorProtos(result, new Map(), 'MapIteratorPrototype');\n      }\n      if (typeof Set === 'function') {\n        registerIteratorProtos(result, new Set(), 'SetIteratorPrototype');\n      }\n\n      // Get the ES6 %GeneratorFunction% intrinsic, if present.\n      if (getProto(Generator) !== Function.prototype) {\n        throw new Error('Generator.__proto__ was not Function.prototype');\n      }\n      const GeneratorFunction = Generator.constructor;\n      if (getProto(GeneratorFunction) !== Function.prototype.constructor) {\n        throw new Error(\n          'GeneratorFunction.__proto__ was not Function.prototype.constructor',\n        );\n      }\n      result.GeneratorFunction = GeneratorFunction;\n      const genProtoBase = getProto(Generator.prototype);\n      if (genProtoBase !== result.IteratorPrototype) {\n        throw new Error('Unexpected Generator.prototype.__proto__');\n      }\n\n      // Get the ES6 %AsyncGeneratorFunction% intrinsic, if present.\n      if (getProto(AsyncGenerator) !== Function.prototype) {\n        throw new Error('AsyncGenerator.__proto__ was not Function.prototype');\n      }\n      const AsyncGeneratorFunction = AsyncGenerator.constructor;\n      if (getProto(AsyncGeneratorFunction) !== Function.prototype.constructor) {\n        throw new Error(\n          'AsyncGeneratorFunction.__proto__ was not Function.prototype.constructor',\n        );\n      }\n      result.AsyncGeneratorFunction = AsyncGeneratorFunction;\n      const AsyncGeneratorPrototype = AsyncGenerator.prototype;\n      result.AsyncIteratorPrototype = getProto(AsyncGeneratorPrototype);\n      // it appears that the only way to get an AsyncIteratorPrototype is\n      // through this getProto() process, so there's nothing to check it\n      // against\n      if (getProto(result.AsyncIteratorPrototype) !== Object.prototype) {\n        throw new Error(\n          'AsyncIteratorPrototype.__proto__ was not Object.prototype',\n        );\n      }\n\n      // Get the ES6 %AsyncFunction% intrinsic, if present.\n      if (getProto(AsyncFunctionPrototype) !== Function.prototype) {\n        throw new Error(\n          'AsyncFunctionPrototype.__proto__ was not Function.prototype',\n        );\n      }\n      const AsyncFunction = AsyncFunctionPrototype.constructor;\n      if (getProto(AsyncFunction) !== Function.prototype.constructor) {\n        throw new Error(\n          'AsyncFunction.__proto__ was not Function.prototype.constructor',\n        );\n      }\n      result.AsyncFunction = AsyncFunction;\n\n      // Get the ES6 %TypedArray% intrinsic, if present.\n      (function getTypedArray() {\n        if (!global.Float32Array) {\n          return;\n        }\n        const TypedArray = getProto(global.Float32Array);\n        if (TypedArray === Function.prototype) {\n          return;\n        }\n        if (getProto(TypedArray) !== Function.prototype) {\n          // http://bespin.cz/~ondras/html/classv8_1_1ArrayBufferView.html\n          // has me worried that someone might make such an intermediate\n          // object visible.\n          throw new Error('TypedArray.__proto__ was not Function.prototype');\n        }\n        result.TypedArray = TypedArray;\n      })();\n\n      Object.keys(result).forEach(name => {\n        if (result[name] === undefined) {\n          throw new Error(`Malformed intrinsic: ${name}`);\n        }\n      });\n\n      return result;\n    }\n\n    return sampleAnonIntrinsics();\n  }\n\n  function getAllPrimordials(global, anonIntrinsics) {\n\n    const root = {\n      global, // global plus all the namedIntrinsics\n      anonIntrinsics,\n    };\n    // todo: re-examine exactly which \"global\" we're freezing\n\n    return root;\n  }\n\n  // Copyright (C) 2011 Google Inc.\n  // Copyright (C) 2018 Agoric\n  //\n  // Licensed under the Apache License, Version 2.0 (the \"License\");\n  // you may not use this file except in compliance with the License.\n  // You may obtain a copy of the License at\n  //\n  // http://www.apache.org/licenses/LICENSE-2.0\n  //\n  // Unless required by applicable law or agreed to in writing, software\n  // distributed under the License is distributed on an \"AS IS\" BASIS,\n  // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  // See the License for the specific language governing permissions and\n  // limitations under the License.\n\n  /**\n   * @fileoverview Exports {@code ses.whitelist}, a recursively defined\n   * JSON record enumerating all the naming paths in the ES5.1 spec,\n   * those de-facto extensions that we judge to be safe, and SES and\n   * Dr. SES extensions provided by the SES runtime.\n   *\n   * <p>Assumes only ES3. Compatible with ES5, ES5-strict, or\n   * anticipated ES6.\n   *\n   * //provides ses.whitelist\n   * @author Mark S. Miller,\n   * @overrides ses, whitelistModule\n   */\n\n  /**\n   * <p>Each JSON record enumerates the disposition of the properties on\n   * some corresponding primordial object, with the root record\n   * representing the global object. For each such record, the values\n   * associated with its property names can be\n   * <ul>\n   * <li>Another record, in which case this property is simply\n   *     whitelisted and that next record represents the disposition of\n   *     the object which is its value. For example, {@code \"Object\"}\n   *     leads to another record explaining what properties {@code\n   *     \"Object\"} may have and how each such property, if present,\n   *     and its value should be tamed.\n   * <li>true, in which case this property is simply whitelisted. The\n   *     value associated with that property is still traversed and\n   *     tamed, but only according to the taming of the objects that\n   *     object inherits from. For example, {@code \"Object.freeze\"} leads\n   *     to true, meaning that the {@code \"freeze\"} property of {@code\n   *     Object} should be whitelisted and the value of the property (a\n   *     function) should be further tamed only according to the\n   *     markings of the other objects it inherits from, like {@code\n   *     \"Function.prototype\"} and {@code \"Object.prototype\").\n   *     If the property is an accessor property, it is not\n   *     whitelisted (as invoking an accessor might not be meaningful,\n   *     yet the accessor might return a value needing taming).\n   * <li>\"maybeAccessor\", in which case this accessor property is simply\n   *     whitelisted and its getter and/or setter are tamed according to\n   *     inheritance. If the property is not an accessor property, its\n   *     value is tamed according to inheritance.\n   * <li>\"*\", in which case this property on this object is whitelisted,\n   *     as is this property as inherited by all objects that inherit\n   *     from this object. The values associated with all such properties\n   *     are still traversed and tamed, but only according to the taming\n   *     of the objects that object inherits from. For example, {@code\n   *     \"Object.prototype.constructor\"} leads to \"*\", meaning that we\n   *     whitelist the {@code \"constructor\"} property on {@code\n   *     Object.prototype} and on every object that inherits from {@code\n   *     Object.prototype} that does not have a conflicting mark. Each\n   *     of these is tamed as if with true, so that the value of the\n   *     property is further tamed according to what other objects it\n   *     inherits from.\n   * <li>false, which suppresses permission inherited via \"*\".\n   * </ul>\n   *\n   * <p>TODO: We want to do for constructor: something weaker than '*',\n   * but rather more like what we do for [[Prototype]] links, which is\n   * that it is whitelisted only if it points at an object which is\n   * otherwise reachable by a whitelisted path.\n   *\n   * <p>The members of the whitelist are either\n   * <ul>\n   * <li>(uncommented) defined by the ES5.1 normative standard text,\n   * <li>(questionable) provides a source of non-determinism, in\n   *     violation of pure object-capability rules, but allowed anyway\n   *     since we've given up on restricting JavaScript to a\n   *     deterministic subset.\n   * <li>(ES5 Appendix B) common elements of de facto JavaScript\n   *     described by the non-normative Appendix B.\n   * <li>(Harmless whatwg) extensions documented at\n   *     <a href=\"http://wiki.whatwg.org/wiki/Web_ECMAScript\"\n   *     >http://wiki.whatwg.org/wiki/Web_ECMAScript</a> that seem to be\n   *     harmless. Note that the RegExp constructor extensions on that\n   *     page are <b>not harmless</b> and so must not be whitelisted.\n   * <li>(ES-Harmony proposal) accepted as \"proposal\" status for\n   *     EcmaScript-Harmony.\n   * </ul>\n   *\n   * <p>With the above encoding, there are some sensible whitelists we\n   * cannot express, such as marking a property both with \"*\" and a JSON\n   * record. This is an expedient decision based only on not having\n   * encountered such a need. Should we need this extra expressiveness,\n   * we'll need to refactor to enable a different encoding.\n   *\n   * <p>We factor out {@code true} into the variable {@code t} just to\n   * get a bit better compression from simple minifiers.\n   */\n\n  const t = true;\n  const j = true; // included in the Jessie runtime\n\n  let TypedArrayWhitelist; // defined and used below\n\n  var whitelist = {\n    // The accessible intrinsics which are not reachable by own\n    // property name traversal are listed here so that they are\n    // processed by the whitelist, although this also makes them\n    // accessible by this path.  See\n    // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-well-known-intrinsic-objects\n    // Of these, ThrowTypeError is the only one from ES5. All the\n    // rest were introduced in ES6.\n    anonIntrinsics: {\n      ThrowTypeError: {},\n      IteratorPrototype: {\n        // 25.1\n        // Technically, for SES-on-ES5, we should not need to\n        // whitelist 'next'. However, browsers are accidentally\n        // relying on it\n        // https://bugs.chromium.org/p/v8/issues/detail?id=4769#\n        // https://bugs.webkit.org/show_bug.cgi?id=154475\n        // and we will be whitelisting it as we transition to ES6\n        // anyway, so we unconditionally whitelist it now.\n        next: '*',\n        constructor: false,\n      },\n      ArrayIteratorPrototype: {},\n      StringIteratorPrototype: {},\n      MapIteratorPrototype: {},\n      SetIteratorPrototype: {},\n      // AsyncIteratorPrototype does not inherit from IteratorPrototype\n      AsyncIteratorPrototype: {},\n\n      // The %GeneratorFunction% intrinsic is the constructor of\n      // generator functions, so %GeneratorFunction%.prototype is\n      // the %Generator% intrinsic, which all generator functions\n      // inherit from. A generator function is effectively the\n      // constructor of its generator instances, so, for each\n      // generator function (e.g., \"g1\" on the diagram at\n      // http://people.mozilla.org/~jorendorff/figure-2.png )\n      // its .prototype is a prototype that its instances inherit\n      // from. Paralleling this structure, %Generator%.prototype,\n      // i.e., %GeneratorFunction%.prototype.prototype, is the\n      // object that all these generator function prototypes inherit\n      // from. The .next, .return and .throw that generator\n      // instances respond to are actually the builtin methods they\n      // inherit from this object.\n      GeneratorFunction: {\n        // 25.2\n        length: '*', // Not sure why this is needed\n        prototype: {\n          // 25.4\n          prototype: {\n            next: '*',\n            return: '*',\n            throw: '*',\n            constructor: '*', // Not sure why this is needed\n          },\n        },\n      },\n      AsyncGeneratorFunction: {\n        // 25.3\n        length: '*',\n        prototype: {\n          // 25.5\n          prototype: {\n            next: '*',\n            return: '*',\n            throw: '*',\n            constructor: '*', // Not sure why this is needed\n          },\n        },\n      },\n      AsyncFunction: {\n        // 25.7\n        length: '*',\n        prototype: '*',\n      },\n\n      TypedArray: (TypedArrayWhitelist = {\n        // 22.2\n        length: '*', // does not inherit from Function.prototype on Chrome\n        name: '*', // ditto\n        from: t,\n        of: t,\n        BYTES_PER_ELEMENT: '*',\n        prototype: {\n          buffer: 'maybeAccessor',\n          byteLength: 'maybeAccessor',\n          byteOffset: 'maybeAccessor',\n          copyWithin: '*',\n          entries: '*',\n          every: '*',\n          fill: '*',\n          filter: '*',\n          find: '*',\n          findIndex: '*',\n          forEach: '*',\n          includes: '*',\n          indexOf: '*',\n          join: '*',\n          keys: '*',\n          lastIndexOf: '*',\n          length: 'maybeAccessor',\n          map: '*',\n          reduce: '*',\n          reduceRight: '*',\n          reverse: '*',\n          set: '*',\n          slice: '*',\n          some: '*',\n          sort: '*',\n          subarray: '*',\n          values: '*',\n          BYTES_PER_ELEMENT: '*',\n        },\n      }),\n    },\n\n    namedIntrinsics: {\n      // In order according to\n      // http://www.ecma-international.org/ecma-262/ with chapter\n      // numbers where applicable\n\n      // 18 The Global Object\n\n      // 18.1\n      Infinity: j,\n      NaN: j,\n      undefined: j,\n\n      // 18.2\n      // eval: t,                      // Whitelisting under separate control\n      // by TAME_GLOBAL_EVAL in startSES.js\n      isFinite: t,\n      isNaN: t,\n      parseFloat: t,\n      parseInt: t,\n      decodeURI: t,\n      decodeURIComponent: t,\n      encodeURI: t,\n      encodeURIComponent: t,\n\n      // 19 Fundamental Objects\n\n      Object: {\n        // 19.1\n        assign: t, // ES-Harmony\n        create: t,\n        defineProperties: t, // ES-Harmony\n        defineProperty: t,\n        entries: t, // ES-Harmony\n        freeze: j,\n        getOwnPropertyDescriptor: t,\n        getOwnPropertyDescriptors: t, // proposed ES-Harmony\n        getOwnPropertyNames: t,\n        getOwnPropertySymbols: t, // ES-Harmony\n        getPrototypeOf: t,\n        is: j, // ES-Harmony\n        isExtensible: t,\n        isFrozen: t,\n        isSealed: t,\n        keys: t,\n        preventExtensions: j,\n        seal: j,\n        setPrototypeOf: t, // ES-Harmony\n        values: t, // ES-Harmony\n\n        prototype: {\n          // B.2.2\n          // __proto__: t, whitelisted manually in startSES.js\n          __defineGetter__: t,\n          __defineSetter__: t,\n          __lookupGetter__: t,\n          __lookupSetter__: t,\n\n          constructor: '*',\n          hasOwnProperty: t,\n          isPrototypeOf: t,\n          propertyIsEnumerable: t,\n          toLocaleString: '*',\n          toString: '*',\n          valueOf: '*',\n\n          // Generally allowed\n          [Symbol.iterator]: '*',\n          [Symbol.toPrimitive]: '*',\n          [Symbol.toStringTag]: '*',\n          [Symbol.unscopables]: '*',\n        },\n      },\n\n      Function: {\n        // 19.2\n        length: t,\n        prototype: {\n          apply: t,\n          bind: t,\n          call: t,\n          [Symbol.hasInstance]: '*',\n\n          // 19.2.4 instances\n          length: '*',\n          name: '*', // ES-Harmony\n          prototype: '*',\n          arity: '*', // non-std, deprecated in favor of length\n\n          // Generally allowed\n          [Symbol.species]: 'maybeAccessor', // ES-Harmony?\n        },\n      },\n\n      Boolean: {\n        // 19.3\n        prototype: t,\n      },\n\n      Symbol: {\n        // 19.4               all ES-Harmony\n        asyncIterator: t, // proposed? ES-Harmony\n        for: t,\n        hasInstance: t,\n        isConcatSpreadable: t,\n        iterator: t,\n        keyFor: t,\n        match: t,\n        matchAll: t,\n        replace: t,\n        search: t,\n        species: t,\n        split: t,\n        toPrimitive: t,\n        toStringTag: t,\n        unscopables: t,\n        prototype: t,\n      },\n\n      Error: {\n        // 19.5\n        prototype: {\n          name: '*',\n          message: '*',\n        },\n      },\n      // In ES6 the *Error \"subclasses\" of Error inherit from Error,\n      // since constructor inheritance generally mirrors prototype\n      // inheritance. As explained at\n      // https://code.google.com/p/google-caja/issues/detail?id=1963 ,\n      // debug.js hides away the Error constructor itself, and so needs\n      // to rewire these \"subclass\" constructors. Until we have a more\n      // general mechanism, please maintain this list of whitelisted\n      // subclasses in sync with the list in debug.js of subclasses to\n      // be rewired.\n      EvalError: {\n        prototype: t,\n      },\n      RangeError: {\n        prototype: t,\n      },\n      ReferenceError: {\n        prototype: t,\n      },\n      SyntaxError: {\n        prototype: t,\n      },\n      TypeError: {\n        prototype: t,\n      },\n      URIError: {\n        prototype: t,\n      },\n\n      // 20 Numbers and Dates\n\n      Number: {\n        // 20.1\n        EPSILON: t, // ES-Harmony\n        isFinite: j, // ES-Harmony\n        isInteger: t, // ES-Harmony\n        isNaN: j, // ES-Harmony\n        isSafeInteger: j, // ES-Harmony\n        MAX_SAFE_INTEGER: j, // ES-Harmony\n        MAX_VALUE: t,\n        MIN_SAFE_INTEGER: j, // ES-Harmony\n        MIN_VALUE: t,\n        NaN: t,\n        NEGATIVE_INFINITY: t,\n        parseFloat: t, // ES-Harmony\n        parseInt: t, // ES-Harmony\n        POSITIVE_INFINITY: t,\n        prototype: {\n          toExponential: t,\n          toFixed: t,\n          toPrecision: t,\n        },\n      },\n\n      Math: {\n        // 20.2\n        E: j,\n        LN10: j,\n        LN2: j,\n        LOG10E: t,\n        LOG2E: t,\n        PI: j,\n        SQRT1_2: t,\n        SQRT2: t,\n\n        abs: j,\n        acos: t,\n        acosh: t, // ES-Harmony\n        asin: t,\n        asinh: t, // ES-Harmony\n        atan: t,\n        atanh: t, // ES-Harmony\n        atan2: t,\n        cbrt: t, // ES-Harmony\n        ceil: j,\n        clz32: t, // ES-Harmony\n        cos: t,\n        cosh: t, // ES-Harmony\n        exp: t,\n        expm1: t, // ES-Harmony\n        floor: j,\n        fround: t, // ES-Harmony\n        hypot: t, // ES-Harmony\n        imul: t, // ES-Harmony\n        log: j,\n        log1p: t, // ES-Harmony\n        log10: j, // ES-Harmony\n        log2: j, // ES-Harmony\n        max: j,\n        min: j,\n        pow: j,\n        random: t, // questionable\n        round: j,\n        sign: t, // ES-Harmony\n        sin: t,\n        sinh: t, // ES-Harmony\n        sqrt: j,\n        tan: t,\n        tanh: t, // ES-Harmony\n        trunc: j, // ES-Harmony\n      },\n\n      // no-arg Date constructor is questionable\n      Date: {\n        // 20.3\n        now: t, // questionable\n        parse: t,\n        UTC: t,\n        prototype: {\n          // Note: coordinate this list with maintanence of repairES5.js\n          getDate: t,\n          getDay: t,\n          getFullYear: t,\n          getHours: t,\n          getMilliseconds: t,\n          getMinutes: t,\n          getMonth: t,\n          getSeconds: t,\n          getTime: t,\n          getTimezoneOffset: t,\n          getUTCDate: t,\n          getUTCDay: t,\n          getUTCFullYear: t,\n          getUTCHours: t,\n          getUTCMilliseconds: t,\n          getUTCMinutes: t,\n          getUTCMonth: t,\n          getUTCSeconds: t,\n          setDate: t,\n          setFullYear: t,\n          setHours: t,\n          setMilliseconds: t,\n          setMinutes: t,\n          setMonth: t,\n          setSeconds: t,\n          setTime: t,\n          setUTCDate: t,\n          setUTCFullYear: t,\n          setUTCHours: t,\n          setUTCMilliseconds: t,\n          setUTCMinutes: t,\n          setUTCMonth: t,\n          setUTCSeconds: t,\n          toDateString: t,\n          toISOString: t,\n          toJSON: t,\n          toLocaleDateString: t,\n          toLocaleString: t,\n          toLocaleTimeString: t,\n          toTimeString: t,\n          toUTCString: t,\n\n          // B.2.4\n          getYear: t,\n          setYear: t,\n          toGMTString: t,\n        },\n      },\n\n      // 21 Text Processing\n\n      String: {\n        // 21.2\n        fromCharCode: j,\n        fromCodePoint: t, // ES-Harmony\n        raw: j, // ES-Harmony\n        prototype: {\n          charAt: t,\n          charCodeAt: t,\n          codePointAt: t, // ES-Harmony\n          concat: t,\n          endsWith: j, // ES-Harmony\n          includes: t, // ES-Harmony\n          indexOf: j,\n          lastIndexOf: j,\n          localeCompare: t,\n          match: t,\n          normalize: t, // ES-Harmony\n          padEnd: t, // ES-Harmony\n          padStart: t, // ES-Harmony\n          repeat: t, // ES-Harmony\n          replace: t,\n          search: t,\n          slice: j,\n          split: t,\n          startsWith: j, // ES-Harmony\n          substring: t,\n          toLocaleLowerCase: t,\n          toLocaleUpperCase: t,\n          toLowerCase: t,\n          toUpperCase: t,\n          trim: t,\n\n          // B.2.3\n          substr: t,\n          anchor: t,\n          big: t,\n          blink: t,\n          bold: t,\n          fixed: t,\n          fontcolor: t,\n          fontsize: t,\n          italics: t,\n          link: t,\n          small: t,\n          strike: t,\n          sub: t,\n          sup: t,\n\n          trimLeft: t, // non-standard\n          trimRight: t, // non-standard\n\n          // 21.1.4 instances\n          length: '*',\n        },\n      },\n\n      RegExp: {\n        // 21.2\n        prototype: {\n          exec: t,\n          flags: 'maybeAccessor',\n          global: 'maybeAccessor',\n          ignoreCase: 'maybeAccessor',\n          [Symbol.match]: '*', // ES-Harmony\n          multiline: 'maybeAccessor',\n          [Symbol.replace]: '*', // ES-Harmony\n          [Symbol.search]: '*', // ES-Harmony\n          source: 'maybeAccessor',\n          [Symbol.split]: '*', // ES-Harmony\n          sticky: 'maybeAccessor',\n          test: t,\n          unicode: 'maybeAccessor', // ES-Harmony\n          dotAll: 'maybeAccessor', // proposed ES-Harmony\n\n          // B.2.5\n          compile: false, // UNSAFE. Purposely suppressed\n\n          // 21.2.6 instances\n          lastIndex: '*',\n          options: '*', // non-std\n        },\n      },\n\n      // 22 Indexed Collections\n\n      Array: {\n        // 22.1\n        from: j,\n        isArray: t,\n        of: j, // ES-Harmony?\n        prototype: {\n          concat: t,\n          copyWithin: t, // ES-Harmony\n          entries: t, // ES-Harmony\n          every: t,\n          fill: t, // ES-Harmony\n          filter: j,\n          find: t, // ES-Harmony\n          findIndex: t, // ES-Harmony\n          forEach: j,\n          includes: t, // ES-Harmony\n          indexOf: j,\n          join: t,\n          keys: t, // ES-Harmony\n          lastIndexOf: j,\n          map: j,\n          pop: j,\n          push: j,\n          reduce: j,\n          reduceRight: j,\n          reverse: t,\n          shift: j,\n          slice: j,\n          some: t,\n          sort: t,\n          splice: t,\n          unshift: j,\n          values: t, // ES-Harmony\n\n          // 22.1.4 instances\n          length: '*',\n        },\n      },\n\n      // 22.2 Typed Array stuff\n      // TODO: Not yet organized according to spec order\n\n      Int8Array: TypedArrayWhitelist,\n      Uint8Array: TypedArrayWhitelist,\n      Uint8ClampedArray: TypedArrayWhitelist,\n      Int16Array: TypedArrayWhitelist,\n      Uint16Array: TypedArrayWhitelist,\n      Int32Array: TypedArrayWhitelist,\n      Uint32Array: TypedArrayWhitelist,\n      Float32Array: TypedArrayWhitelist,\n      Float64Array: TypedArrayWhitelist,\n\n      // 23 Keyed Collections          all ES-Harmony\n\n      Map: {\n        // 23.1\n        prototype: {\n          clear: j,\n          delete: j,\n          entries: j,\n          forEach: j,\n          get: j,\n          has: j,\n          keys: j,\n          set: j,\n          size: 'maybeAccessor',\n          values: j,\n        },\n      },\n\n      Set: {\n        // 23.2\n        prototype: {\n          add: j,\n          clear: j,\n          delete: j,\n          entries: j,\n          forEach: j,\n          has: j,\n          keys: j,\n          size: 'maybeAccessor',\n          values: j,\n        },\n      },\n\n      WeakMap: {\n        // 23.3\n        prototype: {\n          // Note: coordinate this list with maintenance of repairES5.js\n          delete: j,\n          get: j,\n          has: j,\n          set: j,\n        },\n      },\n\n      WeakSet: {\n        // 23.4\n        prototype: {\n          add: j,\n          delete: j,\n          has: j,\n        },\n      },\n\n      // 24 Structured Data\n\n      ArrayBuffer: {\n        // 24.1            all ES-Harmony\n        isView: t,\n        length: t, // does not inherit from Function.prototype on Chrome\n        name: t, // ditto\n        prototype: {\n          byteLength: 'maybeAccessor',\n          slice: t,\n        },\n      },\n\n      // 24.2 TODO: Omitting SharedArrayBuffer for now\n\n      DataView: {\n        // 24.3               all ES-Harmony\n        length: t, // does not inherit from Function.prototype on Chrome\n        name: t, // ditto\n        BYTES_PER_ELEMENT: '*', // non-standard. really?\n        prototype: {\n          buffer: 'maybeAccessor',\n          byteOffset: 'maybeAccessor',\n          byteLength: 'maybeAccessor',\n          getFloat32: t,\n          getFloat64: t,\n          getInt8: t,\n          getInt16: t,\n          getInt32: t,\n          getUint8: t,\n          getUint16: t,\n          getUint32: t,\n          setFloat32: t,\n          setFloat64: t,\n          setInt8: t,\n          setInt16: t,\n          setInt32: t,\n          setUint8: t,\n          setUint16: t,\n          setUint32: t,\n        },\n      },\n\n      // 24.4 TODO: Omitting Atomics for now\n\n      JSON: {\n        // 24.5\n        parse: j,\n        stringify: j,\n      },\n\n      // 25 Control Abstraction Objects\n\n      Promise: {\n        // 25.4\n        all: j,\n        race: j,\n        reject: j,\n        resolve: j,\n        prototype: {\n          catch: t,\n          then: j,\n          finally: t, // proposed ES-Harmony\n\n          // nanoq.js\n          get: t,\n          put: t,\n          del: t,\n          post: t,\n          invoke: t,\n          fapply: t,\n          fcall: t,\n\n          // Temporary compat with the old makeQ.js\n          send: t,\n          delete: t,\n          end: t,\n        },\n      },\n\n      // nanoq.js\n      Q: {\n        all: t,\n        race: t,\n        reject: t,\n        resolve: t,\n\n        join: t,\n        isPassByCopy: t,\n        passByCopy: t,\n        makeRemote: t,\n        makeFar: t,\n\n        // Temporary compat with the old makeQ.js\n        shorten: t,\n        isPromise: t,\n        async: t,\n        rejected: t,\n        promise: t,\n        delay: t,\n        memoize: t,\n        defer: t,\n      },\n\n      // 26 Reflection\n\n      Reflect: {\n        // 26.1\n        apply: t,\n        construct: t,\n        defineProperty: t,\n        deleteProperty: t,\n        get: t,\n        getOwnPropertyDescriptor: t,\n        getPrototypeOf: t,\n        has: t,\n        isExtensible: t,\n        ownKeys: t,\n        preventExtensions: t,\n        set: t,\n        setPrototypeOf: t,\n      },\n\n      Proxy: {\n        // 26.2\n        revocable: t,\n      },\n\n      // Appendix B\n\n      // B.2.1\n      escape: t,\n      unescape: t,\n\n      // B.2.5 (RegExp.prototype.compile) is marked 'false' up in 21.2\n\n      // Other\n\n      StringMap: {\n        // A specialized approximation of ES-Harmony's Map.\n        prototype: {}, // Technically, the methods should be on the prototype,\n        // but doing so while preserving encapsulation will be\n        // needlessly expensive for current usage.\n      },\n\n      Realm: {\n        makeRootRealm: t,\n        makeCompartment: t,\n        prototype: {\n          global: 'maybeAccessor',\n          evaluate: t,\n        },\n      },\n\n      SES: {\n        confine: t,\n        confineExpr: t,\n      },\n\n      Nat: j,\n      def: j,\n    },\n  };\n\n  function makeConsole(parentConsole) {\n    /* 'parentConsole' is the parent Realm's original 'console' object. We must\n       wrap it, exposing a 'console' with a 'console.log' (and perhaps others)\n       to the local realm, without allowing access to the original 'console',\n       its return values, or its exception objects, any of which could be used\n       to break confinement via the unsafe Function constructor. */\n\n    // callAndWrapError is copied from proposal-realms/shim/src/realmFacade.js\n    // Like Realm.apply except that it catches anything thrown and rethrows it\n    // as an Error from this realm\n\n    const errorConstructors = new Map([\n      ['EvalError', EvalError],\n      ['RangeError', RangeError],\n      ['ReferenceError', ReferenceError],\n      ['SyntaxError', SyntaxError],\n      ['TypeError', TypeError],\n      ['URIError', URIError],\n    ]);\n\n    function callAndWrapError(target, ...args) {\n      try {\n        return target(...args);\n      } catch (err) {\n        if (Object(err) !== err) {\n          // err is a primitive value, which is safe to rethrow\n          throw err;\n        }\n        let eName;\n        let eMessage;\n        let eStack;\n        try {\n          // The child environment might seek to use 'err' to reach the\n          // parent's intrinsics and corrupt them. `${err.name}` will cause\n          // string coercion of 'err.name'. If err.name is an object (probably\n          // a String of the parent Realm), the coercion uses\n          // err.name.toString(), which is under the control of the parent. If\n          // err.name were a primitive (e.g. a number), it would use\n          // Number.toString(err.name), using the child's version of Number\n          // (which the child could modify to capture its argument for later\n          // use), however primitives don't have properties like .prototype so\n          // they aren't useful for an attack.\n          eName = `${err.name}`;\n          eMessage = `${err.message}`;\n          eStack = `${err.stack}`;\n          // eName/eMessage/eStack are now child-realm primitive strings, and\n          // safe to expose\n        } catch (ignored) {\n          // if err.name.toString() throws, keep the (parent realm) Error away\n          // from the child\n          throw new Error('unknown error');\n        }\n        const ErrorConstructor = errorConstructors.get(eName) || Error;\n        try {\n          throw new ErrorConstructor(eMessage);\n        } catch (err2) {\n          err2.stack = eStack; // replace with the captured inner stack\n          throw err2;\n        }\n      }\n    }\n\n    const newConsole = {};\n    const passThrough = [\n      'log',\n      'info',\n      'warn',\n      'error',\n      'group',\n      'groupEnd',\n      'trace',\n      'time',\n      'timeLog',\n      'timeEnd',\n    ];\n    // TODO: those are the properties that MDN documents. Node.js has a bunch\n    // of additional ones that I didn't include, which might be appropriate.\n\n    passThrough.forEach(name => {\n      // TODO: do we reveal the presence/absence of these properties to the\n      // child realm, thus exposing nondeterminism (and a hint of what platform\n      // you might be on) when it is constructed with {consoleMode: allow} ? Or\n      // should we expose the same set all the time, but silently ignore calls\n      // to the missing ones, to hide that variation? We might even consider\n      // adding console.* to the child realm all the time, even without\n      // consoleMode:allow, but ignore the calls unless the mode is enabled.\n      if (name in parentConsole) {\n        const orig = parentConsole[name];\n        // TODO: in a stack trace, this appears as\n        // \"Object.newConsole.(anonymous function) [as trace]\"\n        // can we make that \"newConsole.trace\" ?\n        newConsole[name] = function newerConsole(...args) {\n          callAndWrapError(orig, ...args);\n        };\n      }\n    });\n\n    return newConsole;\n  }\n\n  function makeMakeRequire(r, harden) {\n    function makeRequire(config) {\n      const cache = new Map();\n\n      function build(what) {\n        // This approach denies callers the ability to use inheritance to\n        // manage their config objects, but a simple \"if (what in config)\"\n        // predicate would also be truthy for e.g. \"toString\" and other\n        // properties of Object.prototype, and require('toString') should be\n        // legal if and only if the config object included an own-property\n        // named 'toString'. Incidentally, this could have been\n        // \"config.hasOwnProperty(what)\" but eslint complained.\n        if (!Object.prototype.hasOwnProperty.call(config, what)) {\n          throw new Error(`Cannot find module '${what}'`);\n        }\n        const c = config[what];\n\n        // some modules are hard-coded ways to access functionality that SES\n        // provides directly\n        if (what === '@agoric/harden') {\n          return harden;\n        }\n\n        // If the config points at a simple function, it must be a pure\n        // function with no dependencies (i.e. no 'require' or 'import', no\n        // calls to other functions defined in the same file but outside the\n        // function body). We stringify it and evaluate it inside this realm.\n        if (typeof c === 'function') {\n          return r.evaluate(`(${c})`);\n        }\n\n        // else we treat it as an object with an 'attenuatorSource' property\n        // that defines an attenuator function, which we evaluate. We then\n        // invoke it with the config object, which can contain authorities that\n        // it can wrap. The return value from this invocation is the module\n        // object that gets returned from require(). The attenuator function\n        // and the module it returns are in-realm, the authorities it wraps\n        // will be out-of-realm.\n        const src = `(${c.attenuatorSource})`;\n        const attenuator = r.evaluate(src);\n        return attenuator(c);\n      }\n\n      function newRequire(whatArg) {\n        const what = `${whatArg}`;\n        if (!cache.has(what)) {\n          cache.set(what, harden(build(what)));\n        }\n        return cache.get(what);\n      }\n\n      return newRequire;\n    }\n\n    return makeRequire;\n  }\n\n  // Copyright (C) 2018 Agoric\n\n  function createSESWithRealmConstructor(creatorStrings, Realm) {\n    function makeSESRootRealm(options) {\n      // eslint-disable-next-line no-param-reassign\n      options = Object(options); // Todo: sanitize\n      const shims = [];\n      const wl = JSON.parse(JSON.stringify(options.whitelist || whitelist));\n\n      // \"allow\" enables real Date.now(), anything else gets NaN\n      // (it'd be nice to allow a fixed numeric value, but too hard to\n      // implement right now)\n      if (options.dateNowMode !== 'allow') {\n        shims.push(`(${tameDate})();`);\n      }\n\n      if (options.mathRandomMode !== 'allow') {\n        shims.push(`(${tameMath})();`);\n      }\n\n      // Intl is disabled entirely for now, deleted by removeProperties. If we\n      // want to bring it back (under the control of this option), we'll need\n      // to add it to the whitelist too, as well as taming it properly.\n      if (options.intlMode !== 'allow') {\n        // this shim also disables Object.prototype.toLocaleString\n        shims.push(`(${tameIntl})();`);\n      }\n\n      if (options.errorStackMode !== 'allow') {\n        shims.push(`(${tameError})();`);\n      } else {\n        // if removeProperties cleans these things from Error, v8 won't provide\n        // stack traces or even toString on exceptions, and then Node.js prints\n        // uncaught exceptions as \"undefined\" instead of a type/message/stack.\n        // So if we're allowing stack traces, make sure the whitelist is\n        // augmented to include them.\n        wl.namedIntrinsics.Error.captureStackTrace = true;\n        wl.namedIntrinsics.Error.stackTraceLimit = true;\n        wl.namedIntrinsics.Error.prepareStackTrace = true;\n      }\n\n      if (options.regexpMode !== 'allow') {\n        shims.push(`(${tameRegExp})();`);\n      }\n\n      // The getAnonIntrinsics function might be renamed by e.g. rollup. The\n      // removeProperties() function references it by name, so we need to force\n      // it to have a specific name.\n      const removeProp = `const getAnonIntrinsics = (${getAnonIntrinsics$1});\n               (${removeProperties})(this, ${JSON.stringify(wl)})`;\n      shims.push(removeProp);\n\n      const r = Realm.makeRootRealm({ shims });\n\n      // Build a harden() with an empty fringe. It will be populated later when\n      // we call harden(allIntrinsics).\n      const makeHardenerSrc = `(${makeHardener})`;\n      const harden = r.evaluate(makeHardenerSrc)(\n        undefined,\n        options.hardenerOptions,\n      );\n\n      const b = r.evaluate(creatorStrings);\n      b.createSESInThisRealm(r.global, creatorStrings, r);\n      // b.removeProperties(r.global);\n\n      if (options.consoleMode === 'allow') {\n        const s = `(${makeConsole})`;\n        r.global.console = r.evaluate(s)(console);\n      }\n\n      // Finally freeze all the primordials, and the global object. This must\n      // be the last thing we do that modifies the Realm's globals.\n      const anonIntrinsics = r.evaluate(`(${getAnonIntrinsics$1})`)(r.global);\n      const allIntrinsics = r.evaluate(`(${getAllPrimordials})`)(\n        r.global,\n        anonIntrinsics,\n      );\n      harden(allIntrinsics);\n\n      // build the makeRequire helper, glue it to the new Realm\n      r.makeRequire = harden(r.evaluate(`(${makeMakeRequire})`)(r, harden));\n\n      return r;\n    }\n    const SES = {\n      makeSESRootRealm,\n    };\n\n    return SES;\n  }\n\n  function createSESInThisRealm(global, creatorStrings, parentRealm) {\n    // eslint-disable-next-line no-param-reassign,no-undef\n    global.SES = createSESWithRealmConstructor(creatorStrings, Realm);\n    // todo: wrap exceptions, effectively undoing the wrapping that\n    // Realm.evaluate does\n\n    const errorConstructors = new Map([\n      ['EvalError', EvalError],\n      ['RangeError', RangeError],\n      ['ReferenceError', ReferenceError],\n      ['SyntaxError', SyntaxError],\n      ['TypeError', TypeError],\n      ['URIError', URIError],\n    ]);\n\n    // callAndWrapError is copied from the Realm shim. Our SES.confine (from\n    // inside the realm) delegates to Realm.evaluate (from outside the realm),\n    // but we need the exceptions to come from our own realm, so we use this to\n    // reverse the shim's own callAndWrapError. TODO: look for a reasonable way\n    // to avoid the double-wrapping, maybe by changing the shim/Realms-spec to\n    // provide the safeEvaluator as a Realm.evaluate method (inside a realm).\n    // That would make this trivial: global.SES = Realm.evaluate (modulo\n    // potential 'this' issues)\n\n    // the comments here were written from the POV of a parent defending itself\n    // against a malicious child realm. In this case, we are the child.\n\n    function callAndWrapError(target, ...args) {\n      try {\n        return target(...args);\n      } catch (err) {\n        if (Object(err) !== err) {\n          // err is a primitive value, which is safe to rethrow\n          throw err;\n        }\n        let eName;\n        let eMessage;\n        let eStack;\n        try {\n          // The child environment might seek to use 'err' to reach the\n          // parent's intrinsics and corrupt them. `${err.name}` will cause\n          // string coercion of 'err.name'. If err.name is an object (probably\n          // a String of the parent Realm), the coercion uses\n          // err.name.toString(), which is under the control of the parent. If\n          // err.name were a primitive (e.g. a number), it would use\n          // Number.toString(err.name), using the child's version of Number\n          // (which the child could modify to capture its argument for later\n          // use), however primitives don't have properties like .prototype so\n          // they aren't useful for an attack.\n          eName = `${err.name}`;\n          eMessage = `${err.message}`;\n          eStack = `${err.stack}`;\n          // eName/eMessage/eStack are now child-realm primitive strings, and\n          // safe to expose\n        } catch (ignored) {\n          // if err.name.toString() throws, keep the (parent realm) Error away\n          // from the child\n          throw new Error('unknown error');\n        }\n        const ErrorConstructor = errorConstructors.get(eName) || Error;\n        try {\n          throw new ErrorConstructor(eMessage);\n        } catch (err2) {\n          err2.stack = eStack; // replace with the captured inner stack\n          throw err2;\n        }\n      }\n    }\n\n    // We must not allow other child code to access that object. SES.confine\n    // closes over the parent's Realm object so it shouldn't be accessible from\n    // the outside.\n\n    // eslint-disable-next-line no-param-reassign\n    global.SES.confine = (code, endowments) =>\n      callAndWrapError(() => parentRealm.evaluate(code, endowments));\n    // eslint-disable-next-line no-param-reassign\n    global.SES.confineExpr = (code, endowments) =>\n      callAndWrapError(() => parentRealm.evaluate(`(${code})`, endowments));\n  }\n\n  // Copyright (C) 2018 Agoric\n\n  exports.createSESInThisRealm = createSESInThisRealm;\n  exports.createSESWithRealmConstructor = createSESWithRealmConstructor;\n\n  return exports;\n\n}({}))",_e=Oe(Te,ue);var Pe=_e;exports.default=Pe;
},{"@agoric/make-hardener":"Pi9h","vm":"boWn"}],"kax4":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.default=void 0;var t=function(){var t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:new WeakSet,n=function(n){var e=new WeakMap;return function n(e,r,o){if(Object(e)!==e||t.has(e))return e;var u=o.get(e);if(u)return u;var i=function(t){return n(t,o,r)},c=function(t){try{return n(t(),r,o)}catch(e){throw n(e,r,o)}},f=function(t){return c(function(){throw TypeError(t)})},s=new Proxy(e,{defineProperty:function(t,n,e){throw f("Cannot define property ".concat(JSON.stringify(String(n))," on insulated object"))},setPrototypeOf:function(t,n){throw f("Cannot set prototype of insulated object")},set:function(t,n,e){throw f("Cannot set property ".concat(JSON.stringify(String(n))," on insulated object"))},isExtensible:function(t){return Reflect.isExtensible(t)},preventExtensions:function(t){if(!Reflect.isExtensible(t))return!0;throw f("Cannot prevent extensions of insulated object")},get:function(t,n,e){return c(function(){return Reflect.get(t,n,e)})},getPrototypeOf:function(t){return c(function(){return Reflect.getPrototypeOf(t)})},ownKeys:function(t){return c(function(){return Reflect.ownKeys(t)})},has:function(t,n){return c(function(){return n in t})},getOwnPropertyDescriptor:function(t,n){return c(function(){return Reflect.getOwnPropertyDescriptor(t,n)})},apply:function(t,n,e){var r=i(n),o=e.map(i);return c(function(){return Reflect.apply(t,r,o)})},construct:function(t,n){var e=n.map(i);return c(function(){return Reflect.construct(t,e)})}});return o.set(e,s),r.set(s,e),s}(n,new WeakMap,e)};return t.add(n),n},n=t;exports.default=n;
},{}],"eb5I":[function(require,module,exports) {
var global = arguments[3];
var e=arguments[3];function n(e){return o(e)||r(e)||t()}function t(){throw new TypeError("Invalid attempt to spread non-iterable instance")}function r(e){if(Symbol.iterator in Object(e)||"[object Arguments]"===Object.prototype.toString.call(e))return Array.from(e)}function o(e){if(Array.isArray(e)){for(var n=0,t=new Array(e.length);n<e.length;n++)t[n]=e[n];return t}}Object.defineProperty(exports,"__esModule",{value:!0}),exports.default=void 0;var a=Object.freeze;function i(e,t){e=""+e;var r=Object.getOwnPropertyNames(t),o="(function(".concat(r.join(","),') { "use strict"; return (').concat(e,"\n);\n})\n//# sourceURL=data:").concat(encodeURIComponent(e).slice(0,48),"...\n");return(0,eval)(o).apply(void 0,n(r.map(function(e){return t[e]})))}("undefined"==typeof window?e:window).insulate=a;var c={confine:a(i),harden:a(a)};exports.default=c;
},{}],"3KG6":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.default=exports.insulate=exports.setComputedIndex=exports.applyMethod=void 0;var e=r(require("./insulate.mjs")),t=r(require("./sesshim.mjs"));function r(e){return e&&e.__esModule?e:{default:e}}function n(){if("undefined"==typeof Reflect||!Reflect.construct)return!1;if(Reflect.construct.sham)return!1;if("function"==typeof Proxy)return!0;try{return Date.prototype.toString.call(Reflect.construct(Date,[],function(){})),!0}catch(e){return!1}}function u(e,t,r){return(u=n()?Reflect.construct:function(e,t,r){var n=[null];n.push.apply(n,t);var u=new(Function.bind.apply(e,n));return r&&o(u,r.prototype),u}).apply(null,arguments)}function o(e,t){return(o=Object.setPrototypeOf||function(e,t){return e.__proto__=t,e})(e,t)}function a(){var e=c(["Cannot set "," object member"]);return a=function(){return e},e}function c(e,t){return t||(t=e.slice(0)),Object.freeze(Object.defineProperties(e,{raw:{value:Object.freeze(t)}}))}var f=t.default.confine,i=t.default.harden,p={},l=i(function(e,t,r){return t.apply(e,r)});exports.applyMethod=l;var s=i(function(e,t,r){return"__proto__"===t&&slog.error(a(),{index:t}),e[t]=r});exports.setComputedIndex=s,p.makeMap=i(function(){for(var e=arguments.length,t=new Array(e),r=0;r<e;r++)t[r]=arguments[r];return u(Map,t)}),p.makeSet=i(function(){for(var e=arguments.length,t=new Array(e),r=0;r<e;r++)t[r]=arguments[r];return u(Set,t)}),p.makePromise=i(function(e){return new Promise(e)}),p.makeWeakMap=i(function(){for(var e=arguments.length,t=new Array(e),r=0;r<e;r++)t[r]=arguments[r];return u(WeakMap,t)}),p.makeWeakSet=i(function(){for(var e=arguments.length,t=new Array(e),r=0;r<e;r++)t[r]=arguments[r];return u(WeakSet,t)});var d=new WeakSet(Object.values(p));d.add(s);var y=(0,e.default)(d);exports.insulate=y,p.confine=i(f),p.insulate=function(e){return e};var v=p;exports.default=v;
},{"./insulate.mjs":"kax4","./sesshim.mjs":"eb5I"}],"sRTJ":[function(require,module,exports) {
"use strict";function r(r){return n(r)||t(r)||e()}function e(){throw new TypeError("Invalid attempt to spread non-iterable instance")}function t(r){if(Symbol.iterator in Object(r)||"[object Arguments]"===Object.prototype.toString.call(r))return Array.from(r)}function n(r){if(Array.isArray(r)){for(var e=0,t=new Array(r.length);e<r.length;e++)t[e]=r[e];return t}}function o(){var r=i(["Context value "," mismatch: "," vs. ",""]);return o=function(){return r},r}function i(r,e){return e||(e=r.slice(0)),Object.freeze(Object.defineProperties(r,{raw:{value:Object.freeze(e)}}))}function a(r){return(a="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(r){return typeof r}:function(r){return r&&"function"==typeof Symbol&&r.constructor===Symbol&&r!==Symbol.prototype?"symbol":typeof r})(r)}Object.defineProperty(exports,"__esModule",{value:!0}),exports.default=exports.contextArg=void 0;var u=insulate(function(r,e){if("object"!==a(e)||null===e)return""+e;if(void 0!==e.length)return e;for(var t,n,i=Object.keys(e),u=0;u<i.length;u++){var f=i[u];if("format"===f);else{if(void 0!==t||"function"==typeof e[f])return e;t=f,n=JSON.stringify(e[f],void 0,2)}}if(void 0===t)return e;if("_"===t[0]);else if(r.has(t)){var c=r.get(t);n!==c&&slog.error(o(),{valname:t},{val:n},{oval:c})}else r.set(t,n);return n});exports.contextArg=u;var f=insulate(function(e){var t=makeMap(),n=[],o=function(o,i){return o>=0&&(n[o]=i,t.set(i,o)),function(i){var a;if(!i.raw)return a=makeMap(r(Object.entries(i))),function(r){for(var i=arguments.length,u=new Array(i>1?i-1:0),f=1;f<i;f++)u[f-1]=arguments[f];return e(o,n,t,a,r,u)};a=makeMap();for(var u=i,f=arguments.length,c=new Array(f>1?f-1:0),l=1;l<f;l++)c[l-1]=arguments[l];return e(o,n,t,a,u,c)}},i=0,a=o(-1,"stringify");return a.panic=o(i++,"panic"),a.alert=o(i++,"alert"),a.crit=o(i++,"crit"),a.error=o(i++,"error"),a.reject=o(i++,"reject"),a.warn=o(i++,"warn"),a.notice=o(i++,"notice"),a.info=o(i++,"info"),a.debug=o(i++,"debug"),a.trace=o(i++,"trace"),a}),c=insulate(f);exports.default=c;
},{}],"g5I+":[function(require,module,exports) {

var t,e,n=module.exports={};function r(){throw new Error("setTimeout has not been defined")}function o(){throw new Error("clearTimeout has not been defined")}function i(e){if(t===setTimeout)return setTimeout(e,0);if((t===r||!t)&&setTimeout)return t=setTimeout,setTimeout(e,0);try{return t(e,0)}catch(n){try{return t.call(null,e,0)}catch(n){return t.call(this,e,0)}}}function u(t){if(e===clearTimeout)return clearTimeout(t);if((e===o||!e)&&clearTimeout)return e=clearTimeout,clearTimeout(t);try{return e(t)}catch(n){try{return e.call(null,t)}catch(n){return e.call(this,t)}}}!function(){try{t="function"==typeof setTimeout?setTimeout:r}catch(n){t=r}try{e="function"==typeof clearTimeout?clearTimeout:o}catch(n){e=o}}();var c,s=[],l=!1,a=-1;function f(){l&&c&&(l=!1,c.length?s=c.concat(s):a=-1,s.length&&h())}function h(){if(!l){var t=i(f);l=!0;for(var e=s.length;e;){for(c=s,s=[];++a<e;)c&&c[a].run();a=-1,e=s.length}c=null,l=!1,u(t)}}function m(t,e){this.fun=t,this.array=e}function p(){}n.nextTick=function(t){var e=new Array(arguments.length-1);if(arguments.length>1)for(var n=1;n<arguments.length;n++)e[n-1]=arguments[n];s.push(new m(t,e)),1!==s.length||l||i(h)},m.prototype.run=function(){this.fun.apply(null,this.array)},n.title="browser",n.env={},n.argv=[],n.version="",n.versions={},n.on=p,n.addListener=p,n.once=p,n.off=p,n.removeListener=p,n.removeAllListeners=p,n.emit=p,n.prependListener=p,n.prependOnceListener=p,n.listeners=function(t){return[]},n.binding=function(t){throw new Error("process.binding is not supported")},n.cwd=function(){return"/"},n.chdir=function(t){throw new Error("process.chdir is not supported")},n.umask=function(){return 0};
},{}],"fc7A":[function(require,module,exports) {
var global = arguments[3];
var process = require("process");
var e=arguments[3],r=require("process");Object.defineProperty(exports,"__esModule",{value:!0});var t={};exports.default=void 0;var n=i(require("./jessieDefaults.mjs"));Object.keys(n).forEach(function(e){"default"!==e&&"__esModule"!==e&&(Object.prototype.hasOwnProperty.call(t,e)||Object.defineProperty(exports,e,{enumerable:!0,get:function(){return n[e]}}))});var o=i(require("../../lib/slog.mjs"));function i(e){return e&&e.__esModule?e:{default:e}}function c(e){return a(e)||f(e)||u()}function u(){throw new TypeError("Invalid attempt to spread non-iterable instance")}function f(e){if(Symbol.iterator in Object(e)||"[object Arguments]"===Object.prototype.toString.call(e))return Array.from(e)}function a(e){if(Array.isArray(e)){for(var r=0,t=new Array(e.length);r<e.length;r++)t[r]=e[r];return t}}function l(e){return(l="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&"function"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e})(e)}var s=Object.assign({},n.default);Object.keys(s).forEach(function(r){e[r]=s[r]});var y=(0,o.default)(function(t,n,i,u,f,a){var s,y=a.reduce(function(e,r,t){s=(0,o.contextArg)(u,r);var n=e[e.length-1];return"object"===l(s)&&void 0!==s?(e[e.length-1]=n.trimRight(),e.push(s,f[t+1].trimLeft())):e[e.length-1]=n+String(s)+f[t+1],e},[n[t]+": "+f[0]]);if(t===i.get("stringify"))return y.join(" ");if(t>=i.get("warn")){var p;(p=console).error.apply(p,c(y))}else{var b,d=(new Error).stack,g=d.slice(d.indexOf("\n")+1),j=g.slice(g.indexOf("\n")+1),m=j.slice(j.indexOf("\n"));(b=console).error.apply(b,c(y).concat([m]))}if("reject"===n[t])return Promise.reject(y.join(" "));if(void 0!==e&&t<=i.get("panic"))r.exitCode=99;else if(t<=i.get("error"))throw y.join(" ");return y.join(" ")});s.slog=y,Object.keys(s).forEach(function(r){e[r]=s[r]});var p=s;exports.default=p;
},{"./jessieDefaults.mjs":"3KG6","../../lib/slog.mjs":"sRTJ","process":"g5I+"}],"cE9W":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.default=void 0;var t=insulate(function(t){for(var e=[],r="\n",n=arguments.length,s=new Array(n>1?n-1:0),a=1;a<n;a++)s[a-1]=arguments[a];for(var u=0,i=s.length;u<i;u++){var l=t[u];0===u&&l[0].startsWith("\n")&&(l=l.slice(1));var o=l.lastIndexOf("\n");if(o>=0){r="\n";for(var f=l.length-o;f>0;f--)r+=" "}e.push(l),String(s[u]).split("\n").forEach(function(t,n){0!==n&&e.push(r),e.push(t)})}return e.push(t[s.length]),e.join("")}),e=insulate(t);exports.default=e;
},{}],"QgFk":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.default=void 0;var n=r(require("./indent.mjs"));function r(n){return n&&n.__esModule?n:{default:n}}function t(){var n=q(["reparsedPegAst does not match src/boot-pegast.mjs.ts"]);return t=function(){return n},n}function e(){var n=q(["// boot-pegast.mjs.ts - AUTOMATICALLY GENERATED by boot-peg.mjs.ts\nexport default ",";"],["// boot-pegast.mjs.ts - AUTOMATICALLY GENERATED by boot-peg.mjs.ts\\nexport default ",";"]);return e=function(){return n},n}function u(){var n=q(["Cannot curry baseParserCreator"]);return u=function(){return n},n}function o(n){return(o="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(n){return typeof n}:function(n){return n&&"function"==typeof Symbol&&n.constructor===Symbol&&n!==Symbol.prototype?"symbol":typeof n})(n)}function a(){var n=q(["",": ",""]);return a=function(){return n},n}function i(){var n=q(["Unrecognized tag flag ",""]);return i=function(){return n},n}function f(n){return l(n)||s(n)||c()}function c(){throw new TypeError("Invalid attempt to spread non-iterable instance")}function s(n){if(Symbol.iterator in Object(n)||"[object Arguments]"===Object.prototype.toString.call(n))return Array.from(n)}function l(n){if(Array.isArray(n)){for(var r=0,t=new Array(n.length);r<n.length;r++)t[r]=n[r];return t}}function v(){var n=q(["Cannot find "," in vtable"]);return v=function(){return n},n}function p(){var n=q(["\n    "," = pos;\n    ","\n    value = (value === FAIL) ? SKIP : FAIL;\n    pos = ",";"]);return p=function(){return n},n}function y(){var n=q(["\n    "," = pos;\n    ","\n    if (value !== FAIL) {\n        value = SKIP;\n    }\n    pos = ",";"]);return y=function(){return n},n}function g(){var n=q(["\n    [pos, value] = EAT(self, pos, ",");\n    "]);return g=function(){return n},n}function d(){var n=q(["\n    [pos, value] = EAT(self, pos);\n                "]);return d=function(){return n},n}function m(){var n=q(["\n    [pos, value] = EAT(self, pos);\n    if (value !== FAIL) {\n        value = ",".indexOf(value) "," 0 ? FAIL : value;\n    }\n                "]);return m=function(){return n},n}function A(){var n=q(["\n    if (beginPos !== undefined) {\n        yytext = '';\n        while (beginPos < pos) {\n            [beginPos, value] = EAT(self, beginPos);\n            if (value === FAIL) {\n                break;\n            }\n            yytext += value;\n        }\n        beginPos = undefined;\n        value = [];\n    }"]);return A=function(){return n},n}function b(){var n=q(["\n    ","\n    if (value.length === 0) value = FAIL;"]);return b=function(){return n},n}function h(){var n=q(["\n    "," = [];\n    "," = pos;\n    "," = SKIP;\n    while (true) {\n      "," = pos;\n      ","\n      if (value === FAIL) {\n        pos = ",";\n        break;\n      }\n      if ("," !== SKIP) ",".push(",");\n      if (value !== SKIP) ",".push(value);\n      "," = pos;\n      ","\n      if (value === FAIL) break;\n      "," = value;\n      if (pos === ",") break;\n    }\n    value = ",";"]);return h=function(){return n},n}function I(){var n=q(["\n    "," = pos;\n    ","\n    if (value !== FAIL) {\n        value = act_","(...value);\n        if (Array.isArray(value)) {\n            value = [...value];\n            value._pegPosition = makeTokStr(self, FIND(self.template, ","));\n        }\n    }"]);return I=function(){return n},n}function S(){var n=q(["\n    ","\n    if (value !== FAIL && value.length === 1) value = value[0];"]);return S=function(){return n},n}function E(){var n=q(["\n    "," = [];\n    "," = FAIL;\n    "," = pos;\n    ",": {\n      let beginPos, yytext;\n      ","\n      if (yytext !== undefined) {\n          "," = [yytext];\n      }\n      else {\n        "," = ",";\n      }\n    }\n    if ((value = ",") === FAIL) pos = ",";"]);return E=function(){return n},n}function _(){var n=q(["\n    ","\n    if (value === FAIL) break ",";\n    if (value !== SKIP) ",".push(value);"]);return _=function(){return n},n}function x(){var n=q(["\n    ",": {\n      ","\n    }"]);return x=function(){return n},n}function L(){var n=q(["\n    ","\n    if (value !== FAIL) break ",";"]);return L=function(){return n},n}function O(){var n=q(["\n    rule_",": (self, pos) => {\n      ","\n      ","\n      return [pos, value];\n    },"]);return O=function(){return n},n}function P(){var n=q(["\n    (function(",") {\n      let myHits = 0, myMisses = 0;\n      return baseMemo => (template, debug) => {\n          const BaseParser = baseMemo({});\n          return {...BaseParser,\n        template,\n        _memo: makeMap(),\n        _hits: (i) => myHits += i,\n        _misses: (i) => myMisses += i,\n        _debug: debug,\n        start: (self) => {\n          const pair = RUN(self, self.rule_",", 0, ",");\n          if (pair[1] === FAIL) {\n            ERROR(self, pair[0]);\n          }\n          return pair[1];\n        },\n        done: DONE,\n        ","\n    }};\n    })\n    "]);return P=function(){return n},n}function F(){var n=q(["Invalid hexadecimal number ",""]);return F=function(){return n},n}function w(){var n=q(["","(",") => [",", ","]"]);return w=function(){return n},n}function C(){var n=q(["","(",") => left recursion detector"]);return C=function(){return n},n}function k(){var n=q(["@"," => FAIL [","]"]);return k=function(){return n},n}function T(){var n=q(["hits: ",", misses: ",""]);return T=function(){return n},n}function N(){var n=q(["Syntax error ",""]);return N=function(){return n},n}function j(){var n=q(["-------template--------\n    ","\n    -------\n    ",""]);return j=function(){return n},n}function R(n,r){return J(n)||M(n,r)||K()}function K(){throw new TypeError("Invalid attempt to destructure non-iterable instance")}function M(n,r){var t=[],e=!0,u=!1,o=void 0;try{for(var a,i=n[Symbol.iterator]();!(e=(a=i.next()).done)&&(t.push(a.value),!r||t.length!==r);e=!0);}catch(f){u=!0,o=f}finally{try{e||null==i.return||i.return()}finally{if(u)throw o}}return t}function J(n){if(Array.isArray(n))return n}function U(){var n=q(["Rule missing: ",""]);return U=function(){return n},n}function D(){var n=q(["Left recursion on rule: ",""]);return D=function(){return n},n}function H(){var n=q(["run(f, ",", ",")"]);return H=function(){return n},n}function q(n,r){return r||(r=n.slice(0)),Object.freeze(Object.defineProperties(n,{raw:{value:Object.freeze(r)}}))}var B=insulate(n.default),z=insulate({toString:function(){return"LEFT_RECUR"}}),G=insulate(function(n,r,t,e){n._debug&&slog.info(H(),t,e);var u=n._memo.get(t);u||(u=makeMap(),n._memo.set(t,u));var o=u.get(r);return o?(o===z&&slog.error(D(),{name:e}),n._hits(1)):(u.set(r,z),n._misses(1),"function"==typeof r?o=r(n,t):void 0===r?slog.error(U(),e):o=$(n,t,r),u.set(r,o)),o}),W=insulate(function(n){var r=0,t=[],e=!0,u=!1,o=void 0;try{for(var a,i=n._memo[Symbol.iterator]();!(e=(a=i.next()).done);e=!0){var f=a.value[1],c=!0,s=!1,l=void 0;try{for(var v,p=f[Symbol.iterator]();!(c=(v=p.next()).done);c=!0){var y=R(v.value,2),g=y[0],d=y[1];if(d!==z){var m="function"==typeof g?g.name.slice(5):JSON.stringify(""+g),A=R(d,2),b=A[0];A[1]===rn&&(b>r?(r=b,t=[m]):b===r&&t.indexOf(m)<0&&t.push(m))}}}catch(h){s=!0,l=h}finally{try{c||null==p.return||p.return()}finally{if(s)throw l}}}}catch(h){u=!0,o=h}finally{try{e||null==i.return||i.return()}finally{if(u)throw o}}return[r,t]}),Y=insulate(function(n,r){var t=R(W(n),2),e=t[0],u=t[1],o=X(n.template,e),a=Array.isArray(o)?"at ".concat(e," ").concat(V(n,o)):"unexpected EOF after ".concat(V(n,X(n.template,e-1))),i=0===u.length?"stuck":"looking for ".concat(u.join(", ")),f=n.template.sources;slog.info(j(),n.template.raw.reduce(function(n,r,t){if(f){var e=f[t];n+="    ".concat(e.uri,":").concat(e.line,": ")}return n+=JSON.stringify(r).slice(0,50)+"\n"},""),i),slog.error(N(),a)}),V=insulate(function(n,r){if(Array.isArray(r)){var t=n.template[r[0]];return"".concat(JSON.stringify(t[r[1]])," #").concat(r[0],":").concat(r[1])}if("number"==typeof r)return"hole #".concat(r)}),Q=insulate(function(n){if(n._debug){var r=!0,t=!1,e=void 0;try{for(var u,o=n._memo[Symbol.iterator]();!(r=(u=o.next()).done);r=!0){var a=R(u.value,2),i=a[0],f=a[1],c=[],s=!0,l=!1,v=void 0;try{for(var p,y=f[Symbol.iterator]();!(s=(p=y.next()).done);s=!0){var g=R(p.value,2),d=g[0],m=g[1],A="function"==typeof d?d.name:JSON.stringify(d);if(m===z)slog.notice(C(),A,i);else{var b=R(m,2),h=b[0],I=b[1];I===rn?c.push(A):slog.debug(w(),A,i,h,I)}}}catch(S){l=!0,v=S}finally{try{s||null==y.return||y.return()}finally{if(l)throw v}}c.length>=1&&slog.debug(k(),i,c)}}catch(S){t=!0,e=S}finally{try{r||null==o.return||o.return()}finally{if(t)throw e}}slog.info(T(),n._hits(0),n._misses(0))}}),X=insulate(function(n,r){for(var t=n.raw,e=t.length-1,u=r,o=0;o<=e;o++){var a=t[o].length;if(u<a)return[o,u];if(u===a&&o<e)return o;u-=a+1}}),Z=insulate(function(n,r){return[r,[]]}),$=insulate(function(n,r,t){var e=X(n.template,r);if(Array.isArray(e)){var u=n.template.raw[e[0]];if("string"!=typeof t)return[r+1,u[e[1]]];if(u.startsWith(t,e[1]))return[r+t.length,t]}return[r,rn]}),nn=insulate(function(n,r){var t=X(n.template,r);return"number"==typeof t?[r+1,t]:[r,rn]}),rn=insulate({toString:function(){return"FAIL"}}),tn=insulate({toString:function(){return"SKIP"}}),en="0123456789abcdef",un="ABCDEF",on=insulate(function(n){var r=en.indexOf(n);return r<0&&(r=un.indexOf(n)+10),r<0&&slog.error(F(),{c:n}),r}),an=insulate(function(n){if("\\"!==n[0])return[n[0],1];var r=n[1];switch(r){case"b":r="\b";break;case"f":r="\f";break;case"n":r="\n";break;case"r":r="\r";break;case"t":r="\t";break;case"x":var t=16*on(n[2])+on(n[3]);return[r=String.fromCharCode(t),4]}return[r,2]}),fn=insulate(function(n,r){function c(n){var r=0,t=0,e=["let value = FAIL"];function u(n){var r="".concat(n,"_").concat(t++);return e.push(r),r}function o(n){return"".concat(n,"_").concat(t++)}var a={peg:function(){for(var n=arguments.length,t=new Array(n),e=0;e<n;e++)t[e]=arguments[e];for(var u=t.map(i).join("\n"),o=[],a=0;a<r;a++)o.push("act_".concat(a));var f=t[0][1];return B(P(),o.join(", "),f,JSON.stringify(f),u)},def:function(n,r){var t,u=i(r);return B(O(),n,(t="".concat(e.join(", "),";"),e.length=1,t),u)},empty:function(){return"value = SKIP;"},fail:function(){return"value = FAIL;"},or:function(){for(var n=o("or"),r=arguments.length,t=new Array(r),e=0;e<r;e++)t[e]=arguments[e];var u=t.map(i).map(function(r){return B(L(),r,n)}).join("\n");return B(x(),n,u)},seq:function(){for(var n=u("pos"),r=o("seq"),t=u("s"),e=u("v"),a=arguments.length,f=new Array(a),c=0;c<a;c++)f[c]=arguments[c];var s=f.map(i).map(function(n){return B(_(),n,r,t)}).join("\n");return B(E(),t,e,n,r,s,e,e,t,e,n)},pred:function(n){return r=Math.max(r,n+1),"[pos, value] = act_".concat(n,"(self, pos);")},val0:function(){var n=a.seq.apply(a,arguments);return B(S(),n)},act:function(n){var t=u("pos");r=Math.max(r,n+1);for(var e=arguments.length,o=new Array(e>1?e-1:0),i=1;i<e;i++)o[i-1]=arguments[i];var f=a.seq.apply(a,o);return B(I(),t,f,n,t)},"**":function(n,r){var t=u("pos"),e=u("pos"),o=u("s"),a=i(n),f=i(r),c=u("sepVal");return B(h(),o,t,c,e,a,t,c,o,c,o,t,f,c,e,o)},"++":function(n,r){var t=a["**"](n,r);return B(b(),t)},"?":function(n){return a["**"](n,["fail"])},"*":function(n){return a["**"](n,["empty"])},"+":function(n){return a["++"](n,["empty"])},super:function(n){return"[pos, value] = RUN(self, BaseParser.rule_".concat(n,", pos, ").concat(JSON.stringify("super.".concat(n)),");")},begin:function(){return"beginPos = pos; value = [];"},end:function(){return B(A())},cls:function(n){var r="",t=0,e="^"===n[t];for(e&&++t;t<n.length;){var u=R(an(n.slice(t)),2),o=u[0];if("-"===n[t+=u[1]]){++t;var a=R(an(n.slice(t)),2),i=a[0];t+=a[1];for(var f=o.charCodeAt(0),c=i.charCodeAt(0),s=f;s<=c;s++)r+=String.fromCharCode(s)}else r+=o}var l=e?">=":"<",v=JSON.stringify(r);return B(m(),v,l)},dot:function(){return B(d())},lit:function(n){for(var r="",t=0;t<n.length;){var e=R(an(n.slice(t)),2),u=e[0];t+=e[1],r+=u}return B(g(),JSON.stringify(r))},peek:function(n){var r=u("pos"),t=i(n);return B(y(),r,t,r)},peekNot:function(n){var r=u("pos"),t=i(n);return B(p(),r,t,r)}};function i(n){if("string"==typeof n){var r=JSON.stringify(n);return"[pos, value] = RUN(self, self.rule_".concat(n,", pos, ").concat(r,");")}var t=a[n[0]];return t||slog.error(v(),n[0]),t.apply(void 0,f(n.slice(1)))}return i(n)}function s(n){return function(n,r){var t=makeWeakMap(),e=!1,u=function r(u){if("string"==typeof u){switch(u){case"DEBUG":e=!0;break;default:throw slog.error(i(),{templateOrFlag:u})}return r}var f=u,c=t.get(f);c||(c=n(f,e),t.set(f,c)),"function"!=typeof c&&slog.error(a(),o(c),c);for(var s=arguments.length,l=new Array(s>1?s-1:0),v=1;v<s;v++)l[v-1]=arguments[v];return c.apply(void 0,l)};return u.parserCreator=r,u}(function(r,t){var e=n(r,t);void 0===e&&slog.error(u());var o=null;try{o=e.start(e)}finally{e.done(e)}return o},n)}var l=s(function(n){});function F(n){var r=c(["peg"].concat(f(n))),t=confine(r,{DONE:Q,EAT:$,ERROR:Y,FAIL:rn,FIND:X,RUN:G,SKIP:tn,makeTokStr:V});return function(){var n,r,e=t.apply(void 0,arguments),u=function t(e){function u(u){var o=[];function a(n){if("string"==typeof n)return o.push(n),a;for(var t=arguments.length,u=new Array(t>1?t-1:0),i=1;i<t;i++)u[i-1]=arguments[i];var f=r.apply(void 0,[n].concat(u))._asExtending(e);return o.reduce(function(n,r){return n(r)},f)}if(a.ACCEPT=Z,a.EAT=$,a.FAIL=rn,a.HOLE=nn,a.SKIP=tn,a._asExtending=n,a.extends=t,a.parserCreator=r.parserCreator,"string"==typeof u)return a(u);for(var i=arguments.length,f=new Array(i>1?i-1:0),c=1;c<i;c++)f[c-1]=arguments[c];return a.apply(void 0,[u].concat(f))}return u.ACCEPT=Z,u.EAT=$,u.FAIL=rn,u.HOLE=nn,u.SKIP=tn,u._asExtending=n,u.extends=t,u.parserCreator=r.parserCreator,u};n=function(r){var t=s(e(r.parserCreator));return t.ACCEPT=Z,t.EAT=$,t.FAIL=rn,t.HOLE=nn,t.SKIP=tn,t._asExtending=n,t.extends=u,t},l._asExtending=n;var o=l;return o._asExtending=n,r=n(o)}}var w=function(n){for(var r=arguments.length,t=new Array(r>1?r-1:0),e=1;e<r;e++)t[e-1]=arguments[e];return t};w.ACCEPT=Z,w.HOLE=nn,w.SKIP=tn;var C=n(w,F),k=F(r).apply(void 0,f(C)),T=n(k,function(n){return function(){return n}}),N=n(T,void 0),j=JSON.stringify(r,void 0,"  "),K=JSON.stringify(N,void 0,"  ");return j!==K&&(slog.info(e(),{b:K}),slog.panic(t())),n(k,F)}),cn=insulate(fn);exports.default=cn;
},{"./indent.mjs":"cE9W"}],"joiS":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.default=void 0;var a=insulate([["def","Grammar",["act",0,"_Spacing",["+","Definition"],"_EndOfFile"]],["def","Definition",["act",2,"Identifier","LEFTARROW","Expression","SEMI",["pred",1]]],["def","Expression",["act",3,["**","Sequence","_SLASH"]]],["def","Sequence",["act",5,["act",4,["*","Prefix"]],["?","HOLE"]]],["def","Prefix",["or",["act",6,"AND","HOLE"],["act",7,"AND","Suffix"],["act",8,"NOT","Suffix"],["val0","Suffix"]]],["def","Suffix",["or",["act",9,"Primary",["or",["val0","STARSTAR"],["val0","PLUSPLUS"]],"Primary"],["act",10,"Primary",["or",["val0","QUESTION"],["val0","STAR"],["val0","PLUS"]]],["val0","Primary"]]],["def","Primary",["or",["val0","Super"],["val0","Identifier",["peekNot","LEFTARROW"]],["act",11,"OPEN","Expression","CLOSE"],["act",12,"Literal"],["act",13,"Class"],["act",14,"DOT"],["act",15,"BEGIN"],["act",16,"END"]]],["def","Super",["act",17,["lit","super."],"Identifier"]],["def","Identifier",["val0",["begin"],"IdentStart",["*","IdentCont"],["end"],"_Spacing"]],["def","IdentStart",["val0",["cls","a-zA-Z_"]]],["def","IdentCont",["or",["val0","IdentStart"],["val0",["cls","0-9"]]]],["def","Literal",["or",["val0",["cls","'"],["begin"],["*",["val0",["peekNot",["cls","'"]],"Char"]],["end"],["cls","'"],"_Spacing"],["val0",["cls",'"'],["begin"],["*",["val0",["peekNot",["cls",'"']],"Char"]],["end"],["cls",'"'],"_Spacing"]]],["def","Class",["val0",["lit","["],["begin"],["*",["val0",["peekNot",["lit","]"]],"Range"]],["end"],["lit","]"],"_Spacing"]],["def","Range",["or",["val0","Char",["lit","-"],"Char"],["val0","Char"]]],["def","Char",["or",["val0",["lit","\\\\"],["cls","abefnrtv'\"\\[\\]\\\\\\`\\$"]],["val0",["lit","\\\\x"],["cls","0-9a-fA-F"],["cls","0-9a-fA-F"]],["val0",["lit","\\\\"],["lit","-"]],["val0",["peekNot",["lit","\\\\"]],["dot"]]]],["def","LEFTARROW",["val0",["lit","<-"],"_Spacing"]],["def","_SLASH",["act",18,["lit","/"],"_Spacing"]],["def","SEMI",["val0",["lit",";"],"_Spacing"]],["def","AND",["val0",["lit","&"],"_Spacing"]],["def","NOT",["val0",["lit","~"],"_Spacing"]],["def","QUESTION",["val0",["lit","?"],"_Spacing"]],["def","STAR",["val0",["lit","*"],"_Spacing"]],["def","PLUS",["val0",["lit","+"],"_Spacing"]],["def","OPEN",["val0",["lit","("],"_Spacing"]],["def","CLOSE",["val0",["lit",")"],"_Spacing"]],["def","DOT",["val0",["lit","."],"_Spacing"]],["def","_Spacing",["act",19,["*",["or",["val0","Space"],["val0","Comment"]]]]],["def","Comment",["val0",["lit","#"],["*",["val0",["peekNot","EndOfLine"],["dot"]]],"EndOfLine"]],["def","Space",["or",["val0",["lit"," "]],["val0",["lit","\\t"]],["val0","EndOfLine"]]],["def","EndOfLine",["or",["val0",["lit","\\r\\n"]],["val0",["lit","\\n"]],["val0",["lit","\\r"]]]],["def","_EndOfFile",["val0",["peekNot",["dot"]]]],["def","HOLE",["val0",["pred",20],"_Spacing"]],["def","BEGIN",["val0",["lit","<"],"_Spacing"]],["def","END",["val0",["lit",">"],"_Spacing"]],["def","PLUSPLUS",["val0",["lit","++"],"_Spacing"]],["def","STARSTAR",["val0",["lit","**"],"_Spacing"]]]);exports.default=a;
},{}],"3zTw":[function(require,module,exports) {
"use strict";function n(){var e=r(["\n# Hierarchical syntax\n\nGrammar      <- _Spacing Definition+ _EndOfFile\n                    ",";\n\nDefinition   <- Identifier LEFTARROW Expression SEMI &","\n                    ",";\nExpression   <- Sequence ** _SLASH\n                    ",";\nSequence     <- (Prefix*\n                    ",")\n                 HOLE?\n                    ",";\nPrefix       <- AND HOLE\n                    ","\n              / AND Suffix\n                    ","\n              / NOT Suffix\n                    ","\n              /     Suffix;\nSuffix       <- Primary (STARSTAR\n                        / PLUSPLUS) Primary\n                    ","\n              / Primary (QUESTION\n                        / STAR\n                        / PLUS)\n                    ","\n              / Primary;\nPrimary      <- Super\n              / Identifier ~LEFTARROW\n              / OPEN Expression CLOSE\n                    ","\n              / Literal\n                    ","\n              / Class\n                    ","\n              / DOT\n                    ","\n              / BEGIN\n                    ","\n              / END\n                    ","\n              ;\n\nSuper        <- 'super.' Identifier\n                    ",";\n\n# Lexical syntax\n\nIdentifier   <- < IdentStart IdentCont* > _Spacing;\nIdentStart   <- [a-zA-Z_];\nIdentCont    <- IdentStart / [0-9];\nLiteral      <- ['] < (~['] Char )* > ['] _Spacing\n              / [\"] < (~[\"] Char )* > [\"] _Spacing;\nClass        <- '[' < (~']' Range)* > ']' _Spacing;\nRange        <- Char '-' Char / Char;\nChar         <- '\\' [abefnrtv'\"[]\\`$]\n              / '\\x' [0-9a-fA-F][0-9a-fA-F]\n              / '\\' '-'\n              / ~'\\' .;\nLEFTARROW    <- '<-' _Spacing;\n_SLASH        <- '/' _Spacing              ",";\nSEMI         <- ';' _Spacing;\nAND          <- '&' _Spacing;\nNOT          <- '~' _Spacing;\nQUESTION     <- '?' _Spacing;\nSTAR         <- '*' _Spacing;\nPLUS         <- '+' _Spacing;\nOPEN         <- '(' _Spacing;\nCLOSE        <- ')' _Spacing;\nDOT          <- '.' _Spacing;\n_Spacing      <- (Space / Comment)*        ",";\nComment      <- '#' (~EndOfLine .)* EndOfLine;\nSpace        <- ' ' / '\t' / EndOfLine;\nEndOfLine    <- '\r\n' / '\n' / '\r';\n_EndOfFile    <- ~.;\n\nHOLE         <- &"," _Spacing;\nBEGIN        <- '<' _Spacing;\nEND          <- '>' _Spacing;\nPLUSPLUS     <- '++' _Spacing;\nSTARSTAR     <- '**' _Spacing;\n"],["\n# Hierarchical syntax\n\nGrammar      <- _Spacing Definition+ _EndOfFile\n                    ",";\n\nDefinition   <- Identifier LEFTARROW Expression SEMI &","\n                    ",";\nExpression   <- Sequence ** _SLASH\n                    ",";\nSequence     <- (Prefix*\n                    ",")\n                 HOLE?\n                    ",";\nPrefix       <- AND HOLE\n                    ","\n              / AND Suffix\n                    ","\n              / NOT Suffix\n                    ","\n              /     Suffix;\nSuffix       <- Primary (STARSTAR\n                        / PLUSPLUS) Primary\n                    ","\n              / Primary (QUESTION\n                        / STAR\n                        / PLUS)\n                    ","\n              / Primary;\nPrimary      <- Super\n              / Identifier ~LEFTARROW\n              / OPEN Expression CLOSE\n                    ","\n              / Literal\n                    ","\n              / Class\n                    ","\n              / DOT\n                    ","\n              / BEGIN\n                    ","\n              / END\n                    ","\n              ;\n\nSuper        <- 'super.' Identifier\n                    ",";\n\n# Lexical syntax\n\nIdentifier   <- < IdentStart IdentCont* > _Spacing;\nIdentStart   <- [a-zA-Z_];\nIdentCont    <- IdentStart / [0-9];\nLiteral      <- ['] < (~['] Char )* > ['] _Spacing\n              / [\"] < (~[\"] Char )* > [\"] _Spacing;\nClass        <- '[' < (~']' Range)* > ']' _Spacing;\nRange        <- Char '-' Char / Char;\nChar         <- '\\\\' [abefnrtv'\"\\[\\]\\\\\\`\\$]\n              / '\\\\x' [0-9a-fA-F][0-9a-fA-F]\n              / '\\\\' '-'\n              / ~'\\\\' .;\nLEFTARROW    <- '<-' _Spacing;\n_SLASH        <- '/' _Spacing              ",";\nSEMI         <- ';' _Spacing;\nAND          <- '&' _Spacing;\nNOT          <- '~' _Spacing;\nQUESTION     <- '?' _Spacing;\nSTAR         <- '*' _Spacing;\nPLUS         <- '+' _Spacing;\nOPEN         <- '(' _Spacing;\nCLOSE        <- ')' _Spacing;\nDOT          <- '.' _Spacing;\n_Spacing      <- (Space / Comment)*        ",";\nComment      <- '#' (~EndOfLine .)* EndOfLine;\nSpace        <- ' ' / '\\t' / EndOfLine;\nEndOfLine    <- '\\r\\n' / '\\n' / '\\r';\n_EndOfFile    <- ~.;\n\nHOLE         <- &"," _Spacing;\nBEGIN        <- '<' _Spacing;\nEND          <- '>' _Spacing;\nPLUSPLUS     <- '++' _Spacing;\nSTARSTAR     <- '**' _Spacing;\n"]);return n=function(){return e},e}function r(n,r){return r||(r=n.slice(0)),Object.freeze(Object.defineProperties(n,{raw:{value:Object.freeze(r)}}))}function e(n){return t(n)||c(n)||i()}function i(){throw new TypeError("Invalid attempt to destructure non-iterable instance")}function t(n){if(Array.isArray(n))return n}function a(n){return u(n)||c(n)||S()}function S(){throw new TypeError("Invalid attempt to spread non-iterable instance")}function c(n){if(Symbol.iterator in Object(n)||"[object Arguments]"===Object.prototype.toString.call(n))return Array.from(n)}function u(n){if(Array.isArray(n)){for(var r=0,e=new Array(n.length);r<n.length;r++)e[r]=n[r];return e}}Object.defineProperty(exports,"__esModule",{value:!0}),exports.default=void 0;var f=insulate(function(r,i){var t=r.ACCEPT,S=r.HOLE,c=r.SKIP;function u(n,r){return 0===r.length?["empty"]:1===r.length?r[0]:[n].concat(a(r))}function f(n){return n.reduce(function(n,r){return n.push.apply(n,a(o(r))),n},[])}function o(n){if(Array.isArray(n)){if(0===n.length)return[];var r=e(n),i=r[0],t=r.slice(1);return"seq"===i?f(t):0===t.length&&Array.isArray(i)?o(i):[[i].concat(a(f(t)))]}return[n]}return r(n(),i,t,function(n,r,e,i){return["def",n,e]},function(n){return u("or",n)},function(n){return u("seq",n)},function(n,r){return 0===r.length?["val0"].concat(a(o(n))):["act",r[0]].concat(a(o(n)))},function(n,r){return["pred",r]},function(n,r){return["peek",r]},function(n,r){return["peekNot",r]},function(n,r,e){return[r,n,e]},function(n,r){return[r[0],n]},function(n,r,e){return r},function(n){return["lit",n]},function(n){return["cls",n]},function(){return["dot"]},function(){return["begin"]},function(){return["end"]},function(n,r){return["super",r]},function(n){return c},function(n){return c},S)}),o=insulate(f);exports.default=o;
},{}],"xkRL":[function(require,module,exports) {
"use strict";function e(e){return r(e)||n(e)||t()}function t(){throw new TypeError("Invalid attempt to spread non-iterable instance")}function n(e){if(Symbol.iterator in Object(e)||"[object Arguments]"===Object.prototype.toString.call(e))return Array.from(e)}function r(e){if(Array.isArray(e)){for(var t=0,n=new Array(e.length);t<e.length;t++)n[t]=e[t];return n}}function o(){var e=u(["\n    # Override rather than inherit start production.\n    # Only module syntax is permitted.\n    start <- _WS moduleBody _EOF               ",";\n\n    # A.5 Scripts and Modules\n\n    insulatedExpr <- < super.insulatedExpr >;\n\n    moduleBody <- moduleItem*;\n    moduleItem <-\n      < SEMI >\n    / importDecl    # Same AST as in Jessie.\n    / exportDecl    # Similar AST, but insulatedExpr is source string.\n    / < moduleDeclaration >;  # Source string.\n\n    exportDecl <-\n      EXPORT DEFAULT < exportableExpr > SEMI    ","\n    / EXPORT moduleDeclaration                  ",";\n    "]);return o=function(){return e},e}function u(e,t){return t||(t=e.slice(0)),Object.freeze(Object.defineProperties(e,{raw:{value:Object.freeze(t)}}))}Object.defineProperty(exports,"__esModule",{value:!0}),exports.default=void 0;var i=insulate(function(t){return t(o(),function(e){return function(){return["moduleX",e]}},function(e){return["exportDefaultX",e]},function(t,n){return["exportX"].concat(e(n))})}),a=insulate(i);exports.default=a;
},{}],"NMVp":[function(require,module,exports) {
"use strict";function n(){var r=a(["\n    # Jump to the expr production.\n    start <- _WS expr _EOF              ",";\n    "]);return n=function(){return r},r}function r(n){return o(n)||t(n)||e()}function e(){throw new TypeError("Invalid attempt to spread non-iterable instance")}function t(n){if(Symbol.iterator in Object(n)||"[object Arguments]"===Object.prototype.toString.call(n))return Array.from(n)}function o(n){if(Array.isArray(n)){for(var r=0,e=new Array(n.length);r<n.length;r++)e[r]=n[r];return e}}function i(){var n=a(["\n    # Override rather than inherit start production.\n    # Only module syntax is permitted.\n    start <- _WS moduleBody _EOF               ",';\n\n    # A.1 Lexical Grammar\n\n    # For proposed eventual send expressions\n    LATER <- _NO_NEWLINE "!" _WS;\n\n    # A.2 Expressions\n\n    # Jessie primaryExpr does not include "this", ClassExpression,\n    # GeneratorExpression, AsyncFunctionExpression,\n    # AsyncGenerarorExpression, or RegularExpressionLiteral.\n    primaryExpr <-\n      super.primaryExpr\n    / functionExpr;\n\n    propDef <-\n      methodDef\n    / super.propDef;\n\n    purePropDef <-\n      methodDef\n    / super.purePropDef;\n\n    # Recognize pre-increment/decrement.\n    prePre <-\n      (PLUSPLUS / MINUSMINUS)                          ',"\n    / super.prePre;\n\n    # Extend to recognize proposed eventual get syntax,\n    # as well as computed indices and postfix increment/decrement.\n    memberPostOp <-\n      super.memberPostOp\n    / LEFT_BRACKET assignExpr RIGHT_BRACKET        ","\n    / LATER LEFT_BRACKET assignExpr RIGHT_BRACKET  ","\n    / LATER IDENT_NAME                             ",";\n\n    # Extend to recognize proposed eventual send syntax.\n    # We distinguish b!foo(x) from calling b!foo by a post-parsing pass\n    callPostOp <-\n      super.callPostOp\n    / LATER args                                           ",";\n\n    postOp <- (PLUSPLUS / MINUSMINUS) _WS;\n\n    # to be extended\n    assignExpr <-\n      arrowFunc\n    / functionExpr\n    / lValue postOp                                        ","\n    / lValue (EQUALS / assignOp) assignExpr                ","\n    / super.assignExpr\n    / primaryExpr;\n\n    # An expression without side-effects.\n    pureExpr <-\n      arrowFunc\n    / super.pureExpr;\n\n    # In Jessie, an lValue is only a variable, a computed index-named\n    # property (an array element), or a statically string-named\n    # property.\n    # We allow assignment to statically string-named fields, since it\n    # is useful during initialization and prevented thereafter by\n    # mandatory tamper-proofing.\n\n    # to be overridden or extended\n    lValue <-\n      primaryExpr LEFT_BRACKET indexExpr RIGHT_BRACKET     ","\n    / primaryExpr LATER LEFT_BRACKET indexExpr RIGHT_BRACKET ","\n    / primaryExpr DOT IDENT_NAME                           ","\n    / primaryExpr LATER IDENT_NAME                         ",'\n    / useVar;\n\n    assignOp <-\n      ("*=" / "/=" / "%=" / "+=" / "-="\n    / "<<=" / ">>=" / ">>>="\n    / "&=" / "^=" / "|="\n    / "**=") _WS;\n\n\n    # A.3 Statements\n\n    # to be extended.\n    # The exprStatement production must go last, so PEG\'s prioritized\n    # choice will interpret {} as a block rather than an expression.\n    statement <-\n      block\n    / IF LEFT_PAREN expr RIGHT_PAREN arm ELSE elseArm      ',"\n    / IF LEFT_PAREN expr RIGHT_PAREN arm                   ","\n    / breakableStatement\n    / terminator\n    / IDENT COLON statement                                ","\n    / TRY block catcher finalizer                          ","\n    / TRY block catcher                                    ","\n    / TRY block finalizer                                  ","\n    / DEBUGGER SEMI                                        ","\n    / exprStatement;\n\n    # to be overridden.  In Jessie, only blocks are accepted as arms\n    # of flow-of-control statements.\n    arm <- block;\n\n    # Allows for\n    # if (...) {} else if (...) {} else if (...) {};\n    elseArm <-\n      arm\n    / IF LEFT_PAREN expr RIGHT_PAREN arm ELSE elseArm      ","\n    / IF LEFT_PAREN expr RIGHT_PAREN arm                   ",";\n\n    breakableStatement <-\n      FOR LEFT_PAREN declOp forOfBinding OF expr RIGHT_PAREN arm\n            ","\n    / FOR LEFT_PAREN declaration expr? SEMI expr? RIGHT_PAREN arm ","\n    / WHILE LEFT_PAREN expr RIGHT_PAREN arm                       ","\n    / SWITCH LEFT_PAREN expr RIGHT_PAREN LEFT_BRACE clause* RIGHT_BRACE\n            ",';\n\n    # Each case clause must end in a terminating statement.\n    terminator <-\n      "continue" _NO_NEWLINE IDENT SEMI                ','\n    / "continue" _WS SEMI                              ','\n    / "break" _NO_NEWLINE IDENT SEMI                   ','\n    / "break" _WS SEMI                                 ','\n    / "return" _NO_NEWLINE expr SEMI                   ','\n    / "return" _WS SEMI                                ','\n    / "throw" _NO_NEWLINE expr SEMI                    ',";\n\n    block <- LEFT_BRACE body RIGHT_BRACE              ",';\n    body <- statementItem*;\n\n    # declaration must come first, so that PEG will prioritize\n    # function declarations over exprStatement.\n    statementItem <-\n      declaration\n    / statement;\n\n    # No "class" declaration.\n    # No generator, async, or async iterator function.\n    declaration <-\n      declOp binding ** _COMMA SEMI                    ','\n    / functionDecl;\n\n    declOp <- ("const" / "let") _WSN;\n\n    forOfBinding <- bindingPattern / defVar;\n    binding <-\n      bindingPattern EQUALS assignExpr                ',"\n    / defVar EQUALS assignExpr                        ","\n    / defVar;\n\n    bindingPattern <-\n      LEFT_BRACKET elementParam ** _COMMA RIGHT_BRACKET     ","\n    / LEFT_BRACE propParam ** _COMMA RIGHT_BRACE            ",";\n\n    pattern <-\n      bindingPattern\n    / defVar\n    / dataLiteral                                     ","\n    / HOLE                                            ",";\n\n    # to be overridden\n    elementParam <- param;\n\n    param <-\n      ELLIPSIS pattern                                ","\n    / defVar EQUALS assignExpr                        ","\n    / pattern;\n\n    propParam <-\n      ELLIPSIS pattern                                ","\n    / propName COLON pattern                          ","\n    / defVar EQUALS assignExpr                        ","\n    / defVar                                          ",";\n\n    # Use PEG prioritized choice.\n    # TODO emit diagnostic for failure cases.\n    exprStatement <-\n      ~cantStartExprStatement expr SEMI               ",';\n\n    cantStartExprStatement <-\n      ("{" / "function" / "async" _NO_NEWLINE "function"\n    / "class" / "let" / "[") _WSN;\n\n    # to be overridden\n    terminatedBody <- ((~terminator statementItem)* terminator)+   ',";\n    clause <-\n      caseLabel+ LEFT_BRACE terminatedBody RIGHT_BRACE ",";\n    caseLabel <-\n      CASE expr COLON                                 ","\n    / DEFAULT _WS COLON                                ",";\n\n    catcher <- CATCH LEFT_PAREN pattern RIGHT_PAREN block ",";\n    finalizer <- FINALLY block                        ",";\n\n\n    # A.4 Functions and Classes\n\n    functionDecl <-\n      FUNCTION defVar LEFT_PAREN param ** _COMMA RIGHT_PAREN block\n                                                      ",";\n\n    functionExpr <-\n      FUNCTION defVar? LEFT_PAREN param ** _COMMA RIGHT_PAREN block\n                                                      ",";\n\n    # The assignExpr form must come after the block form, to make proper use\n    # of PEG prioritized choice.\n    arrowFunc <-\n      arrowParams _NO_NEWLINE ARROW block              ","\n    / arrowParams _NO_NEWLINE ARROW assignExpr         ",";\n\n    arrowParams <-\n      IDENT                                           ","\n    / LEFT_PAREN param ** _COMMA RIGHT_PAREN           ",";\n\n    # to be extended\n    methodDef <-\n      method\n    / GET propName LEFT_PAREN RIGHT_PAREN block            ","\n    / SET propName LEFT_PAREN param RIGHT_PAREN block      ",";\n\n    method <-\n      propName LEFT_PAREN param ** _COMMA RIGHT_PAREN block ",";\n\n\n    # A.5 Scripts and Modules\n\n    moduleBody <- moduleItem*;\n    moduleItem <-\n      SEMI                                               ","\n    / importDecl\n    / exportDecl\n    / moduleDeclaration;\n\n    useImport <- IMPORT_PFX IDENT                 ",";\n    defImport <- IMPORT_PFX IDENT                 ",';\n\n    moduleDeclaration <-\n      "const" _WSN moduleBinding ** _COMMA SEMI       ',";\n\n    # An insulated expression without side-effects.\n    insulatedExpr <-\n      dataLiteral                                     ",'\n    / "insulate" _WS LEFT_PAREN (pureExpr / useImport) RIGHT_PAREN  ',";\n\n    # Jessie modules only allow insulated module-level bindings.\n    moduleBinding <-\n      bindingPattern EQUALS insulatedExpr       ","\n    / defVar EQUALS insulatedExpr               ","\n    / defVar;\n\n    importClause <-\n      STAR AS defImport                         ","\n    / namedImports                              ","\n    / defImport _COMMA STAR AS defImport        ","\n    / defImport _COMMA namedImports             ","\n    / defImport                                 ",";\n\n    importSpecifier <-\n      defImport                                 ","\n    / IDENT_NAME AS defImport                   ",";\n\n    namedImports <-\n      LEFT_BRACE importSpecifier ** _COMMA _COMMA? RIGHT_BRACE ",";\n\n    importDecl <- IMPORT importClause FROM STRING SEMI  ",";\n    exportDecl <-\n      EXPORT DEFAULT exportableExpr SEMI        ","\n    / EXPORT moduleDeclaration                  ",';\n\n    # to be extended\n    exportableExpr <- insulatedExpr;\n\n    # Lexical syntax\n    ARROW <- "=>" _WS;\n    AS <- "as" _WSN;\n    DEBUGGER <- "debugger" _WSN;\n    PLUSPLUS <- "++" _WSN;\n    MINUSMINUS <- "--" _WSN;\n    CASE <- "case" _WSN;\n    IF <- "if" _WSN;\n    ELSE <- "else" _WSN;\n    FOR <- "for" _WSN;\n    OF <- "of" _WSN;\n    WHILE <- "while" _WSN;\n    BREAK <- "break" _WSN;\n    CONTINUE <- "continue" _WSN;\n    SWITCH <- "switch" _WSN;\n    TRY <- "try" _WSN;\n    CATCH <- "catch" _WSN;\n    FINALLY <- "finally" _WSN;\n    GET <- "get" _WSN;\n    SET <- "set" _WSN;\n    IMPORT <- "import" _WSN;\n    EXPORT <- "export" _WSN;\n    FROM <- "from" _WSN;\n    FUNCTION <- "function" _WSN;\n    DEFAULT <- "default" _WSN;\n    EQUALS <- "=" _WS;\n    SEMI <- ";" _WS;\n    STAR <- "*" _WS;\n    ']);return i=function(){return n},n}function a(n,r){return r||(r=n.slice(0)),Object.freeze(Object.defineProperties(n,{raw:{value:Object.freeze(r)}}))}function u(n,r){return p(n)||s(n,r)||c()}function c(){throw new TypeError("Invalid attempt to destructure non-iterable instance")}function s(n,r){var e=[],t=!0,o=!1,i=void 0;try{for(var a,u=n[Symbol.iterator]();!(t=(a=u.next()).done)&&(e.push(a.value),!r||e.length!==r);t=!0);}catch(c){o=!0,i=c}finally{try{t||null==u.return||u.return()}finally{if(o)throw i}}return e}function p(n){if(Array.isArray(n))return n}Object.defineProperty(exports,"__esModule",{value:!0}),exports.default=void 0;var E=insulate(function(n){return["block",n.reduce(function(n,r){var e=u(r,2),t=e[0],o=e[1];return t.forEach(function(r){return n.push(r)}),n.push(o),n},[])]}),f=insulate(function(e,t){var o=t.SKIP,a=t(i(),function(n){return function(){return["module",n]}},function(n){return"pre:".concat(n)},function(n,r,e){return["index",r]},function(n,r,e,t){return["indexLater",e]},function(n,r){return["getLater",r]},function(n,r){return["callLater",r]},function(n,r){return[r,n]},function(n,r,e){return[r,n,e]},function(n,r,e,t){return["index",n,e]},function(n,r,e,t,o){return["indexLater",n,t]},function(n,r,e){return["get",n,e]},function(n,r,e){return["getLater",n,e]},function(n,r,e,t,o,i,a){return["if",e,o,a]},function(n,r,e,t,o){return["if",e,o]},function(n,r,e){return["label",n,e]},function(n,r,e,t){return["try",r,e,t]},function(n,r,e){return["try",r,e]},function(n,r,e){return["try",r,void 0,e]},function(n,r){return["debugger"]},function(n,r,e,t,o,i,a){return["if",e,o,a]},function(n,r,e,t,o){return["if",e,o]},function(n,r,e,t,o,i,a,u){return["forOf",e,t,i,u]},function(n,r,e,t,o,i,a,u){return["for",e,t,i,u]},function(n,r,e,t,o){return["while",e,o]},function(n,r,e,t,o,i,a){return["switch",e,i]},function(n,r,e){return["continue",r]},function(n,r){return["continue"]},function(n,r,e){return["break",r]},function(n,r){return["break"]},function(n,r,e){return["return",r]},function(n,r){return["return"]},function(n,r,e){return["throw",r]},function(n,r,e){return["block",r]},function(n,r,e){return[n,r]},function(n,r,e){return["bind",n,e]},function(n,r,e){return["bind",n,e]},function(n,r,e){return["matchArray",r]},function(n,r,e){return["matchRecord",r]},function(n){return["matchData",JSON.parse(n)]},function(n){return["patternHole",n]},function(n,r){return["rest",r]},function(n,r,e){return["optional",n,e]},function(n,r){return["restObj",r]},function(n,r,e){return["matchProp",n,e]},function(n,r,e){return["optionalProp",n[1],n,e]},function(n){return["matchProp",n[1],n]},function(n,r){return n},function(n){return E(n)},function(n,r,e,t){return["clause",n,e]},function(n,r){return["case",r]},function(n,r){return["default"]},function(n,r,e,t,o){return["catch",e,o]},function(n,r){return["finally",r]},function(n,r,e,t,o,i){return["functionDecl",r,t,i]},function(n,r,e,t,o,i){return["functionExpr",r[0],t,i]},function(n,r,e){return["arrow",n,e]},function(n,r,e){return["lambda",n,e]},function(n){return[["def",n]]},function(n,r,e){return r},function(n,r,e,t,o){return["getter",r,[],o]},function(n,r,e,t,o,i){return["setter",r,[t],i]},function(n,r,e,t,o){return["method",n,e,o]},function(n){return o},function(n,r){return["use",n+r]},function(n,r){return["def",n+r]},function(n,r){return[n,r]},function(n){return["data",JSON.parse(n)]},function(n,r,e,t){return["call",["use",n],[e]]},function(n,r,e){return["bind",n,e]},function(n,r,e){return["bind",n,e]},function(n,r,e){return["importBind",[["as","*",e[1]]]]},function(n){return["importBind",n]},function(n,r,e,t){return["importBind",[["as","default",n[1]],["as","*",t[1]]]]},function(n,e){return["importBind",[["as","default",n[1]]].concat(r(e))]},function(n){return["importBind",[["as","default",n[1]]]]},function(n){return["as",n[1],n[1]]},function(n,r,e){return["as",n,e[1]]},function(n,r,e){return r},function(n,r,e,t,o){return["import",r,JSON.parse(t)]},function(n,r,e,t){return["exportDefault",e]},function(n,e){return["export"].concat(r(e))});return[a,e.extends(a)(n(),function(n){return function(){return n}})]}),l=insulate(f);exports.default=l;
},{}],"My9u":[function(require,module,exports) {
"use strict";function n(){var r=e(["\n# to be overridden or inherited\nstart <- _WS assignExpr _EOF                ",";\n\n# to be extended\nprimaryExpr <- dataStructure;\n\ndataStructure <-\n  dataLiteral                             ","\n/ array\n/ record\n/ HOLE                                    ",";\n\n# An expression without side-effects.\n# to be extended\npureExpr <-\n  dataLiteral                             ","\n/ pureArray\n/ pureRecord\n/ HOLE                                    ",';\n\ndataLiteral <- (("null" / "false" / "true") _WSN / NUMBER / STRING) _WS;\n\npureArray <-\n  LEFT_BRACKET pureExpr ** _COMMA _COMMA? RIGHT_BRACKET ',";\n\narray <-\n  LEFT_BRACKET element ** _COMMA _COMMA? RIGHT_BRACKET ",';\n\n# to be extended\nelement <- assignExpr;\n\n# The JavaScript and JSON grammars calls records "objects"\n\npureRecord <-\n  LEFT_BRACE purePropDef ** _COMMA _COMMA? RIGHT_BRACE  ',";\n\nrecord <-\n  LEFT_BRACE propDef ** _COMMA _COMMA? RIGHT_BRACE  ",";\n\n# to be extended\npurePropDef <- propName COLON pureExpr     ",";\n\n# to be extended\npropDef <- propName COLON assignExpr       ",";\n\n# to be extended\npropName <- STRING                     ",';\n\n# to be overridden\nassignExpr <- primaryExpr;\n\n# Lexical syntax\n\n_EOF <- ~.;\nLEFT_BRACKET <- "[" _WS;\nRIGHT_BRACKET <- "]" _WS;\nLEFT_BRACE <- "{" _WS;\nRIGHT_BRACE <- "}" _WS;\n_COMMA <- "," _WS                     ',';\nCOLON <- ":" _WS;\nMINUS <- "-" _WS;\nHOLE <- &'," _WS;\n\nSTRING <- < '\"' (~'\"' character)* '\"' > _WS;\n\nutf8 <-\n  [Â-ß] utf8cont\n/ [à-ï] utf8cont utf8cont\n/ [ð-ô] utf8cont utf8cont utf8cont;\n\nutf8cont <- [-¿];\n\ncharacter <-\n  escape\n/ '\\u' hex hex hex hex\n/ ~'\\' ([ -] / utf8);\n\nescape <- '\\' ['\"\\bfnrt];\nhex <- digit / [a-fA-F];\n\nNUMBER <- < int frac? exp? > _WSN;\n\nint <- [1-9] digit+\n/ digit\n/ MINUS digit\n/ MINUS [1-9] digit+;\n\ndigit <- [0-9];\n\nfrac <- '.' digit+;\nexp <- [Ee] [+-]? digit+;\n\n# _WSN is whitespace or a non-ident character.\n_WSN <- ~[$A-Za-z_] _WS    ",";\n_WS <- [\t\n\r ]*          ",";\n"],["\n# to be overridden or inherited\nstart <- _WS assignExpr _EOF                ",";\n\n# to be extended\nprimaryExpr <- dataStructure;\n\ndataStructure <-\n  dataLiteral                             ","\n/ array\n/ record\n/ HOLE                                    ",";\n\n# An expression without side-effects.\n# to be extended\npureExpr <-\n  dataLiteral                             ","\n/ pureArray\n/ pureRecord\n/ HOLE                                    ",';\n\ndataLiteral <- (("null" / "false" / "true") _WSN / NUMBER / STRING) _WS;\n\npureArray <-\n  LEFT_BRACKET pureExpr ** _COMMA _COMMA? RIGHT_BRACKET ',";\n\narray <-\n  LEFT_BRACKET element ** _COMMA _COMMA? RIGHT_BRACKET ",';\n\n# to be extended\nelement <- assignExpr;\n\n# The JavaScript and JSON grammars calls records "objects"\n\npureRecord <-\n  LEFT_BRACE purePropDef ** _COMMA _COMMA? RIGHT_BRACE  ',";\n\nrecord <-\n  LEFT_BRACE propDef ** _COMMA _COMMA? RIGHT_BRACE  ",";\n\n# to be extended\npurePropDef <- propName COLON pureExpr     ",";\n\n# to be extended\npropDef <- propName COLON assignExpr       ",";\n\n# to be extended\npropName <- STRING                     ",';\n\n# to be overridden\nassignExpr <- primaryExpr;\n\n# Lexical syntax\n\n_EOF <- ~.;\nLEFT_BRACKET <- "[" _WS;\nRIGHT_BRACKET <- "]" _WS;\nLEFT_BRACE <- "{" _WS;\nRIGHT_BRACE <- "}" _WS;\n_COMMA <- "," _WS                     ',';\nCOLON <- ":" _WS;\nMINUS <- "-" _WS;\nHOLE <- &'," _WS;\n\nSTRING <- < '\"' (~'\"' character)* '\"' > _WS;\n\nutf8 <-\n  [\\xc2-\\xdf] utf8cont\n/ [\\xe0-\\xef] utf8cont utf8cont\n/ [\\xf0-\\xf4] utf8cont utf8cont utf8cont;\n\nutf8cont <- [\\x80-\\xbf];\n\ncharacter <-\n  escape\n/ '\\\\u' hex hex hex hex\n/ ~'\\\\' ([\\x20-\\x7f] / utf8);\n\nescape <- '\\\\' ['\"\\\\bfnrt];\nhex <- digit / [a-fA-F];\n\nNUMBER <- < int frac? exp? > _WSN;\n\nint <- [1-9] digit+\n/ digit\n/ MINUS digit\n/ MINUS [1-9] digit+;\n\ndigit <- [0-9];\n\nfrac <- '.' digit+;\nexp <- [Ee] [+\\-]? digit+;\n\n# _WSN is whitespace or a non-ident character.\n_WSN <- ~[$A-Za-z_] _WS    ",";\n_WS <- [\\t\\n\\r ]*          ",";\n"]);return n=function(){return r},r}function e(n,e){return e||(e=n.slice(0)),Object.freeze(Object.defineProperties(n,{raw:{value:Object.freeze(e)}}))}Object.defineProperty(exports,"__esModule",{value:!0}),exports.default=void 0;var r=insulate(function(e){var r=e.FAIL,t=e.HOLE,a=e.SKIP;return e(n(),function(n){return function(){return n}},function(n){return["data",JSON.parse(n)]},function(n){return["exprHole",n]},function(n){return["data",JSON.parse(n)]},function(n){return["exprHole",n]},function(n,e,r){return["array",e]},function(n,e,r){return["array",e]},function(n,e,r){return["record",e]},function(n,e,r){return["record",e]},function(n,e,r){return["prop",n,r]},function(n,e,r){return["prop",n,r]},function(n){var e=JSON.parse(n);return"__proto__"===e?r:["data",e]},function(n){return a},t,function(n){return a},function(n){return a})}),t=insulate(r);exports.default=t;
},{}],"fln+":[function(require,module,exports) {
"use strict";function r(r){return n(r)||e(r)||t()}function t(){throw new TypeError("Invalid attempt to spread non-iterable instance")}function e(r){if(Symbol.iterator in Object(r)||"[object Arguments]"===Object.prototype.toString.call(r))return Array.from(r)}function n(r){if(Array.isArray(r)){for(var t=0,e=new Array(r.length);t<r.length;t++)e[t]=r[t];return e}}Object.defineProperty(exports,"__esModule",{value:!0}),exports.reduceElisions=exports.qrepack=exports.qunpack=void 0;var o=insulate(function(t,e,n){return[t].concat(r(e),[n])});exports.qunpack=o;var a=insulate(function(r){for(var t=[r[0]],e=[],n=r.length,o=1;o<n;o+=2)e.push(r[o]),t.push(r[o+1]);var a=[].concat(t);return a.raw=t,[["data",a]].concat(e)});exports.qrepack=a;var i=insulate(function(r){var t=[],e=!0,n=!1,o=void 0;try{for(var a,i=r[Symbol.iterator]();!(e=(a=i.next()).done);e=!0){var u=a.value;void 0===u[0]?u.forEach(function(r){return t.push(void 0)}):t.push(u)}}catch(c){n=!0,o=c}finally{try{e||null==i.return||i.return()}finally{if(n)throw o}}return t});exports.reduceElisions=i;
},{}],"X5zO":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.default=void 0;var n=require("./quasi-utils.mjs");function e(){var n=r(["\n    # to be overridden or inherited\n    start <- _WS assignExpr _EOF                       ",';\n\n    # A.1 Lexical Grammar\n\n    DOT <- "." _WS;\n    ELLIPSIS <- "..." _WS;\n    LEFT_PAREN <- "(" _WS;\n    PLUS <- "+" _WS;\n    QUESTION <- "?" _WS;\n    RIGHT_PAREN <- ")" _WS;\n    STARSTAR <- "**" _WS;\n\n    # Define Javascript-style comments.\n    _WS <- super._WS (EOL_COMMENT / MULTILINE_COMMENT)?   ',';\n    EOL_COMMENT <- "//" (~[\n\r] .)* _WS;\n    MULTILINE_COMMENT <- "/*" (~"*/" .)* "*/" _WS;\n\n    # Add single-quoted strings.\n    STRING <-\n      super.STRING\n    / "\'" < (~"\'" character)* > "\'" _WS  ',";\n\n    # Only match if whitespace doesn't contain newline\n    _NO_NEWLINE <- ~IDENT [ \t]*     ",';\n\n    IDENT_NAME <- ~(HIDDEN_PFX / "__proto__") (IDENT / RESERVED_WORD);\n\n    IDENT <- ~(HIDDEN_PFX / IMPORT_PFX) < [$A-Za-z_] [$A-Za-z0-9_]* > _WS;\n    HIDDEN_PFX <- "$h_";\n    IMPORT_PFX <- "$i_";\n\n    # Omit "async", "arguments", "eval", "get", and "set" from IDENT\n    # in Justin even though ES2017 considers them in IDENT.\n    RESERVED_WORD <-\n      (KEYWORD / RESERVED_KEYWORD / FUTURE_RESERVED_WORD\n    / "null" / "false" / "true"\n    / "async" / "arguments" / "eval" / "get" / "set") _WSN;\n\n    KEYWORD <-\n      ("break"\n    / "case" / "catch" / "const" / "continue"\n    / "debugger" / "default"\n    / "else" / "export"\n    / "finally" / "for" / "function"\n    / "if" / "import"\n    / "return"\n    / "switch"\n    / "throw" / "try" / "typeof"\n    / "void"\n    / "while") _WSN;\n\n    # Unused by Justin but enumerated here, in order to omit them\n    # from the IDENT token.\n    RESERVED_KEYWORD <-\n      ("class"\n    / "delete" / "do"\n    / "extends"\n    / "in" / "instanceof"\n    / "new"\n    / "super"\n    / "this"\n    / "var"\n    / "with"\n    / "yield") _WSN;\n\n    FUTURE_RESERVED_WORD <-\n      ("await" / "enum"\n    / "implements" / "package" / "protected"\n    / "interface" / "private" / "public") _WSN;\n\n    # Quasiliterals aka template literals\n    QUASI_CHAR <- "\\" . / ~"`" .;\n    QUASI_ALL <- "`" < (~"${" QUASI_CHAR)* > "`" _WS;\n    QUASI_HEAD <- "`" < (~"${" QUASI_CHAR)* > "${" _WS;\n    QUASI_MID <- "}" < (~"${" QUASI_CHAR)* > "${" _WS;\n    QUASI_TAIL <- "}" < (~"${" QUASI_CHAR)* > "`" _WS;\n\n\n    # A.2 Expressions\n\n    dataStructure <-\n      "undefined" _WSN     ',"\n    / super.dataStructure;\n\n    # Optional trailing commas.\n    record <-\n      super.record\n    / LEFT_BRACE propDef ** _COMMA _COMMA? RIGHT_BRACE      ",";\n\n    array <-\n      super.array\n    / LEFT_BRACKET element ** _COMMA _COMMA? RIGHT_BRACKET  ",";\n\n    useVar <- IDENT                                       ",";\n\n    # Justin does not contain variable definitions, only uses. However,\n    # multiple languages that extend Justin will contain defining\n    # occurrences of variable names, so we put the defVar production\n    # here.\n    defVar <- IDENT                                       ",";\n\n\n    primaryExpr <-\n      super.primaryExpr\n    / quasiExpr\n    / LEFT_PAREN expr RIGHT_PAREN                         ","\n    / useVar;\n\n    pureExpr <-\n      super.pureExpr\n    / LEFT_PAREN pureExpr RIGHT_PAREN                     ","\n    / useVar;\n\n    element <-\n      super.element\n    / ELLIPSIS assignExpr                                 ",";\n\n    propDef <-\n      super.propDef\n    / useVar                                              ","\n    / ELLIPSIS assignExpr                                 ",";\n\n    purePropDef <-\n      super.purePropDef\n    / useVar                                              ","\n    / ELLIPSIS assignExpr                                 ",";\n\n    # No computed property name\n    propName <-\n      super.propName\n    / IDENT_NAME\n    / NUMBER;\n\n    quasiExpr <-\n      QUASI_ALL                                            ","\n    / QUASI_HEAD expr ** QUASI_MID QUASI_TAIL              ",";\n\n    # to be extended\n    memberPostOp <-\n      LEFT_BRACKET indexExpr RIGHT_BRACKET                 ","\n    / DOT IDENT_NAME                                       ","\n    / quasiExpr                                            ",";\n\n    # to be extended\n    callPostOp <-\n      memberPostOp\n    / args                                                 ",';\n\n    # Because Justin and Jessie have no "new" or "super", they don\'t need\n    # to distinguish callExpr from memberExpr. So justin omits memberExpr\n    # and newExpr. Instead, in Justin, callExpr jumps directly to\n    # primaryExpr and updateExpr jumps directly to callExpr.\n\n    # to be overridden.\n    callExpr <- primaryExpr callPostOp*                   ',";\n\n    # To be overridden rather than inherited.\n    # Introduced to impose a non-JS restriction\n    # Restrict index access to number-names, including\n    # floating point, NaN, Infinity, and -Infinity.\n    indexExpr <-\n      NUMBER                                               ","\n    / PLUS unaryExpr                                       ",";\n\n    args <- LEFT_PAREN arg ** _COMMA RIGHT_PAREN            ",";\n\n    arg <-\n      assignExpr\n    / ELLIPSIS assignExpr                                  ",";\n\n    # to be overridden\n    updateExpr <- callExpr;\n\n    unaryExpr <-\n      preOp unaryExpr                                      ",'\n    / updateExpr;\n\n    # to be extended\n    # No prefix or postfix "++" or "--".\n    # No "delete".\n    preOp <- (("void" / "typeof") _WSN / prePre);\n    prePre <- ("+" / "-" / "~" / "!") _WS                 ',";\n\n    # Different communities will think -x**y parses in different ways,\n    # so the EcmaScript grammar forces parens to disambiguate.\n    powExpr <-\n      updateExpr STARSTAR powExpr                          ","\n    / unaryExpr;\n\n    multExpr <- powExpr (multOp powExpr)*                  ",";\n    addExpr <- multExpr (addOp multExpr)*                  ",";\n    shiftExpr <- addExpr (shiftOp addExpr)*                ",";\n\n    # Non-standard, to be overridden\n    # In C-like languages, the precedence and associativity of the\n    # relational, equality, and bitwise operators is surprising, and\n    # therefore hazardous. Here, none of these associate with the\n    # others, forcing parens to disambiguate.\n    eagerExpr <- shiftExpr (eagerOp shiftExpr)?            ",";\n\n    andThenExpr <- eagerExpr (andThenOp eagerExpr)*       ",";\n    orElseExpr <- andThenExpr (orElseOp andThenExpr)*     ",';\n\n    multOp <- ("*" / "/" / "%") _WS;\n    addOp <- ("+" / "-") _WS;\n    shiftOp <- ("<<" / ">>>" / ">>") _WS;\n    relOp <- ("<=" / "<" / ">=" / ">") _WS;\n    eqOp <- ("===" / "!==") _WS;\n    bitOp <- ("&" / "^" / "|") _WS;\n\n    eagerOp <- relOp / eqOp / bitOp;\n\n    andThenOp <- "&&" _WS;\n    orElseOp <- "||" _WS;\n\n    condExpr <-\n      orElseExpr QUESTION assignExpr COLON assignExpr   ',"\n    / orElseExpr;\n\n    # override, to be extended\n    assignExpr <- condExpr;\n\n    # The comma expression is not in Jessie because we\n    # opt to pass only insulated expressions as the this-binding.\n    expr <- assignExpr;\n  "],["\n    # to be overridden or inherited\n    start <- _WS assignExpr _EOF                       ",';\n\n    # A.1 Lexical Grammar\n\n    DOT <- "." _WS;\n    ELLIPSIS <- "..." _WS;\n    LEFT_PAREN <- "(" _WS;\n    PLUS <- "+" _WS;\n    QUESTION <- "?" _WS;\n    RIGHT_PAREN <- ")" _WS;\n    STARSTAR <- "**" _WS;\n\n    # Define Javascript-style comments.\n    _WS <- super._WS (EOL_COMMENT / MULTILINE_COMMENT)?   ',';\n    EOL_COMMENT <- "//" (~[\\n\\r] .)* _WS;\n    MULTILINE_COMMENT <- "/*" (~"*/" .)* "*/" _WS;\n\n    # Add single-quoted strings.\n    STRING <-\n      super.STRING\n    / "\'" < (~"\'" character)* > "\'" _WS  ',";\n\n    # Only match if whitespace doesn't contain newline\n    _NO_NEWLINE <- ~IDENT [ \\t]*     ",';\n\n    IDENT_NAME <- ~(HIDDEN_PFX / "__proto__") (IDENT / RESERVED_WORD);\n\n    IDENT <- ~(HIDDEN_PFX / IMPORT_PFX) < [$A-Za-z_] [$A-Za-z0-9_]* > _WS;\n    HIDDEN_PFX <- "$h_";\n    IMPORT_PFX <- "$i_";\n\n    # Omit "async", "arguments", "eval", "get", and "set" from IDENT\n    # in Justin even though ES2017 considers them in IDENT.\n    RESERVED_WORD <-\n      (KEYWORD / RESERVED_KEYWORD / FUTURE_RESERVED_WORD\n    / "null" / "false" / "true"\n    / "async" / "arguments" / "eval" / "get" / "set") _WSN;\n\n    KEYWORD <-\n      ("break"\n    / "case" / "catch" / "const" / "continue"\n    / "debugger" / "default"\n    / "else" / "export"\n    / "finally" / "for" / "function"\n    / "if" / "import"\n    / "return"\n    / "switch"\n    / "throw" / "try" / "typeof"\n    / "void"\n    / "while") _WSN;\n\n    # Unused by Justin but enumerated here, in order to omit them\n    # from the IDENT token.\n    RESERVED_KEYWORD <-\n      ("class"\n    / "delete" / "do"\n    / "extends"\n    / "in" / "instanceof"\n    / "new"\n    / "super"\n    / "this"\n    / "var"\n    / "with"\n    / "yield") _WSN;\n\n    FUTURE_RESERVED_WORD <-\n      ("await" / "enum"\n    / "implements" / "package" / "protected"\n    / "interface" / "private" / "public") _WSN;\n\n    # Quasiliterals aka template literals\n    QUASI_CHAR <- "\\\\" . / ~"\\`" .;\n    QUASI_ALL <- "\\`" < (~"\\${" QUASI_CHAR)* > "\\`" _WS;\n    QUASI_HEAD <- "\\`" < (~"\\${" QUASI_CHAR)* > "\\${" _WS;\n    QUASI_MID <- "}" < (~"\\${" QUASI_CHAR)* > "\\${" _WS;\n    QUASI_TAIL <- "}" < (~"\\${" QUASI_CHAR)* > "\\`" _WS;\n\n\n    # A.2 Expressions\n\n    dataStructure <-\n      "undefined" _WSN     ',"\n    / super.dataStructure;\n\n    # Optional trailing commas.\n    record <-\n      super.record\n    / LEFT_BRACE propDef ** _COMMA _COMMA? RIGHT_BRACE      ",";\n\n    array <-\n      super.array\n    / LEFT_BRACKET element ** _COMMA _COMMA? RIGHT_BRACKET  ",";\n\n    useVar <- IDENT                                       ",";\n\n    # Justin does not contain variable definitions, only uses. However,\n    # multiple languages that extend Justin will contain defining\n    # occurrences of variable names, so we put the defVar production\n    # here.\n    defVar <- IDENT                                       ",";\n\n\n    primaryExpr <-\n      super.primaryExpr\n    / quasiExpr\n    / LEFT_PAREN expr RIGHT_PAREN                         ","\n    / useVar;\n\n    pureExpr <-\n      super.pureExpr\n    / LEFT_PAREN pureExpr RIGHT_PAREN                     ","\n    / useVar;\n\n    element <-\n      super.element\n    / ELLIPSIS assignExpr                                 ",";\n\n    propDef <-\n      super.propDef\n    / useVar                                              ","\n    / ELLIPSIS assignExpr                                 ",";\n\n    purePropDef <-\n      super.purePropDef\n    / useVar                                              ","\n    / ELLIPSIS assignExpr                                 ",";\n\n    # No computed property name\n    propName <-\n      super.propName\n    / IDENT_NAME\n    / NUMBER;\n\n    quasiExpr <-\n      QUASI_ALL                                            ","\n    / QUASI_HEAD expr ** QUASI_MID QUASI_TAIL              ",";\n\n    # to be extended\n    memberPostOp <-\n      LEFT_BRACKET indexExpr RIGHT_BRACKET                 ","\n    / DOT IDENT_NAME                                       ","\n    / quasiExpr                                            ",";\n\n    # to be extended\n    callPostOp <-\n      memberPostOp\n    / args                                                 ",';\n\n    # Because Justin and Jessie have no "new" or "super", they don\'t need\n    # to distinguish callExpr from memberExpr. So justin omits memberExpr\n    # and newExpr. Instead, in Justin, callExpr jumps directly to\n    # primaryExpr and updateExpr jumps directly to callExpr.\n\n    # to be overridden.\n    callExpr <- primaryExpr callPostOp*                   ',";\n\n    # To be overridden rather than inherited.\n    # Introduced to impose a non-JS restriction\n    # Restrict index access to number-names, including\n    # floating point, NaN, Infinity, and -Infinity.\n    indexExpr <-\n      NUMBER                                               ","\n    / PLUS unaryExpr                                       ",";\n\n    args <- LEFT_PAREN arg ** _COMMA RIGHT_PAREN            ",";\n\n    arg <-\n      assignExpr\n    / ELLIPSIS assignExpr                                  ",";\n\n    # to be overridden\n    updateExpr <- callExpr;\n\n    unaryExpr <-\n      preOp unaryExpr                                      ",'\n    / updateExpr;\n\n    # to be extended\n    # No prefix or postfix "++" or "--".\n    # No "delete".\n    preOp <- (("void" / "typeof") _WSN / prePre);\n    prePre <- ("+" / "-" / "~" / "!") _WS                 ',";\n\n    # Different communities will think -x**y parses in different ways,\n    # so the EcmaScript grammar forces parens to disambiguate.\n    powExpr <-\n      updateExpr STARSTAR powExpr                          ","\n    / unaryExpr;\n\n    multExpr <- powExpr (multOp powExpr)*                  ",";\n    addExpr <- multExpr (addOp multExpr)*                  ",";\n    shiftExpr <- addExpr (shiftOp addExpr)*                ",";\n\n    # Non-standard, to be overridden\n    # In C-like languages, the precedence and associativity of the\n    # relational, equality, and bitwise operators is surprising, and\n    # therefore hazardous. Here, none of these associate with the\n    # others, forcing parens to disambiguate.\n    eagerExpr <- shiftExpr (eagerOp shiftExpr)?            ",";\n\n    andThenExpr <- eagerExpr (andThenOp eagerExpr)*       ",";\n    orElseExpr <- andThenExpr (orElseOp andThenExpr)*     ",';\n\n    multOp <- ("*" / "/" / "%") _WS;\n    addOp <- ("+" / "-") _WS;\n    shiftOp <- ("<<" / ">>>" / ">>") _WS;\n    relOp <- ("<=" / "<" / ">=" / ">") _WS;\n    eqOp <- ("===" / "!==") _WS;\n    bitOp <- ("&" / "^" / "|") _WS;\n\n    eagerOp <- relOp / eqOp / bitOp;\n\n    andThenOp <- "&&" _WS;\n    orElseOp <- "||" _WS;\n\n    condExpr <-\n      orElseExpr QUESTION assignExpr COLON assignExpr   ',"\n    / orElseExpr;\n\n    # override, to be extended\n    assignExpr <- condExpr;\n\n    # The comma expression is not in Jessie because we\n    # opt to pass only insulated expressions as the this-binding.\n    expr <- assignExpr;\n  "]);return e=function(){return n},n}function r(n,e){return e||(e=n.slice(0)),Object.freeze(Object.defineProperties(n,{raw:{value:Object.freeze(e)}}))}function t(n,e){return p(n)||i(n,e)||a()}function a(){throw new TypeError("Invalid attempt to destructure non-iterable instance")}function i(n,e){var r=[],t=!0,a=!1,i=void 0;try{for(var p,s=n[Symbol.iterator]();!(t=(p=s.next()).done)&&(r.push(p.value),!e||r.length!==e);t=!0);}catch(o){a=!0,i=o}finally{try{t||null==s.return||s.return()}finally{if(a)throw i}}return r}function p(n){if(Array.isArray(n))return n}var s=insulate(n.qunpack),o=insulate(function(n,e){return e.reduce(function(n,e){var r=t(e,2);return[r[0],n,r[1]]},n)}),E=insulate(function(n){for(var e=0,r="";e<n.length;){var t=n.slice(e,e+1);"\\"===t?(r+=n.slice(e,e+2),e+=2):'"'===t?(r+='\\"',e++):(r+=t,e++)}return'"'.concat(r,'"')}),u=insulate(function(n){var r=n.SKIP;return n(e(),function(n){return function(){return n}},function(n){return r},function(n){return E(n)},function(n){return r},function(n){return["data",void 0]},function(n,e,r){return["record",e]},function(n,e,r){return["array",e]},function(n){return["use",n]},function(n){return["def",n]},function(n,e,r){return e},function(n,e,r){return e},function(n,e){return["spread",e]},function(n){return["prop",n[1],n]},function(n,e){return["spreadObj",e]},function(n){return["prop",n[1],n]},function(n,e){return["spreadObj",e]},function(n){return["quasi",[n]]},function(n,e,r){return["quasi",s(n,e,r)]},function(n,e,r){return["index",e]},function(n,e){return["get",e]},function(n){return["tag",n]},function(n){return["call",n]},o,function(n){return["data",JSON.parse(n)]},function(n,e){return["pre:+",e]},function(n,e,r){return e},function(n,e){return["spread",e]},function(n,e){return[n,e]},function(n){return"pre:".concat(n)},function(n,e,r){return[e,n,r]},o,o,o,o,o,o,function(n,e,r,t,a){return["cond",n,r,a]})}),d=insulate(u);exports.default=d;
},{"./quasi-utils.mjs":"fln+"}],"SAPa":[function(require,module,exports) {
"use strict";function t(t){return r(t)||a(t)||n()}function n(){throw new TypeError("Invalid attempt to spread non-iterable instance")}function r(t){if(Array.isArray(t)){for(var n=0,r=new Array(t.length);n<t.length;n++)r[n]=t[n];return r}}function e(){var t=o(["No rewriter for ",""]);return e=function(){return t},t}function o(t,n){return n||(n=t.slice(0)),Object.freeze(Object.defineProperties(t,{raw:{value:Object.freeze(n)}}))}function c(t){return l(t)||a(t)||i()}function a(t){if(Symbol.iterator in Object(t)||"[object Arguments]"===Object.prototype.toString.call(t))return Array.from(t)}function u(t,n){return l(t)||f(t,n)||i()}function i(){throw new TypeError("Invalid attempt to destructure non-iterable instance")}function f(t,n){var r=[],e=!0,o=!1,c=void 0;try{for(var a,u=t[Symbol.iterator]();!(e=(a=u.next()).done)&&(r.push(a.value),!n||r.length!==n);e=!0);}catch(i){o=!0,c=i}finally{try{e||null==u.return||u.return()}finally{if(o)throw c}}return r}function l(t){if(Array.isArray(t))return t}Object.defineProperty(exports,"__esModule",{value:!0}),exports.default=void 0;var v=insulate(function(t){return"$h_".concat(t)}),s=insulate(function(t,n){var r="",e="",o=!0,c=!1,a=void 0;try{for(var u,i=t[Symbol.iterator]();!(o=(u=i.next()).done);o=!0){var f=u.value;""!==f&&(r+=e+f,e=n)}}catch(l){c=!0,a=l}finally{try{o||null==i.return||i.return()}finally{if(c)throw a}}return r}),y=insulate(function(n){var r,o=arguments.length>1&&void 0!==arguments[1]?arguments[1]:v("define"),a=v("exports"),i=makeMap(),f=makeSet(),l=0,y={as:function(t,n){return"*"===t?(r=n,""):"".concat(t,": ").concat(n)},bind:function(t,n){var r=d(t);return"".concat(r," = ").concat(d(n))},def:function(t){return f.add(t),t},exportDefaultX:function(t){return"".concat(a,".default = ").concat(d(t),";")},exportX:function(t,n){f.clear();var r=s(n.map(d),", "),e="",o=!0,c=!1,u=void 0;try{for(var i,l=f.keys()[Symbol.iterator]();!(o=(i=l.next()).done);o=!0){var v=i.value;e+="".concat(a,".").concat(v," = ").concat(v,";\n")}}catch(y){c=!0,u=y}finally{try{o||null==l.return||l.return()}finally{if(c)throw u}}return f.clear(),"".concat(t," ").concat(r,";\n").concat(e)},import:function(t,n){r=void 0;var e=d(t);return void 0===r&&(r=v("star".concat(l++))),i.set(n,r),e?"const {".concat(e,"} = ").concat(r,";\n"):""},importBind:function(t){return s(t.map(d),", ")},matchArray:function(t){return"[".concat(s(t.map(d),", "),"]")},matchProp:function(t,n){var r=d(n);return t===r?t:"".concat(t,": ").concat(r)},matchRecord:function(t){return"{".concat(s(t.map(d),", "),"}")},moduleX:function(t){var n=t.reduce(function(t,n){return t+d(n)},""),r=[],e=[],c=!0,f=!1,l=void 0;try{for(var v,y=i.entries()[Symbol.iterator]();!(c=(v=y.next()).done);c=!0){var p=u(v.value,2),h=p[0],m=p[1];r.push(h),e.push(m)}}catch(w){f=!0,l=w}finally{try{c||null==y.return||y.return()}finally{if(f)throw l}}var b=s(e,", ");return"".concat(o,"(\n").concat(JSON.stringify(r),",\n(").concat(b,") => {\nconst ").concat(a," = {};\n").concat(n,"\nreturn ").concat(a,";\n})")},rest:function(t){return"...".concat(d(t))},restObj:function(t){return"...".concat(d(t))}},d=function(n){if("string"==typeof n)return n;var r=c(n),o=r[0],a=r.slice(1),u=y[o];if(!u)throw slog.error(e(),{name:o});return u.apply(void 0,t(a))};return d(n)}),d=insulate(y);exports.default=d;
},{}],"ZHvC":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.default=void 0;var r=insulate(function(e,t){function n(n){for(var u=arguments.length,a=new Array(u>1?u-1:0),i=1;i<u;i++)a[i-1]=arguments[i];if("string"==typeof n)return r(e(n),t);var o=n,s=o.reduce(function(r,e,t){return r.push(e,String(a[t])),r},[]);s.push(o[o.length-1]);var c=s.join(""),f=a.reduce(function(r,e,t){return r.push(String(e),o.raw[t+1]),r},[o.raw[0]]).join(""),l={byte:0,column:1,line:1,uri:t},p=[c];return p.raw=[f],p.sources=[l],e(p)}return n.parserCreator=e.parserCreator,n._asExtending=e._asExtending,n}),e=insulate(r);exports.default=e;
},{}],"bRI1":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.translate=void 0;var e=l(require("./boot-peg.mjs")),r=l(require("./boot-pegast.mjs")),t=l(require("./quasi-peg.mjs")),n=l(require("./quasi-jessie-module.mjs")),u=l(require("./quasi-jessie.mjs")),i=l(require("./quasi-json.mjs")),a=l(require("./quasi-justin.mjs")),o=l(require("./rewrite-define.mjs")),s=l(require("./tag-string.mjs"));function l(e){return e&&e.__esModule?e:{default:e}}function c(){var e=m(["Unrecognized targetType: ",""]);return c=function(){return e},e}function f(){var e=m(["",""]);return f=function(){return e},e}function d(e){for(var r=1;r<arguments.length;r++){var t=null!=arguments[r]?arguments[r]:{},n=Object.keys(t);"function"==typeof Object.getOwnPropertySymbols&&(n=n.concat(Object.getOwnPropertySymbols(t).filter(function(e){return Object.getOwnPropertyDescriptor(t,e).enumerable}))),n.forEach(function(r){j(e,r,t[r])})}return e}function j(e,r,t){return r in e?Object.defineProperty(e,r,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[r]=t,e}function g(){var e=m(["",""]);return g=function(){return e},e}function p(){var e=m(["Unrecognized target: ",""]);return p=function(){return e},e}function y(){var e=m(["Unrecognized sourceType: ",""]);return y=function(){return e},e}function m(e,r){return r||(r=e.slice(0)),Object.freeze(Object.defineProperties(e,{raw:{value:Object.freeze(r)}}))}function v(e,r){return w(e)||q(e,r)||b()}function b(){throw new TypeError("Invalid attempt to destructure non-iterable instance")}function q(e,r){var t=[],n=!0,u=!1,i=void 0;try{for(var a,o=e[Symbol.iterator]();!(n=(a=o.next()).done)&&(t.push(a.value),!r||t.length!==r);n=!0);}catch(s){u=!0,i=s}finally{try{n||null==o.return||o.return()}finally{if(u)throw i}}return t}function w(e){if(Array.isArray(e))return e}var h=insulate(e.default),O=insulate(r.default),x=insulate(t.default),T=insulate(n.default),P=insulate(u.default),z=insulate(i.default),U=insulate(a.default),_=insulate(o.default),S=insulate(s.default),k=insulate(h(x,O)),A=insulate(z(k)),E=insulate(U(k.extends(A))),L=insulate(P(k,k.extends(E))),M=v(L,1),R=M[0],D=insulate(T(k.extends(R))),I=insulate(function(e,r){return makePromise(function(t){var n=r.sourceType,u=r.target,i=r.targetType;if("jessie"!==n)throw slog.error(y(),{sourceType:n});if("jessie-frame"!==u)throw slog.error(p(),{target:u});switch(i){case"function":var a=S(D,r.sourceURL)(g(),e),o=_(a,"$h_define");return t(d({},r,{translatedText:o}));case"module":return S(R,r.sourceURL)(f(),e),t(d({},r,{translatedText:e}));default:throw slog.error(c(),{targetType:i})}})});exports.translate=I;
},{"./boot-peg.mjs":"QgFk","./boot-pegast.mjs":"joiS","./quasi-peg.mjs":"3zTw","./quasi-jessie-module.mjs":"xkRL","./quasi-jessie.mjs":"NMVp","./quasi-json.mjs":"My9u","./quasi-justin.mjs":"X5zO","./rewrite-define.mjs":"SAPa","./tag-string.mjs":"ZHvC"}],"lr5t":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),Object.defineProperty(exports,"translate",{enumerable:!0,get:function(){return r.translate}}),exports.SES=exports.globals=void 0;var e=n(require("./node_modules/ses/dist/ses.esm.js")),t=n(require("../nodejs/globalEnv.mjs")),r=require("../../lib/translate.mjs");function n(e){return e&&e.__esModule?e:{default:e}}function o(e){for(var t=1;t<arguments.length;t++){var r=null!=arguments[t]?arguments[t]:{},n=Object.keys(r);"function"==typeof Object.getOwnPropertySymbols&&(n=n.concat(Object.getOwnPropertySymbols(r).filter(function(e){return Object.getOwnPropertyDescriptor(r,e).enumerable}))),n.forEach(function(t){s(e,t,r[t])})}return e}function s(e,t,r){return t in e?Object.defineProperty(e,t,{value:r,enumerable:!0,configurable:!0,writable:!0}):e[t]=r,e}var l=o({},t.default,{insulate:t.insulate});exports.globals=l;var u=e.default;exports.SES=u;
},{"./node_modules/ses/dist/ses.esm.js":"iDNi","../nodejs/globalEnv.mjs":"fc7A","../../lib/translate.mjs":"bRI1"}]},{},["lr5t"], "jessica")
//# sourceMappingURL=jessica.0f0fb83a.js.map