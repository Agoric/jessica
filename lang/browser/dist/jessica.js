parcelRequire=function(e,r,t,n){var i,o="function"==typeof parcelRequire&&parcelRequire,u="function"==typeof require&&require;function f(t,n){if(!r[t]){if(!e[t]){var i="function"==typeof parcelRequire&&parcelRequire;if(!n&&i)return i(t,!0);if(o)return o(t,!0);if(u&&"string"==typeof t)return u(t);var c=new Error("Cannot find module '"+t+"'");throw c.code="MODULE_NOT_FOUND",c}p.resolve=function(r){return e[t][1][r]||r},p.cache={};var l=r[t]=new f.Module(t);e[t][0].call(l.exports,p,l,l.exports,this)}return r[t].exports;function p(e){return f(p.resolve(e))}}f.isParcelRequire=!0,f.Module=function(e){this.id=e,this.bundle=f,this.exports={}},f.modules=e,f.cache=r,f.parent=o,f.register=function(r,t){e[r]=[function(e,r){r.exports=t},{}]};for(var c=0;c<t.length;c++)try{f(t[c])}catch(e){i||(i=e)}if(t.length){var l=f(t[t.length-1]);"object"==typeof exports&&"undefined"!=typeof module?module.exports=l:"function"==typeof define&&define.amd?define(function(){return l}):n&&(this[n]=l)}if(parcelRequire=f,i)throw i;return f}({"eb5I":[function(require,module,exports) {
var global = arguments[3];
var n=arguments[3];function t(n){return o(n)||r(n)||e()}function e(){throw new TypeError("Invalid attempt to spread non-iterable instance")}function r(n){if(Symbol.iterator in Object(n)||"[object Arguments]"===Object.prototype.toString.call(n))return Array.from(n)}function o(n){if(Array.isArray(n)){for(var t=0,e=new Array(n.length);t<n.length;t++)e[t]=n[t];return e}}!function(n){var e=Object.freeze;n.confine=e(function(n,e){n=""+n;var r=Object.getOwnPropertyNames(e),o="(function(".concat(r.join(","),') { "use strict"; return (').concat(n,"\n  );\n})\n//# sourceURL=data:").concat(encodeURIComponent(n).slice(0,48),"...\n");return(0,eval)(o).apply(void 0,t(r.map(function(n){return e[n]})))}),n.immunize=e(e)}("undefined"==typeof window?n:window);
},{}],"O63h":[function(require,module,exports) {
"use strict";function t(t,i){return n(t)||e(t,i)||r()}function r(){throw new TypeError("Invalid attempt to destructure non-iterable instance")}function e(t,r){var e=[],n=!0,i=!1,u=void 0;try{for(var o,a=t[Symbol.iterator]();!(n=(o=a.next()).done)&&(e.push(o.value),!r||e.length!==r);n=!0);}catch(f){i=!0,u=f}finally{try{n||null==a.return||a.return()}finally{if(i)throw u}}return e}function n(t){if(Array.isArray(t))return t}Object.defineProperty(exports,"__esModule",{value:!0}),exports.default=void 0;var i=immunize(function(r,e,n){var i=r(function(r){for(var e=Object.entries(r),i=0;i<e.length;i++){var u=t(e[i],2),a=u[0],f=u[1];if("function"==typeof f){var c=o(f);try{n(r,a,c)}catch(l){continue}}}});var u=makeWeakMap();function o(r){var i=u.get(r);if(!i){i=e(a,r),u.set(r,i),u.set(i,i);for(var o=Object.entries(r),f=0;f<o.length;f++){var c=t(o[f],2),l=c[0],v=c[1];n(i,l,v)}}return i}function a(t){if("function"==typeof t){var r=o(t);return i(r)}return i(t)}return u.set(n,n),a}),u=immunize(i);exports.default=u;
},{}],"sRTJ":[function(require,module,exports) {
"use strict";function r(r){return n(r)||t(r)||e()}function e(){throw new TypeError("Invalid attempt to spread non-iterable instance")}function t(r){if(Symbol.iterator in Object(r)||"[object Arguments]"===Object.prototype.toString.call(r))return Array.from(r)}function n(r){if(Array.isArray(r)){for(var e=0,t=new Array(r.length);e<r.length;e++)t[e]=r[e];return t}}Object.defineProperty(exports,"__esModule",{value:!0}),exports.default=void 0;var a=immunize(function(e){var t=makeMap(),n=[],a=function(a,i){return a>=0&&(n[a]=i,t.set(i,a)),function(i){var o;if(!i.raw)return o=makeMap(r(Object.entries(i))),function(r){for(var i=arguments.length,c=new Array(i>1?i-1:0),u=1;u<i;u++)c[u-1]=arguments[u];return e(a,n,t,o,r,c)};o=makeMap();for(var c=i,u=arguments.length,f=new Array(u>1?u-1:0),l=1;l<u;l++)f[l-1]=arguments[l];return e(a,n,t,o,c,f)}},i=0,o=a(-1,"stringify");return o.panic=a(i++,"panic"),o.alert=a(i++,"alert"),o.crit=a(i++,"crit"),o.error=a(i++,"error"),o.reject=a(i++,"reject"),o.warn=a(i++,"warn"),o.notice=a(i++,"notice"),o.info=a(i++,"info"),o.debug=a(i++,"debug"),o.trace=a(i++,"trace"),o}),i=immunize(a);exports.default=i;
},{}],"g5I+":[function(require,module,exports) {

var t,e,n=module.exports={};function r(){throw new Error("setTimeout has not been defined")}function o(){throw new Error("clearTimeout has not been defined")}function i(e){if(t===setTimeout)return setTimeout(e,0);if((t===r||!t)&&setTimeout)return t=setTimeout,setTimeout(e,0);try{return t(e,0)}catch(n){try{return t.call(null,e,0)}catch(n){return t.call(this,e,0)}}}function u(t){if(e===clearTimeout)return clearTimeout(t);if((e===o||!e)&&clearTimeout)return e=clearTimeout,clearTimeout(t);try{return e(t)}catch(n){try{return e.call(null,t)}catch(n){return e.call(this,t)}}}!function(){try{t="function"==typeof setTimeout?setTimeout:r}catch(n){t=r}try{e="function"==typeof clearTimeout?clearTimeout:o}catch(n){e=o}}();var c,s=[],l=!1,a=-1;function f(){l&&c&&(l=!1,c.length?s=c.concat(s):a=-1,s.length&&h())}function h(){if(!l){var t=i(f);l=!0;for(var e=s.length;e;){for(c=s,s=[];++a<e;)c&&c[a].run();a=-1,e=s.length}c=null,l=!1,u(t)}}function m(t,e){this.fun=t,this.array=e}function p(){}n.nextTick=function(t){var e=new Array(arguments.length-1);if(arguments.length>1)for(var n=1;n<arguments.length;n++)e[n-1]=arguments[n];s.push(new m(t,e)),1!==s.length||l||i(h)},m.prototype.run=function(){this.fun.apply(null,this.array)},n.title="browser",n.env={},n.argv=[],n.version="",n.versions={},n.on=p,n.addListener=p,n.once=p,n.off=p,n.removeListener=p,n.removeAllListeners=p,n.emit=p,n.prependListener=p,n.prependOnceListener=p,n.listeners=function(t){return[]},n.binding=function(t){throw new Error("process.binding is not supported")},n.cwd=function(){return"/"},n.chdir=function(t){throw new Error("process.chdir is not supported")},n.umask=function(){return 0};
},{}],"fc7A":[function(require,module,exports) {
var global = arguments[3];
var process = require("process");
var e=arguments[3],r=require("process");Object.defineProperty(exports,"__esModule",{value:!0}),exports.default=exports.makeWrapper=exports.setComputedIndex=exports.applyMethod=void 0,require("./sesshim.mjs");var t=o(require("../../lib/immunize.mjs")),n=o(require("../../lib/slog.mjs"));function o(e){return e&&e.__esModule?e:{default:e}}function i(e){return f(e)||a(e)||u()}function u(){throw new TypeError("Invalid attempt to spread non-iterable instance")}function a(e){if(Symbol.iterator in Object(e)||"[object Arguments]"===Object.prototype.toString.call(e))return Array.from(e)}function f(e){if(Array.isArray(e)){for(var r=0,t=new Array(e.length);r<e.length;r++)t[r]=e[r];return t}}function c(){var e=m(["Context value "," mismatch: "," vs. ",""]);return c=function(){return e},e}function l(){if("undefined"==typeof Reflect||!Reflect.construct)return!1;if(Reflect.construct.sham)return!1;if("function"==typeof Proxy)return!0;try{return Date.prototype.toString.call(Reflect.construct(Date,[],function(){})),!0}catch(e){return!1}}function s(e,r,t){return(s=l()?Reflect.construct:function(e,r,t){var n=[null];n.push.apply(n,r);var o=new(Function.bind.apply(e,n));return t&&p(o,t.prototype),o}).apply(null,arguments)}function p(e,r){return(p=Object.setPrototypeOf||function(e,r){return e.__proto__=r,e})(e,r)}function y(e){return(y="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&"function"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e})(e)}function v(){var e=m(["Cannot set "," object member"]);return v=function(){return e},e}function m(e,r){return r||(r=e.slice(0)),Object.freeze(Object.defineProperties(e,{raw:{value:Object.freeze(r)}}))}var d={};d.confine=confine;var b=Object.freeze(function(e,r,t){return r.apply(e,t)});exports.applyMethod=b;var g=Object.freeze(function(e,r,t){return"__proto__"===r&&slog.error(v(),{index:r}),e[r]=t});exports.setComputedIndex=g;var h=Object.freeze(function(e,r){return function(){var t;try{for(var n=arguments.length,o=new Array(n),i=0;i<n;i++)o[i]=arguments[i];var u=o.map(e),a=e(this);t=r.apply(a,u)}catch(f){throw e(f)}return e(t)}});exports.makeWrapper=h;var j=function(r){var t=new WeakMap;return t.set(g,g),"undefined"!=typeof window&&t.set(window,window),void 0!==e&&t.set(e,e),function e(n){if(null===n)return n;var o=y(n);if("object"!==o&&"function"!==o)return n;if(t.has(n))return t.get(n);r(n);var i=Object.freeze(n);t.set(n,i);for(var u=Object.values(n),a=0;a<u.length;a++)e(u[a]);return i}};e.makeWeakMap=Object.freeze(function(){for(var e=arguments.length,r=new Array(e),t=0;t<e;t++)r[t]=arguments[t];return Object.freeze(s(WeakMap,r))});var w=(0,t.default)(j,h,g);d.immunize=w,d.makeMap=w(function(){for(var e=arguments.length,r=new Array(e),t=0;t<e;t++)r[t]=arguments[t];return s(Map,r)}),d.makeSet=w(function(){for(var e=arguments.length,r=new Array(e),t=0;t<e;t++)r[t]=arguments[t];return s(Set,r)}),d.makePromise=w(function(e){return new Promise(e)}),d.makeWeakMap=w(function(){for(var e=arguments.length,r=new Array(e),t=0;t<e;t++)r[t]=arguments[t];return s(WeakMap,r)}),d.makeWeakSet=w(function(){for(var e=arguments.length,r=new Array(e),t=0;t<e;t++)r[t]=arguments[t];return s(WeakSet,r)}),Object.keys(d).forEach(function(r){e[r]=d[r]});var O=function(e,r){if("object"!==y(r)||null===r)return""+r;if(void 0!==r.length)return r;for(var t,n,o=Object.keys(r),i=0;i<o.length;i++){var u=o[i];if("format"===u);else{if(void 0!==t||"function"==typeof r[u])return r;t=u,n=JSON.stringify(r[u],void 0,2)}}if(void 0===t)return r;if("_"===t[0]);else if(e.has(t)){var a=e.get(t);n!==a&&slog.error(c(),{valname:t},{val:n},{oval:a})}else e.set(t,n);return n},k=(0,n.default)(function(e,t,n,o,u,a){var f,c=a.reduce(function(e,r,t){f=O(o,r);var n=e[e.length-1];return"object"===y(f)&&void 0!==f?(e[e.length-1]=n.trimRight(),e.push(f,u[t+1].trimLeft())):e[e.length-1]=n+String(f)+u[t+1],e},[t[e]+": "+u[0]]);if(e===n.get("stringify"))return c.join(" ");if(e>=n.get("warn")){var l;(l=console).error.apply(l,i(c))}else{var s,p=(new Error).stack,v=p.slice(p.indexOf("\n")+1),m=v.slice(v.indexOf("\n")+1),d=m.slice(m.indexOf("\n"));(s=console).error.apply(s,i(c).concat([d]))}if("reject"===t[e])return Promise.reject(c.join(" "));if(e<=n.get("panic"))r.exitCode=99;else if(e<=n.get("error"))throw c.join(" ");return c.join(" ")});d.slog=k,Object.keys(d).forEach(function(r){e[r]=d[r]});var x=d;exports.default=x;
},{"./sesshim.mjs":"eb5I","../../lib/immunize.mjs":"O63h","../../lib/slog.mjs":"sRTJ","process":"g5I+"}],"cE9W":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.default=void 0;var e=immunize(function(e){for(var r=[],t="\n",n=arguments.length,i=new Array(n>1?n-1:0),s=1;s<n;s++)i[s-1]=arguments[s];for(var u=0,a=i.length;u<a;u++){var o=e[u];0===u&&o[0].startsWith("\n")&&(o=o.slice(1));var f=o.lastIndexOf("\n");if(f>=0){t="\n";for(var l=o.length-f;l>0;l--)t+=" "}r.push(o),String(i[u]).split("\n").forEach(function(e,n){0!==n&&r.push(t),r.push(e)})}return r.push(e[i.length]),r.join("")}),r=immunize(e);exports.default=r;
},{}],"QgFk":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.default=void 0;var n=r(require("./indent.mjs"));function r(n){return n&&n.__esModule?n:{default:n}}function t(){var n=H(["reparsedPegAst does not match src/boot-pegast.mjs.ts"]);return t=function(){return n},n}function e(){var n=H(["// boot-pegast.mjs.ts - AUTOMATICALLY GENERATED by boot-peg.mjs.ts\nexport default ",";"],["// boot-pegast.mjs.ts - AUTOMATICALLY GENERATED by boot-peg.mjs.ts\\nexport default ",";"]);return e=function(){return n},n}function u(){var n=H(["Cannot curry baseParserCreator"]);return u=function(){return n},n}function o(n){return(o="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(n){return typeof n}:function(n){return n&&"function"==typeof Symbol&&n.constructor===Symbol&&n!==Symbol.prototype?"symbol":typeof n})(n)}function i(){var n=H(["",": ",""]);return i=function(){return n},n}function a(){var n=H(["Unrecognized tag flag ",""]);return a=function(){return n},n}function f(n){return l(n)||s(n)||c()}function c(){throw new TypeError("Invalid attempt to spread non-iterable instance")}function s(n){if(Symbol.iterator in Object(n)||"[object Arguments]"===Object.prototype.toString.call(n))return Array.from(n)}function l(n){if(Array.isArray(n)){for(var r=0,t=new Array(n.length);r<n.length;r++)t[r]=n[r];return t}}function v(){var n=H(["Cannot find "," in vtable"]);return v=function(){return n},n}function p(){var n=H(["\n    "," = pos;\n    ","\n    value = (value === FAIL) ? SKIP : FAIL;\n    pos = ",";"]);return p=function(){return n},n}function y(){var n=H(["\n    "," = pos;\n    ","\n    if (value !== FAIL) {\n        value = SKIP;\n    }\n    pos = ",";"]);return y=function(){return n},n}function m(){var n=H(["\n    [pos, value] = EAT(self, pos, ",");\n    "]);return m=function(){return n},n}function g(){var n=H(["\n    [pos, value] = EAT(self, pos);\n                "]);return g=function(){return n},n}function d(){var n=H(["\n    [pos, value] = EAT(self, pos);\n    if (value !== FAIL) {\n        value = ",".indexOf(value) "," 0 ? FAIL : value;\n    }\n                "]);return d=function(){return n},n}function A(){var n=H(["\n    if (beginPos !== undefined) {\n        yytext = '';\n        while (beginPos < pos) {\n            [beginPos, value] = EAT(self, beginPos);\n            if (value === FAIL) {\n                break;\n            }\n            yytext += value;\n        }\n        beginPos = undefined;\n        value = [];\n    }"]);return A=function(){return n},n}function b(){var n=H(["\n    ","\n    if (value.length === 0) value = FAIL;"]);return b=function(){return n},n}function h(){var n=H(["\n    "," = [];\n    "," = pos;\n    "," = SKIP;\n    while (true) {\n      "," = pos;\n      ","\n      if (value === FAIL) {\n        pos = ",";\n        break;\n      }\n      if ("," !== SKIP) ",".push(",");\n      if (value !== SKIP) ",".push(value);\n      "," = pos;\n      ","\n      if (value === FAIL) break;\n      "," = value;\n      if (pos === ",") break;\n    }\n    value = ",";"]);return h=function(){return n},n}function I(){var n=H(["\n    "," = pos;\n    ","\n    if (value !== FAIL) {\n        value = act_","(...value);\n        if (Array.isArray(value)) {\n            value = [...value];\n            value._pegPosition = makeTokStr(self, FIND(self.template, ","));\n        }\n    }"]);return I=function(){return n},n}function S(){var n=H(["\n    ","\n    if (value !== FAIL && value.length === 1) value = value[0];"]);return S=function(){return n},n}function E(){var n=H(["\n    "," = [];\n    "," = FAIL;\n    "," = pos;\n    ",": {\n      let beginPos, yytext;\n      ","\n      if (yytext !== undefined) {\n          "," = [yytext];\n      }\n      else {\n        "," = ",";\n      }\n    }\n    if ((value = ",") === FAIL) pos = ",";"]);return E=function(){return n},n}function _(){var n=H(["\n    ","\n    if (value === FAIL) break ",";\n    if (value !== SKIP) ",".push(value);"]);return _=function(){return n},n}function x(){var n=H(["\n    ",": {\n      ","\n    }"]);return x=function(){return n},n}function L(){var n=H(["\n    ","\n    if (value !== FAIL) break ",";"]);return L=function(){return n},n}function O(){var n=H(["\n    rule_",": (self, pos) => {\n      ","\n      ","\n      return [pos, value];\n    },"]);return O=function(){return n},n}function P(){var n=H(["\n    (function(",") {\n      let myHits = 0, myMisses = 0;\n      return baseMemo => (template, debug) => {\n          const BaseParser = baseMemo({});\n          return {...BaseParser,\n        template,\n        _memo: makeMap(),\n        _hits: (i) => myHits += i,\n        _misses: (i) => myMisses += i,\n        _debug: debug,\n        start: (self) => {\n          const pair = RUN(self, self.rule_",", 0, ",");\n          if (pair[1] === FAIL) {\n            ERROR(self, pair[0]);\n          }\n          return pair[1];\n        },\n        done: DONE,\n        ","\n    }};\n    })\n    "]);return P=function(){return n},n}function F(){var n=H(["Invalid hexadecimal number ",""]);return F=function(){return n},n}function w(){var n=H(["","(",") => [",", ","]"]);return w=function(){return n},n}function C(){var n=H(["","(",") => left recursion detector"]);return C=function(){return n},n}function k(){var n=H(["@"," => FAIL [","]"]);return k=function(){return n},n}function T(){var n=H(["hits: ",", misses: ",""]);return T=function(){return n},n}function N(){var n=H(["Syntax error ",""]);return N=function(){return n},n}function z(){var n=H(["-------template--------\n    ","\n    -------\n    ",""]);return z=function(){return n},n}function j(n,r){return M(n)||K(n,r)||R()}function R(){throw new TypeError("Invalid attempt to destructure non-iterable instance")}function K(n,r){var t=[],e=!0,u=!1,o=void 0;try{for(var i,a=n[Symbol.iterator]();!(e=(i=a.next()).done)&&(t.push(i.value),!r||t.length!==r);e=!0);}catch(f){u=!0,o=f}finally{try{e||null==a.return||a.return()}finally{if(u)throw o}}return t}function M(n){if(Array.isArray(n))return n}function J(){var n=H(["Rule missing: ",""]);return J=function(){return n},n}function U(){var n=H(["Left recursion on rule: ",""]);return U=function(){return n},n}function D(){var n=H(["run(f, ",", ",")"]);return D=function(){return n},n}function H(n,r){return r||(r=n.slice(0)),Object.freeze(Object.defineProperties(n,{raw:{value:Object.freeze(r)}}))}var q=immunize(n.default),B=immunize({toString:function(){return"LEFT_RECUR"}}),G=immunize(function(n,r,t,e){n._debug&&slog.info(D(),t,e);var u=n._memo.get(t);u||(u=makeMap(),n._memo.set(t,u));var o=u.get(r);return o?(o===B&&slog.error(U(),{name:e}),n._hits(1)):(u.set(r,B),n._misses(1),"function"==typeof r?o=r(n,t):void 0===r?slog.error(J(),e):o=$(n,t,r),u.set(r,o)),o}),W=immunize(function(n){var r=0,t=[],e=!0,u=!1,o=void 0;try{for(var i,a=n._memo[Symbol.iterator]();!(e=(i=a.next()).done);e=!0){var f=i.value[1],c=!0,s=!1,l=void 0;try{for(var v,p=f[Symbol.iterator]();!(c=(v=p.next()).done);c=!0){var y=j(v.value,2),m=y[0],g=y[1];if(g!==B){var d="function"==typeof m?m.name.slice(5):JSON.stringify(""+m),A=j(g,2),b=A[0];A[1]===rn&&(b>r?(r=b,t=[d]):b===r&&t.indexOf(d)<0&&t.push(d))}}}catch(h){s=!0,l=h}finally{try{c||null==p.return||p.return()}finally{if(s)throw l}}}}catch(h){u=!0,o=h}finally{try{e||null==a.return||a.return()}finally{if(u)throw o}}return[r,t]}),Y=immunize(function(n,r){var t=j(W(n),2),e=t[0],u=t[1],o=X(n.template,e),i=Array.isArray(o)?"at ".concat(e," ").concat(V(n,o)):"unexpected EOF after ".concat(V(n,X(n.template,e-1))),a=0===u.length?"stuck":"looking for ".concat(u.join(", ")),f=n.template.sources;slog.info(z(),n.template.raw.reduce(function(n,r,t){if(f){var e=f[t];n+="    ".concat(e.uri,":").concat(e.line,": ")}return n+=JSON.stringify(r).slice(0,50)+"\n"},""),a),slog.error(N(),i)}),V=immunize(function(n,r){if(Array.isArray(r)){var t=n.template[r[0]];return"".concat(JSON.stringify(t[r[1]])," #").concat(r[0],":").concat(r[1])}if("number"==typeof r)return"hole #".concat(r)}),Q=immunize(function(n){if(n._debug){var r=!0,t=!1,e=void 0;try{for(var u,o=n._memo[Symbol.iterator]();!(r=(u=o.next()).done);r=!0){var i=j(u.value,2),a=i[0],f=i[1],c=[],s=!0,l=!1,v=void 0;try{for(var p,y=f[Symbol.iterator]();!(s=(p=y.next()).done);s=!0){var m=j(p.value,2),g=m[0],d=m[1],A="function"==typeof g?g.name:JSON.stringify(g);if(d===B)slog.notice(C(),A,a);else{var b=j(d,2),h=b[0],I=b[1];I===rn?c.push(A):slog.debug(w(),A,a,h,I)}}}catch(S){l=!0,v=S}finally{try{s||null==y.return||y.return()}finally{if(l)throw v}}c.length>=1&&slog.debug(k(),a,c)}}catch(S){t=!0,e=S}finally{try{r||null==o.return||o.return()}finally{if(t)throw e}}slog.info(T(),n._hits(0),n._misses(0))}}),X=immunize(function(n,r){for(var t=n.raw,e=t.length-1,u=r,o=0;o<=e;o++){var i=t[o].length;if(u<i)return[o,u];if(u===i&&o<e)return o;u-=i+1}}),Z=immunize(function(n,r){return[r,[]]}),$=immunize(function(n,r,t){var e=X(n.template,r);if(Array.isArray(e)){var u=n.template.raw[e[0]];if("string"!=typeof t)return[r+1,u[e[1]]];if(u.startsWith(t,e[1]))return[r+t.length,t]}return[r,rn]}),nn=immunize(function(n,r){var t=X(n.template,r);return"number"==typeof t?[r+1,t]:[r,rn]}),rn=immunize({toString:function(){return"FAIL"}}),tn=immunize({toString:function(){return"SKIP"}}),en="0123456789abcdef",un="ABCDEF",on=immunize(function(n){var r=en.indexOf(n);return r<0&&(r=un.indexOf(n)+10),r<0&&slog.error(F(),{c:n}),r}),an=immunize(function(n){if("\\"!==n[0])return[n[0],1];var r=n[1];switch(r){case"b":r="\b";break;case"f":r="\f";break;case"n":r="\n";break;case"r":r="\r";break;case"t":r="\t";break;case"x":var t=16*on(n[2])+on(n[3]);return[r=String.fromCharCode(t),4]}return[r,2]}),fn=immunize(function(n,r){function c(n){var r=0,t=0,e=["let value = FAIL"];function u(n){var r="".concat(n,"_").concat(t++);return e.push(r),r}function o(n){return"".concat(n,"_").concat(t++)}var i={peg:function(){for(var n=arguments.length,t=new Array(n),e=0;e<n;e++)t[e]=arguments[e];for(var u=t.map(a).join("\n"),o=[],i=0;i<r;i++)o.push("act_".concat(i));var f=t[0][1];return q(P(),o.join(", "),f,JSON.stringify(f),u)},def:function(n,r){var t,u=a(r);return q(O(),n,(t="".concat(e.join(", "),";"),e.length=1,t),u)},empty:function(){return"value = SKIP;"},fail:function(){return"value = FAIL;"},or:function(){for(var n=o("or"),r=arguments.length,t=new Array(r),e=0;e<r;e++)t[e]=arguments[e];var u=t.map(a).map(function(r){return q(L(),r,n)}).join("\n");return q(x(),n,u)},seq:function(){for(var n=u("pos"),r=o("seq"),t=u("s"),e=u("v"),i=arguments.length,f=new Array(i),c=0;c<i;c++)f[c]=arguments[c];var s=f.map(a).map(function(n){return q(_(),n,r,t)}).join("\n");return q(E(),t,e,n,r,s,e,e,t,e,n)},pred:function(n){return r=Math.max(r,n+1),"[pos, value] = act_".concat(n,"(self, pos);")},val0:function(){var n=i.seq.apply(i,arguments);return q(S(),n)},act:function(n){var t=u("pos");r=Math.max(r,n+1);for(var e=arguments.length,o=new Array(e>1?e-1:0),a=1;a<e;a++)o[a-1]=arguments[a];var f=i.seq.apply(i,o);return q(I(),t,f,n,t)},"**":function(n,r){var t=u("pos"),e=u("pos"),o=u("s"),i=a(n),f=a(r),c=u("sepVal");return q(h(),o,t,c,e,i,t,c,o,c,o,t,f,c,e,o)},"++":function(n,r){var t=i["**"](n,r);return q(b(),t)},"?":function(n){return i["**"](n,["fail"])},"*":function(n){return i["**"](n,["empty"])},"+":function(n){return i["++"](n,["empty"])},super:function(n){return"[pos, value] = RUN(self, BaseParser.rule_".concat(n,", pos, ").concat(JSON.stringify("super.".concat(n)),");")},begin:function(){return"beginPos = pos; value = [];"},end:function(){return q(A())},cls:function(n){var r="",t=0,e="^"===n[t];for(e&&++t;t<n.length;){var u=j(an(n.slice(t)),2),o=u[0];if("-"===n[t+=u[1]]){++t;var i=j(an(n.slice(t)),2),a=i[0];t+=i[1];for(var f=o.charCodeAt(0),c=a.charCodeAt(0),s=f;s<=c;s++)r+=String.fromCharCode(s)}else r+=o}var l=e?">=":"<",v=JSON.stringify(r);return q(d(),v,l)},dot:function(){return q(g())},lit:function(n){for(var r="",t=0;t<n.length;){var e=j(an(n.slice(t)),2),u=e[0];t+=e[1],r+=u}return q(m(),JSON.stringify(r))},peek:function(n){var r=u("pos"),t=a(n);return q(y(),r,t,r)},peekNot:function(n){var r=u("pos"),t=a(n);return q(p(),r,t,r)}};function a(n){if("string"==typeof n){var r=JSON.stringify(n);return"[pos, value] = RUN(self, self.rule_".concat(n,", pos, ").concat(r,");")}var t=i[n[0]];return t||slog.error(v(),n[0]),t.apply(void 0,f(n.slice(1)))}return a(n)}function s(n){return function(n,r){var t=makeWeakMap(),e=!1,u=function r(u){if("string"==typeof u){switch(u){case"DEBUG":e=!0;break;default:throw slog.error(a(),{templateOrFlag:u})}return r}var f=u,c=t.get(f);c||(c=n(f,e),t.set(f,c)),"function"!=typeof c&&slog.error(i(),o(c),c);for(var s=arguments.length,l=new Array(s>1?s-1:0),v=1;v<s;v++)l[v-1]=arguments[v];return c.apply(void 0,l)};return u.parserCreator=r,u}(function(r,t){var e=n(r,t);void 0===e&&slog.error(u());var o=null;try{o=e.start(e)}finally{e.done(e)}return o},n)}var l=s(function(n){});function F(n){var r=c(["peg"].concat(f(n))),t=confine(r,{DONE:Q,EAT:$,ERROR:Y,FAIL:rn,FIND:X,RUN:G,SKIP:tn,makeTokStr:V});return function(){var n,r,e=t.apply(void 0,arguments),u=function t(e){function u(u){var o=[];function i(n){if("string"==typeof n)return o.push(n),i;for(var t=arguments.length,u=new Array(t>1?t-1:0),a=1;a<t;a++)u[a-1]=arguments[a];var f=r.apply(void 0,[n].concat(u))._asExtending(e);return o.reduce(function(n,r){return n(r)},f)}if(i.ACCEPT=Z,i.EAT=$,i.FAIL=rn,i.HOLE=nn,i.SKIP=tn,i._asExtending=n,i.extends=t,i.parserCreator=r.parserCreator,"string"==typeof u)return i(u);for(var a=arguments.length,f=new Array(a>1?a-1:0),c=1;c<a;c++)f[c-1]=arguments[c];return i.apply(void 0,[u].concat(f))}return u.ACCEPT=Z,u.EAT=$,u.FAIL=rn,u.HOLE=nn,u.SKIP=tn,u._asExtending=n,u.extends=t,u.parserCreator=r.parserCreator,u};n=function(r){var t=s(e(r.parserCreator));return t.ACCEPT=Z,t.EAT=$,t.FAIL=rn,t.HOLE=nn,t.SKIP=tn,t._asExtending=n,t.extends=u,t},l._asExtending=n;var o=l;return o._asExtending=n,r=n(o)}}var w=function(n){for(var r=arguments.length,t=new Array(r>1?r-1:0),e=1;e<r;e++)t[e-1]=arguments[e];return t};w.ACCEPT=Z,w.HOLE=nn,w.SKIP=tn;var C=n(w,F),k=F(r).apply(void 0,f(C)),T=n(k,function(n){return function(){return n}}),N=n(T,void 0),z=JSON.stringify(r,void 0,"  "),R=JSON.stringify(N,void 0,"  ");return z!==R&&(slog.info(e(),{b:R}),slog.panic(t())),n(k,F)}),cn=immunize(fn);exports.default=cn;
},{"./indent.mjs":"cE9W"}],"joiS":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.default=void 0;var a=immunize([["def","Grammar",["act",0,"_Spacing",["+","Definition"],"_EndOfFile"]],["def","Definition",["act",2,"Identifier","LEFTARROW","Expression","SEMI",["pred",1]]],["def","Expression",["act",3,["**","Sequence","_SLASH"]]],["def","Sequence",["act",5,["act",4,["*","Prefix"]],["?","HOLE"]]],["def","Prefix",["or",["act",6,"AND","HOLE"],["act",7,"AND","Suffix"],["act",8,"NOT","Suffix"],["val0","Suffix"]]],["def","Suffix",["or",["act",9,"Primary",["or",["val0","STARSTAR"],["val0","PLUSPLUS"]],"Primary"],["act",10,"Primary",["or",["val0","QUESTION"],["val0","STAR"],["val0","PLUS"]]],["val0","Primary"]]],["def","Primary",["or",["val0","Super"],["val0","Identifier",["peekNot","LEFTARROW"]],["act",11,"OPEN","Expression","CLOSE"],["act",12,"Literal"],["act",13,"Class"],["act",14,"DOT"],["act",15,"BEGIN"],["act",16,"END"]]],["def","Super",["act",17,["lit","super."],"Identifier"]],["def","Identifier",["val0",["begin"],"IdentStart",["*","IdentCont"],["end"],"_Spacing"]],["def","IdentStart",["val0",["cls","a-zA-Z_"]]],["def","IdentCont",["or",["val0","IdentStart"],["val0",["cls","0-9"]]]],["def","Literal",["or",["val0",["cls","'"],["begin"],["*",["val0",["peekNot",["cls","'"]],"Char"]],["end"],["cls","'"],"_Spacing"],["val0",["cls",'"'],["begin"],["*",["val0",["peekNot",["cls",'"']],"Char"]],["end"],["cls",'"'],"_Spacing"]]],["def","Class",["val0",["lit","["],["begin"],["*",["val0",["peekNot",["lit","]"]],"Range"]],["end"],["lit","]"],"_Spacing"]],["def","Range",["or",["val0","Char",["lit","-"],"Char"],["val0","Char"]]],["def","Char",["or",["val0",["lit","\\\\"],["cls","abefnrtv'\"\\[\\]\\\\\\`\\$"]],["val0",["lit","\\\\x"],["cls","0-9a-fA-F"],["cls","0-9a-fA-F"]],["val0",["lit","\\\\"],["lit","-"]],["val0",["peekNot",["lit","\\\\"]],["dot"]]]],["def","LEFTARROW",["val0",["lit","<-"],"_Spacing"]],["def","_SLASH",["act",18,["lit","/"],"_Spacing"]],["def","SEMI",["val0",["lit",";"],"_Spacing"]],["def","AND",["val0",["lit","&"],"_Spacing"]],["def","NOT",["val0",["lit","~"],"_Spacing"]],["def","QUESTION",["val0",["lit","?"],"_Spacing"]],["def","STAR",["val0",["lit","*"],"_Spacing"]],["def","PLUS",["val0",["lit","+"],"_Spacing"]],["def","OPEN",["val0",["lit","("],"_Spacing"]],["def","CLOSE",["val0",["lit",")"],"_Spacing"]],["def","DOT",["val0",["lit","."],"_Spacing"]],["def","_Spacing",["act",19,["*",["or",["val0","Space"],["val0","Comment"]]]]],["def","Comment",["val0",["lit","#"],["*",["val0",["peekNot","EndOfLine"],["dot"]]],"EndOfLine"]],["def","Space",["or",["val0",["lit"," "]],["val0",["lit","\\t"]],["val0","EndOfLine"]]],["def","EndOfLine",["or",["val0",["lit","\\r\\n"]],["val0",["lit","\\n"]],["val0",["lit","\\r"]]]],["def","_EndOfFile",["val0",["peekNot",["dot"]]]],["def","HOLE",["val0",["pred",20],"_Spacing"]],["def","BEGIN",["val0",["lit","<"],"_Spacing"]],["def","END",["val0",["lit",">"],"_Spacing"]],["def","PLUSPLUS",["val0",["lit","++"],"_Spacing"]],["def","STARSTAR",["val0",["lit","**"],"_Spacing"]]]);exports.default=a;
},{}],"3zTw":[function(require,module,exports) {
"use strict";function n(){var e=r(["\n# Hierarchical syntax\n\nGrammar      <- _Spacing Definition+ _EndOfFile\n                    ",";\n\nDefinition   <- Identifier LEFTARROW Expression SEMI &","\n                    ",";\nExpression   <- Sequence ** _SLASH\n                    ",";\nSequence     <- (Prefix*\n                    ",")\n                 HOLE?\n                    ",";\nPrefix       <- AND HOLE\n                    ","\n              / AND Suffix\n                    ","\n              / NOT Suffix\n                    ","\n              /     Suffix;\nSuffix       <- Primary (STARSTAR\n                        / PLUSPLUS) Primary\n                    ","\n              / Primary (QUESTION\n                        / STAR\n                        / PLUS)\n                    ","\n              / Primary;\nPrimary      <- Super\n              / Identifier ~LEFTARROW\n              / OPEN Expression CLOSE\n                    ","\n              / Literal\n                    ","\n              / Class\n                    ","\n              / DOT\n                    ","\n              / BEGIN\n                    ","\n              / END\n                    ","\n              ;\n\nSuper        <- 'super.' Identifier\n                    ",";\n\n# Lexical syntax\n\nIdentifier   <- < IdentStart IdentCont* > _Spacing;\nIdentStart   <- [a-zA-Z_];\nIdentCont    <- IdentStart / [0-9];\nLiteral      <- ['] < (~['] Char )* > ['] _Spacing\n              / [\"] < (~[\"] Char )* > [\"] _Spacing;\nClass        <- '[' < (~']' Range)* > ']' _Spacing;\nRange        <- Char '-' Char / Char;\nChar         <- '\\' [abefnrtv'\"[]\\`$]\n              / '\\x' [0-9a-fA-F][0-9a-fA-F]\n              / '\\' '-'\n              / ~'\\' .;\nLEFTARROW    <- '<-' _Spacing;\n_SLASH        <- '/' _Spacing              ",";\nSEMI         <- ';' _Spacing;\nAND          <- '&' _Spacing;\nNOT          <- '~' _Spacing;\nQUESTION     <- '?' _Spacing;\nSTAR         <- '*' _Spacing;\nPLUS         <- '+' _Spacing;\nOPEN         <- '(' _Spacing;\nCLOSE        <- ')' _Spacing;\nDOT          <- '.' _Spacing;\n_Spacing      <- (Space / Comment)*        ",";\nComment      <- '#' (~EndOfLine .)* EndOfLine;\nSpace        <- ' ' / '\t' / EndOfLine;\nEndOfLine    <- '\r\n' / '\n' / '\r';\n_EndOfFile    <- ~.;\n\nHOLE         <- &"," _Spacing;\nBEGIN        <- '<' _Spacing;\nEND          <- '>' _Spacing;\nPLUSPLUS     <- '++' _Spacing;\nSTARSTAR     <- '**' _Spacing;\n"],["\n# Hierarchical syntax\n\nGrammar      <- _Spacing Definition+ _EndOfFile\n                    ",";\n\nDefinition   <- Identifier LEFTARROW Expression SEMI &","\n                    ",";\nExpression   <- Sequence ** _SLASH\n                    ",";\nSequence     <- (Prefix*\n                    ",")\n                 HOLE?\n                    ",";\nPrefix       <- AND HOLE\n                    ","\n              / AND Suffix\n                    ","\n              / NOT Suffix\n                    ","\n              /     Suffix;\nSuffix       <- Primary (STARSTAR\n                        / PLUSPLUS) Primary\n                    ","\n              / Primary (QUESTION\n                        / STAR\n                        / PLUS)\n                    ","\n              / Primary;\nPrimary      <- Super\n              / Identifier ~LEFTARROW\n              / OPEN Expression CLOSE\n                    ","\n              / Literal\n                    ","\n              / Class\n                    ","\n              / DOT\n                    ","\n              / BEGIN\n                    ","\n              / END\n                    ","\n              ;\n\nSuper        <- 'super.' Identifier\n                    ",";\n\n# Lexical syntax\n\nIdentifier   <- < IdentStart IdentCont* > _Spacing;\nIdentStart   <- [a-zA-Z_];\nIdentCont    <- IdentStart / [0-9];\nLiteral      <- ['] < (~['] Char )* > ['] _Spacing\n              / [\"] < (~[\"] Char )* > [\"] _Spacing;\nClass        <- '[' < (~']' Range)* > ']' _Spacing;\nRange        <- Char '-' Char / Char;\nChar         <- '\\\\' [abefnrtv'\"\\[\\]\\\\\\`\\$]\n              / '\\\\x' [0-9a-fA-F][0-9a-fA-F]\n              / '\\\\' '-'\n              / ~'\\\\' .;\nLEFTARROW    <- '<-' _Spacing;\n_SLASH        <- '/' _Spacing              ",";\nSEMI         <- ';' _Spacing;\nAND          <- '&' _Spacing;\nNOT          <- '~' _Spacing;\nQUESTION     <- '?' _Spacing;\nSTAR         <- '*' _Spacing;\nPLUS         <- '+' _Spacing;\nOPEN         <- '(' _Spacing;\nCLOSE        <- ')' _Spacing;\nDOT          <- '.' _Spacing;\n_Spacing      <- (Space / Comment)*        ",";\nComment      <- '#' (~EndOfLine .)* EndOfLine;\nSpace        <- ' ' / '\\t' / EndOfLine;\nEndOfLine    <- '\\r\\n' / '\\n' / '\\r';\n_EndOfFile    <- ~.;\n\nHOLE         <- &"," _Spacing;\nBEGIN        <- '<' _Spacing;\nEND          <- '>' _Spacing;\nPLUSPLUS     <- '++' _Spacing;\nSTARSTAR     <- '**' _Spacing;\n"]);return n=function(){return e},e}function r(n,r){return r||(r=n.slice(0)),Object.freeze(Object.defineProperties(n,{raw:{value:Object.freeze(r)}}))}function e(n){return t(n)||c(n)||i()}function i(){throw new TypeError("Invalid attempt to destructure non-iterable instance")}function t(n){if(Array.isArray(n))return n}function a(n){return u(n)||c(n)||S()}function S(){throw new TypeError("Invalid attempt to spread non-iterable instance")}function c(n){if(Symbol.iterator in Object(n)||"[object Arguments]"===Object.prototype.toString.call(n))return Array.from(n)}function u(n){if(Array.isArray(n)){for(var r=0,e=new Array(n.length);r<n.length;r++)e[r]=n[r];return e}}Object.defineProperty(exports,"__esModule",{value:!0}),exports.default=void 0;var f=immunize(function(r,i){var t=r.ACCEPT,S=r.HOLE,c=r.SKIP;function u(n,r){return 0===r.length?["empty"]:1===r.length?r[0]:[n].concat(a(r))}function f(n){return n.reduce(function(n,r){return n.push.apply(n,a(o(r))),n},[])}function o(n){if(Array.isArray(n)){if(0===n.length)return[];var r=e(n),i=r[0],t=r.slice(1);return"seq"===i?f(t):0===t.length&&Array.isArray(i)?o(i):[[i].concat(a(f(t)))]}return[n]}return r(n(),i,t,function(n,r,e,i){return["def",n,e]},function(n){return u("or",n)},function(n){return u("seq",n)},function(n,r){return 0===r.length?["val0"].concat(a(o(n))):["act",r[0]].concat(a(o(n)))},function(n,r){return["pred",r]},function(n,r){return["peek",r]},function(n,r){return["peekNot",r]},function(n,r,e){return[r,n,e]},function(n,r){return[r[0],n]},function(n,r,e){return r},function(n){return["lit",n]},function(n){return["cls",n]},function(){return["dot"]},function(){return["begin"]},function(){return["end"]},function(n,r){return["super",r]},function(n){return c},function(n){return c},S)}),o=immunize(f);exports.default=o;
},{}],"NMVp":[function(require,module,exports) {
"use strict";function n(){var r=a(["\n    # Jump to the expr production.\n    start <- _WS expr _EOF              ",";\n    "]);return n=function(){return r},r}function r(n){return o(n)||t(n)||e()}function e(){throw new TypeError("Invalid attempt to spread non-iterable instance")}function t(n){if(Symbol.iterator in Object(n)||"[object Arguments]"===Object.prototype.toString.call(n))return Array.from(n)}function o(n){if(Array.isArray(n)){for(var r=0,e=new Array(n.length);r<n.length;r++)e[r]=n[r];return e}}function i(){var n=a(["\n    # Override rather than inherit start production.\n    # Only module syntax is permitted.\n    start <- _WS moduleBody _EOF               ",';\n\n    # A.1 Lexical Grammar\n\n    # For proposed eventual send expressions\n    LATER <- _NO_NEWLINE "!" _WS;\n\n    # A.2 Expressions\n\n    # Jessie primaryExpr does not include "this", ClassExpression,\n    # GeneratorExpression, AsyncFunctionExpression,\n    # AsyncGenerarorExpression, or RegularExpressionLiteral.\n    primaryExpr <-\n      super.primaryExpr\n    / functionExpr;\n\n    propDef <-\n      methodDef\n    / super.propDef;\n\n    purePropDef <-\n      methodDef\n    / super.purePropDef;\n\n    # Recognize pre-increment/decrement.\n    prePre <-\n      (PLUSPLUS / MINUSMINUS)                          ',"\n    / super.prePre;\n\n    # Extend to recognize proposed eventual get syntax,\n    # as well as computed indices and postfix increment/decrement.\n    memberPostOp <-\n      super.memberPostOp\n    / LEFT_BRACKET assignExpr RIGHT_BRACKET        ","\n    / LATER LEFT_BRACKET assignExpr RIGHT_BRACKET  ","\n    / LATER IDENT_NAME                             ",";\n\n    # Extend to recognize proposed eventual send syntax.\n    # We distinguish b!foo(x) from calling b!foo by a post-parsing pass\n    callPostOp <-\n      super.callPostOp\n    / LATER args                                           ",";\n\n    postOp <- (PLUSPLUS / MINUSMINUS) _WS;\n\n    # to be extended\n    assignExpr <-\n      arrowFunc\n    / functionExpr\n    / lValue postOp                                        ","\n    / lValue (EQUALS / assignOp) assignExpr                ","\n    / super.assignExpr\n    / primaryExpr;\n\n    # An expression without side-effects.\n    pureExpr <-\n      arrowFunc\n    / super.pureExpr;\n\n    # In Jessie, an lValue is only a variable, a computed index-named\n    # property (an array element), or a statically string-named\n    # property.\n    # We allow assignment to statically string-named fields, since it\n    # is useful during initialization and prevented thereafter by\n    # mandatory tamper-proofing.\n\n    # to be overridden or extended\n    lValue <-\n      primaryExpr LEFT_BRACKET indexExpr RIGHT_BRACKET     ","\n    / primaryExpr LATER LEFT_BRACKET indexExpr RIGHT_BRACKET ","\n    / primaryExpr DOT IDENT_NAME                           ","\n    / primaryExpr LATER IDENT_NAME                         ",'\n    / useVar;\n\n    assignOp <-\n      ("*=" / "/=" / "%=" / "+=" / "-="\n    / "<<=" / ">>=" / ">>>="\n    / "&=" / "^=" / "|="\n    / "**=") _WS;\n\n\n    # A.3 Statements\n\n    # to be extended.\n    # The exprStatement production must go last, so PEG\'s prioritized\n    # choice will interpret {} as a block rather than an expression.\n    statement <-\n      block\n    / IF LEFT_PAREN expr RIGHT_PAREN arm ELSE elseArm      ',"\n    / IF LEFT_PAREN expr RIGHT_PAREN arm                   ","\n    / breakableStatement\n    / terminator\n    / IDENT COLON statement                                ","\n    / TRY block catcher finalizer                          ","\n    / TRY block catcher                                    ","\n    / TRY block finalizer                                  ","\n    / DEBUGGER SEMI                                        ","\n    / exprStatement;\n\n    # to be overridden.  In Jessie, only blocks are accepted as arms\n    # of flow-of-control statements.\n    arm <- block;\n\n    # Allows for\n    # if (...) {} else if (...) {} else if (...) {};\n    elseArm <-\n      arm\n    / IF LEFT_PAREN expr RIGHT_PAREN arm ELSE elseArm      ","\n    / IF LEFT_PAREN expr RIGHT_PAREN arm                   ",";\n\n    breakableStatement <-\n      FOR LEFT_PAREN declOp forOfBinding OF expr RIGHT_PAREN arm\n            ","\n    / FOR LEFT_PAREN declaration expr? SEMI expr? RIGHT_PAREN arm ","\n    / WHILE LEFT_PAREN expr RIGHT_PAREN arm                       ","\n    / SWITCH LEFT_PAREN expr RIGHT_PAREN LEFT_BRACE clause* RIGHT_BRACE\n            ",';\n\n    # Each case clause must end in a terminating statement.\n    terminator <-\n      "continue" _NO_NEWLINE IDENT SEMI                ','\n    / "continue" _WS SEMI                              ','\n    / "break" _NO_NEWLINE IDENT SEMI                   ','\n    / "break" _WS SEMI                                 ','\n    / "return" _NO_NEWLINE expr SEMI                   ','\n    / "return" _WS SEMI                                ','\n    / "throw" _NO_NEWLINE expr SEMI                    ',";\n\n    block <- LEFT_BRACE body RIGHT_BRACE              ",';\n    body <- statementItem*;\n\n    # declaration must come first, so that PEG will prioritize\n    # function declarations over exprStatement.\n    statementItem <-\n      declaration\n    / statement;\n\n    # No "class" declaration.\n    # No generator, async, or async iterator function.\n    declaration <-\n      declOp binding ** _COMMA SEMI                    ','\n    / functionDecl;\n\n    declOp <- ("const" / "let") _WSN;\n\n    forOfBinding <- bindingPattern / defVar;\n    binding <-\n      bindingPattern EQUALS assignExpr                ',"\n    / defVar EQUALS assignExpr                        ","\n    / defVar;\n\n    bindingPattern <-\n      LEFT_BRACKET elementParam ** _COMMA RIGHT_BRACKET     ","\n    / LEFT_BRACE propParam ** _COMMA RIGHT_BRACE            ",";\n\n    pattern <-\n      bindingPattern\n    / defVar\n    / dataLiteral                                     ","\n    / HOLE                                            ",";\n\n    # to be overridden\n    elementParam <- param;\n\n    param <-\n      ELLIPSIS pattern                                ","\n    / defVar EQUALS assignExpr                        ","\n    / pattern;\n\n    propParam <-\n      ELLIPSIS pattern                                ","\n    / propName COLON pattern                          ","\n    / defVar EQUALS assignExpr                        ","\n    / defVar                                          ",";\n\n    # Use PEG prioritized choice.\n    # TODO emit diagnostic for failure cases.\n    exprStatement <-\n      ~cantStartExprStatement expr SEMI               ",';\n\n    cantStartExprStatement <-\n      ("{" / "function" / "async" _NO_NEWLINE "function"\n    / "class" / "let" / "[") _WSN;\n\n    # to be overridden\n    terminatedBody <- ((~terminator statementItem)* terminator)+   ',";\n    clause <-\n      caseLabel+ LEFT_BRACE terminatedBody RIGHT_BRACE ",";\n    caseLabel <-\n      CASE expr COLON                                 ","\n    / DEFAULT _WS COLON                                ",";\n\n    catcher <- CATCH LEFT_PAREN pattern RIGHT_PAREN block ",";\n    finalizer <- FINALLY block                        ",";\n\n\n    # A.4 Functions and Classes\n\n    functionDecl <-\n      FUNCTION defVar LEFT_PAREN param ** _COMMA RIGHT_PAREN block\n                                                      ",";\n\n    functionExpr <-\n      FUNCTION defVar? LEFT_PAREN param ** _COMMA RIGHT_PAREN block\n                                                      ",";\n\n    # The assignExpr form must come after the block form, to make proper use\n    # of PEG prioritized choice.\n    arrowFunc <-\n      arrowParams _NO_NEWLINE ARROW block              ","\n    / arrowParams _NO_NEWLINE ARROW assignExpr         ",";\n\n    arrowParams <-\n      IDENT                                           ","\n    / LEFT_PAREN param ** _COMMA RIGHT_PAREN           ",";\n\n    # to be extended\n    methodDef <-\n      method\n    / GET propName LEFT_PAREN RIGHT_PAREN block            ","\n    / SET propName LEFT_PAREN param RIGHT_PAREN block      ",";\n\n    method <-\n      propName LEFT_PAREN param ** _COMMA RIGHT_PAREN block ",";\n\n\n    # A.5 Scripts and Modules\n\n    moduleBody <- moduleItem*;\n    moduleItem <-\n      SEMI                                               ","\n    / importDecl\n    / exportDecl\n    / moduleDeclaration;\n\n    useImport <- IMPORT_PFX IDENT                 ",";\n    defImport <- IMPORT_PFX IDENT                 ",';\n\n    moduleDeclaration <-\n      "const" _WSN moduleBinding ** _COMMA SEMI       ',";\n\n    # An immunized expression without side-effects.\n    immunizedExpr <-\n      dataLiteral                                     ",'\n    / "immunize" _WS LEFT_PAREN (pureExpr / useImport) RIGHT_PAREN  ',";\n\n    # Jessie modules only allow immunized module-level bindings.\n    moduleBinding <-\n      bindingPattern EQUALS immunizedExpr       ","\n    / defVar EQUALS immunizedExpr               ","\n    / defVar;\n\n    importClause <-\n      defImport                                 ","\n    / STAR AS defImport                         ","\n    / namedImports                              ","\n    / defImport _COMMA STAR AS defImport        ","\n    / defImport _COMMA namedImports             ",";\n\n    importSpecifier <-\n      defImport                                 ","\n    / IDENT_NAME AS defImport                   ",";\n\n    namedImports <-\n      LEFT_BRACE importSpecifier ** _COMMA _COMMA? RIGHT_BRACE ",";\n\n    importDecl <- IMPORT importClause FROM STRING SEMI  ",";\n    exportDecl <-\n      EXPORT DEFAULT exportableExpr SEMI        ","\n    / EXPORT moduleDeclaration                  ",';\n\n    # to be extended\n    exportableExpr <- immunizedExpr;\n\n    # Lexical syntax\n    ARROW <- "=>" _WS;\n    AS <- "as" _WSN;\n    DEBUGGER <- "debugger" _WSN;\n    PLUSPLUS <- "++" _WSN;\n    MINUSMINUS <- "--" _WSN;\n    CASE <- "case" _WSN;\n    IF <- "if" _WSN;\n    ELSE <- "else" _WSN;\n    FOR <- "for" _WSN;\n    OF <- "of" _WSN;\n    WHILE <- "while" _WSN;\n    BREAK <- "break" _WSN;\n    CONTINUE <- "continue" _WSN;\n    SWITCH <- "switch" _WSN;\n    TRY <- "try" _WSN;\n    CATCH <- "catch" _WSN;\n    FINALLY <- "finally" _WSN;\n    GET <- "get" _WSN;\n    SET <- "set" _WSN;\n    IMPORT <- "import" _WSN;\n    EXPORT <- "export" _WSN;\n    FROM <- "from" _WSN;\n    FUNCTION <- "function" _WSN;\n    DEFAULT <- "default" _WSN;\n    EQUALS <- "=" _WS;\n    SEMI <- ";" _WS;\n    STAR <- "*" _WS;\n    ']);return i=function(){return n},n}function a(n,r){return r||(r=n.slice(0)),Object.freeze(Object.defineProperties(n,{raw:{value:Object.freeze(r)}}))}function u(n,r){return s(n)||p(n,r)||c()}function c(){throw new TypeError("Invalid attempt to destructure non-iterable instance")}function p(n,r){var e=[],t=!0,o=!1,i=void 0;try{for(var a,u=n[Symbol.iterator]();!(t=(a=u.next()).done)&&(e.push(a.value),!r||e.length!==r);t=!0);}catch(c){o=!0,i=c}finally{try{t||null==u.return||u.return()}finally{if(o)throw i}}return e}function s(n){if(Array.isArray(n))return n}Object.defineProperty(exports,"__esModule",{value:!0}),exports.default=void 0;var E=immunize(function(n){return["block",n.reduce(function(n,r){var e=u(r,2),t=e[0],o=e[1];return t.forEach(function(r){return n.push(r)}),n.push(o),n},[])]}),f=immunize(function(e,t){var o=t.SKIP,a=t(i(),function(n){return function(){return["module",n]}},function(n){return"pre:".concat(n)},function(n,r,e){return["index",r]},function(n,r,e,t){return["indexLater",e]},function(n,r){return["getLater",r]},function(n,r){return["callLater",r]},function(n,r){return[r,n]},function(n,r,e){return[r,n,e]},function(n,r,e,t){return["index",n,e]},function(n,r,e,t,o){return["indexLater",n,t]},function(n,r,e){return["get",n,e]},function(n,r,e){return["getLater",n,e]},function(n,r,e,t,o,i,a){return["if",e,o,a]},function(n,r,e,t,o){return["if",e,o]},function(n,r,e){return["label",n,e]},function(n,r,e,t){return["try",r,e,t]},function(n,r,e){return["try",r,e]},function(n,r,e){return["try",r,void 0,e]},function(n,r){return["debugger"]},function(n,r,e,t,o,i,a){return["if",e,o,a]},function(n,r,e,t,o){return["if",e,o]},function(n,r,e,t,o,i,a,u){return["forOf",e,t,i,u]},function(n,r,e,t,o,i,a,u){return["for",e,t,i,u]},function(n,r,e,t,o){return["while",e,o]},function(n,r,e,t,o,i,a){return["switch",e,i]},function(n,r,e){return["continue",r]},function(n,r){return["continue"]},function(n,r,e){return["break",r]},function(n,r){return["break"]},function(n,r,e){return["return",r]},function(n,r){return["return"]},function(n,r,e){return["throw",r]},function(n,r,e){return["block",r]},function(n,r,e){return[n,r]},function(n,r,e){return["bind",n,e]},function(n,r,e){return["bind",n,e]},function(n,r,e){return["matchArray",r]},function(n,r,e){return["matchRecord",r]},function(n){return["matchData",JSON.parse(n)]},function(n){return["patternHole",n]},function(n,r){return["rest",r]},function(n,r,e){return["optional",n,e]},function(n,r){return["restObj",r]},function(n,r,e){return["matchProp",n,e]},function(n,r,e){return["optionalProp",n[1],n,e]},function(n){return["matchProp",n[1],n]},function(n,r){return n},function(n){return E(n)},function(n,r,e,t){return["clause",n,e]},function(n,r){return["case",r]},function(n,r){return["default"]},function(n,r,e,t,o){return["catch",e,o]},function(n,r){return["finally",r]},function(n,r,e,t,o,i){return["functionDecl",r,t,i]},function(n,r,e,t,o,i){return["functionExpr",r[0],t,i]},function(n,r,e){return["arrow",n,e]},function(n,r,e){return["lambda",n,e]},function(n){return[["def",n]]},function(n,r,e){return r},function(n,r,e,t,o){return["getter",r,[],o]},function(n,r,e,t,o,i){return["setter",r,[t],i]},function(n,r,e,t,o){return["method",n,e,o]},function(n){return o},function(n,r){return["use",n+r]},function(n,r){return["def",n+r]},function(n,r){return[n,r]},function(n){return["data",JSON.parse(n)]},function(n,r,e,t){return["call",["use",n],[e]]},function(n,r,e){return["bind",n,e]},function(n,r,e){return["bind",n,e]},function(n){return["importBind",[["as","default",n[1]]]]},function(n,r,e){return["importBind",[["as","*",e[1]]]]},function(n){return["importBind",n]},function(n,r,e,t){return["importBind",[["as","default",n[1]],["as","*",t[1]]]]},function(n,e){return["importBind",[["as","default",n[1]]].concat(r(e))]},function(n){return["as",n[1],n[1]]},function(n,r,e){return["as",n,e[1]]},function(n,r,e){return r},function(n,r,e,t,o){return["import",r,JSON.parse(t)]},function(n,r,e,t){return["exportDefault",e]},function(n,e){return["export"].concat(r(e))});return[a,e.extends(a)(n(),function(n){return function(){return n}})]}),m=immunize(f);exports.default=m;
},{}],"My9u":[function(require,module,exports) {
"use strict";function n(){var r=e(["\n# to be overridden or inherited\nstart <- _WS assignExpr _EOF                ",";\n\n# to be extended\nprimaryExpr <- dataStructure;\n\ndataStructure <-\n  dataLiteral                             ","\n/ array\n/ record\n/ HOLE                                    ",";\n\n# An expression without side-effects.\n# to be extended\npureExpr <-\n  dataLiteral                             ","\n/ pureArray\n/ pureRecord\n/ HOLE                                    ",';\n\ndataLiteral <- (("null" / "false" / "true") _WSN / NUMBER / STRING) _WS;\n\npureArray <-\n  LEFT_BRACKET pureExpr ** _COMMA _COMMA? RIGHT_BRACKET ',";\n\narray <-\n  LEFT_BRACKET element ** _COMMA _COMMA? RIGHT_BRACKET ",';\n\n# to be extended\nelement <- assignExpr;\n\n# The JavaScript and JSON grammars calls records "objects"\n\npureRecord <-\n  LEFT_BRACE purePropDef ** _COMMA _COMMA? RIGHT_BRACE  ',";\n\nrecord <-\n  LEFT_BRACE propDef ** _COMMA _COMMA? RIGHT_BRACE  ",";\n\n# to be extended\npurePropDef <- propName COLON pureExpr     ",";\n\n# to be extended\npropDef <- propName COLON assignExpr       ",";\n\n# to be extended\npropName <- STRING                     ",';\n\n# to be overridden\nassignExpr <- primaryExpr;\n\n# Lexical syntax\n\n_EOF <- ~.;\nLEFT_BRACKET <- "[" _WS;\nRIGHT_BRACKET <- "]" _WS;\nLEFT_BRACE <- "{" _WS;\nRIGHT_BRACE <- "}" _WS;\n_COMMA <- "," _WS                     ',';\nCOLON <- ":" _WS;\nMINUS <- "-" _WS;\nHOLE <- &'," _WS;\n\nSTRING <- < '\"' (~'\"' character)* '\"' > _WS;\n\nutf8 <-\n  [Â-ß] utf8cont\n/ [à-ï] utf8cont utf8cont\n/ [ð-ô] utf8cont utf8cont utf8cont;\n\nutf8cont <- [-¿];\n\ncharacter <-\n  escape\n/ '\\u' hex hex hex hex\n/ ~'\\' ([ -] / utf8);\n\nescape <- '\\' ['\"\\bfnrt];\nhex <- digit / [a-fA-F];\n\nNUMBER <- < int frac? exp? > _WSN;\n\nint <- [1-9] digit+\n/ digit\n/ MINUS digit\n/ MINUS [1-9] digit+;\n\ndigit <- [0-9];\n\nfrac <- '.' digit+;\nexp <- [Ee] [+-]? digit+;\n\n# _WSN is whitespace or a non-ident character.\n_WSN <- ~[$A-Za-z_] _WS    ",";\n_WS <- [\t\n\r ]*          ",";\n"],["\n# to be overridden or inherited\nstart <- _WS assignExpr _EOF                ",";\n\n# to be extended\nprimaryExpr <- dataStructure;\n\ndataStructure <-\n  dataLiteral                             ","\n/ array\n/ record\n/ HOLE                                    ",";\n\n# An expression without side-effects.\n# to be extended\npureExpr <-\n  dataLiteral                             ","\n/ pureArray\n/ pureRecord\n/ HOLE                                    ",';\n\ndataLiteral <- (("null" / "false" / "true") _WSN / NUMBER / STRING) _WS;\n\npureArray <-\n  LEFT_BRACKET pureExpr ** _COMMA _COMMA? RIGHT_BRACKET ',";\n\narray <-\n  LEFT_BRACKET element ** _COMMA _COMMA? RIGHT_BRACKET ",';\n\n# to be extended\nelement <- assignExpr;\n\n# The JavaScript and JSON grammars calls records "objects"\n\npureRecord <-\n  LEFT_BRACE purePropDef ** _COMMA _COMMA? RIGHT_BRACE  ',";\n\nrecord <-\n  LEFT_BRACE propDef ** _COMMA _COMMA? RIGHT_BRACE  ",";\n\n# to be extended\npurePropDef <- propName COLON pureExpr     ",";\n\n# to be extended\npropDef <- propName COLON assignExpr       ",";\n\n# to be extended\npropName <- STRING                     ",';\n\n# to be overridden\nassignExpr <- primaryExpr;\n\n# Lexical syntax\n\n_EOF <- ~.;\nLEFT_BRACKET <- "[" _WS;\nRIGHT_BRACKET <- "]" _WS;\nLEFT_BRACE <- "{" _WS;\nRIGHT_BRACE <- "}" _WS;\n_COMMA <- "," _WS                     ',';\nCOLON <- ":" _WS;\nMINUS <- "-" _WS;\nHOLE <- &'," _WS;\n\nSTRING <- < '\"' (~'\"' character)* '\"' > _WS;\n\nutf8 <-\n  [\\xc2-\\xdf] utf8cont\n/ [\\xe0-\\xef] utf8cont utf8cont\n/ [\\xf0-\\xf4] utf8cont utf8cont utf8cont;\n\nutf8cont <- [\\x80-\\xbf];\n\ncharacter <-\n  escape\n/ '\\\\u' hex hex hex hex\n/ ~'\\\\' ([\\x20-\\x7f] / utf8);\n\nescape <- '\\\\' ['\"\\\\bfnrt];\nhex <- digit / [a-fA-F];\n\nNUMBER <- < int frac? exp? > _WSN;\n\nint <- [1-9] digit+\n/ digit\n/ MINUS digit\n/ MINUS [1-9] digit+;\n\ndigit <- [0-9];\n\nfrac <- '.' digit+;\nexp <- [Ee] [+\\-]? digit+;\n\n# _WSN is whitespace or a non-ident character.\n_WSN <- ~[$A-Za-z_] _WS    ",";\n_WS <- [\\t\\n\\r ]*          ",";\n"]);return n=function(){return r},r}function e(n,e){return e||(e=n.slice(0)),Object.freeze(Object.defineProperties(n,{raw:{value:Object.freeze(e)}}))}Object.defineProperty(exports,"__esModule",{value:!0}),exports.default=void 0;var r=immunize(function(e){var r=e.FAIL,t=e.HOLE,a=e.SKIP;return e(n(),function(n){return function(){return n}},function(n){return["data",JSON.parse(n)]},function(n){return["exprHole",n]},function(n){return["data",JSON.parse(n)]},function(n){return["exprHole",n]},function(n,e,r){return["array",e]},function(n,e,r){return["array",e]},function(n,e,r){return["record",e]},function(n,e,r){return["record",e]},function(n,e,r){return["prop",n,r]},function(n,e,r){return["prop",n,r]},function(n){var e=JSON.parse(n);return"__proto__"===e?r:["data",e]},function(n){return a},t,function(n){return a},function(n){return a})}),t=immunize(r);exports.default=t;
},{}],"fln+":[function(require,module,exports) {
"use strict";function r(r){return n(r)||e(r)||t()}function t(){throw new TypeError("Invalid attempt to spread non-iterable instance")}function e(r){if(Symbol.iterator in Object(r)||"[object Arguments]"===Object.prototype.toString.call(r))return Array.from(r)}function n(r){if(Array.isArray(r)){for(var t=0,e=new Array(r.length);t<r.length;t++)e[t]=r[t];return e}}Object.defineProperty(exports,"__esModule",{value:!0}),exports.reduceElisions=exports.qrepack=exports.qunpack=void 0;var o=immunize(function(t,e,n){return[t].concat(r(e),[n])});exports.qunpack=o;var a=immunize(function(r){for(var t=[r[0]],e=[],n=r.length,o=1;o<n;o+=2)e.push(r[o]),t.push(r[o+1]);var a=[].concat(t);return a.raw=t,[["data",a]].concat(e)});exports.qrepack=a;var i=immunize(function(r){var t=[],e=!0,n=!1,o=void 0;try{for(var a,i=r[Symbol.iterator]();!(e=(a=i.next()).done);e=!0){var u=a.value;void 0===u[0]?u.forEach(function(r){return t.push(void 0)}):t.push(u)}}catch(c){n=!0,o=c}finally{try{e||null==i.return||i.return()}finally{if(n)throw o}}return t});exports.reduceElisions=i;
},{}],"X5zO":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.default=void 0;var n=require("./quasi-utils.mjs");function e(){var n=r(["\n    # to be overridden or inherited\n    start <- _WS assignExpr _EOF                       ",';\n\n    # A.1 Lexical Grammar\n\n    DOT <- "." _WS;\n    ELLIPSIS <- "..." _WS;\n    LEFT_PAREN <- "(" _WS;\n    PLUS <- "+" _WS;\n    QUESTION <- "?" _WS;\n    RIGHT_PAREN <- ")" _WS;\n    STARSTAR <- "**" _WS;\n\n    # Define Javascript-style comments.\n    _WS <- super._WS (EOL_COMMENT / MULTILINE_COMMENT)?   ',';\n    EOL_COMMENT <- "//" (~[\n\r] .)* _WS;\n    MULTILINE_COMMENT <- "/*" (~"*/" .)* "*/" _WS;\n\n    # Add single-quoted strings.\n    STRING <-\n      super.STRING\n    / "\'" < (~"\'" character)* > "\'" _WS  ',";\n\n    # Only match if whitespace doesn't contain newline\n    _NO_NEWLINE <- ~IDENT [ \t]*     ",';\n\n    IDENT_NAME <- ~"__proto__" (IDENT / RESERVED_WORD);\n\n    IDENT <- < ~IMPORT_PFX [$A-Za-z_] [$A-Za-z0-9_]* > _WS;\n    IMPORT_PFX <- "$i_";\n\n    # Omit "async", "arguments", "eval", "get", and "set" from IDENT\n    # in Justin even though ES2017 considers them in IDENT.\n    RESERVED_WORD <-\n      (KEYWORD / RESERVED_KEYWORD / FUTURE_RESERVED_WORD\n    / "null" / "false" / "true"\n    / "async" / "arguments" / "eval" / "get" / "set") _WSN;\n\n    KEYWORD <-\n      ("break"\n    / "case" / "catch" / "const" / "continue"\n    / "debugger" / "default"\n    / "else" / "export"\n    / "finally" / "for" / "function"\n    / "if" / "import"\n    / "return"\n    / "switch"\n    / "throw" / "try" / "typeof"\n    / "void"\n    / "while") _WSN;\n\n    # Unused by Justin but enumerated here, in order to omit them\n    # from the IDENT token.\n    RESERVED_KEYWORD <-\n      ("class"\n    / "delete" / "do"\n    / "extends"\n    / "in" / "instanceof"\n    / "new"\n    / "super"\n    / "this"\n    / "var"\n    / "with"\n    / "yield") _WSN;\n\n    FUTURE_RESERVED_WORD <-\n      ("await" / "enum"\n    / "implements" / "package" / "protected"\n    / "interface" / "private" / "public") _WSN;\n\n    # Quasiliterals aka template literals\n    QUASI_CHAR <- "\\" . / ~"`" .;\n    QUASI_ALL <- "`" < (~"${" QUASI_CHAR)* > "`" _WS;\n    QUASI_HEAD <- "`" < (~"${" QUASI_CHAR)* > "${" _WS;\n    QUASI_MID <- "}" < (~"${" QUASI_CHAR)* > "${" _WS;\n    QUASI_TAIL <- "}" < (~"${" QUASI_CHAR)* > "`" _WS;\n\n\n    # A.2 Expressions\n\n    dataStructure <-\n      "undefined" _WSN     ',"\n    / super.dataStructure;\n\n    # Optional trailing commas.\n    record <-\n      super.record\n    / LEFT_BRACE propDef ** _COMMA _COMMA? RIGHT_BRACE      ",";\n\n    array <-\n      super.array\n    / LEFT_BRACKET element ** _COMMA _COMMA? RIGHT_BRACKET  ",";\n\n    useVar <- IDENT                                       ",";\n\n    # Justin does not contain variable definitions, only uses. However,\n    # multiple languages that extend Justin will contain defining\n    # occurrences of variable names, so we put the defVar production\n    # here.\n    defVar <- IDENT                                       ",";\n\n\n    primaryExpr <-\n      super.primaryExpr\n    / quasiExpr\n    / LEFT_PAREN expr RIGHT_PAREN                         ","\n    / useVar;\n\n    pureExpr <-\n      super.pureExpr\n    / LEFT_PAREN pureExpr RIGHT_PAREN                     ","\n    / useVar;\n\n    element <-\n      super.element\n    / ELLIPSIS assignExpr                                 ",";\n\n    propDef <-\n      super.propDef\n    / useVar                                              ","\n    / ELLIPSIS assignExpr                                 ",";\n\n    purePropDef <-\n      super.purePropDef\n    / useVar                                              ","\n    / ELLIPSIS assignExpr                                 ",";\n\n    # No computed property name\n    propName <-\n      super.propName\n    / IDENT_NAME\n    / NUMBER;\n\n    quasiExpr <-\n      QUASI_ALL                                            ","\n    / QUASI_HEAD expr ** QUASI_MID QUASI_TAIL              ",";\n\n    # to be extended\n    memberPostOp <-\n      LEFT_BRACKET indexExpr RIGHT_BRACKET                 ","\n    / DOT IDENT_NAME                                       ","\n    / quasiExpr                                            ",";\n\n    # to be extended\n    callPostOp <-\n      memberPostOp\n    / args                                                 ",';\n\n    # Because Justin and Jessie have no "new" or "super", they don\'t need\n    # to distinguish callExpr from memberExpr. So justin omits memberExpr\n    # and newExpr. Instead, in Justin, callExpr jumps directly to\n    # primaryExpr and updateExpr jumps directly to callExpr.\n\n    # to be overridden.\n    callExpr <- primaryExpr callPostOp*                   ',";\n\n    # To be overridden rather than inherited.\n    # Introduced to impose a non-JS restriction\n    # Restrict index access to number-names, including\n    # floating point, NaN, Infinity, and -Infinity.\n    indexExpr <-\n      NUMBER                                               ","\n    / PLUS unaryExpr                                       ",";\n\n    args <- LEFT_PAREN arg ** _COMMA RIGHT_PAREN            ",";\n\n    arg <-\n      assignExpr\n    / ELLIPSIS assignExpr                                  ",";\n\n    # to be overridden\n    updateExpr <- callExpr;\n\n    unaryExpr <-\n      preOp unaryExpr                                      ",'\n    / updateExpr;\n\n    # to be extended\n    # No prefix or postfix "++" or "--".\n    # No "delete".\n    preOp <- (("void" / "typeof") _WSN / prePre);\n    prePre <- ("+" / "-" / "~" / "!") _WS                 ',";\n\n    # Different communities will think -x**y parses in different ways,\n    # so the EcmaScript grammar forces parens to disambiguate.\n    powExpr <-\n      updateExpr STARSTAR powExpr                          ","\n    / unaryExpr;\n\n    multExpr <- powExpr (multOp powExpr)*                  ",";\n    addExpr <- multExpr (addOp multExpr)*                  ",";\n    shiftExpr <- addExpr (shiftOp addExpr)*                ",";\n\n    # Non-standard, to be overridden\n    # In C-like languages, the precedence and associativity of the\n    # relational, equality, and bitwise operators is surprising, and\n    # therefore hazardous. Here, none of these associate with the\n    # others, forcing parens to disambiguate.\n    eagerExpr <- shiftExpr (eagerOp shiftExpr)?            ",";\n\n    andThenExpr <- eagerExpr (andThenOp eagerExpr)*       ",";\n    orElseExpr <- andThenExpr (orElseOp andThenExpr)*     ",';\n\n    multOp <- ("*" / "/" / "%") _WS;\n    addOp <- ("+" / "-") _WS;\n    shiftOp <- ("<<" / ">>>" / ">>") _WS;\n    relOp <- ("<=" / "<" / ">=" / ">") _WS;\n    eqOp <- ("===" / "!==") _WS;\n    bitOp <- ("&" / "^" / "|") _WS;\n\n    eagerOp <- relOp / eqOp / bitOp;\n\n    andThenOp <- "&&" _WS;\n    orElseOp <- "||" _WS;\n\n    condExpr <-\n      orElseExpr QUESTION assignExpr COLON assignExpr   ',"\n    / orElseExpr;\n\n    # override, to be extended\n    assignExpr <- condExpr;\n\n    # The comma expression is not in Jessie because we\n    # opt to pass only immunized expressions as the this-binding.\n    expr <- assignExpr;\n  "],["\n    # to be overridden or inherited\n    start <- _WS assignExpr _EOF                       ",';\n\n    # A.1 Lexical Grammar\n\n    DOT <- "." _WS;\n    ELLIPSIS <- "..." _WS;\n    LEFT_PAREN <- "(" _WS;\n    PLUS <- "+" _WS;\n    QUESTION <- "?" _WS;\n    RIGHT_PAREN <- ")" _WS;\n    STARSTAR <- "**" _WS;\n\n    # Define Javascript-style comments.\n    _WS <- super._WS (EOL_COMMENT / MULTILINE_COMMENT)?   ',';\n    EOL_COMMENT <- "//" (~[\\n\\r] .)* _WS;\n    MULTILINE_COMMENT <- "/*" (~"*/" .)* "*/" _WS;\n\n    # Add single-quoted strings.\n    STRING <-\n      super.STRING\n    / "\'" < (~"\'" character)* > "\'" _WS  ',";\n\n    # Only match if whitespace doesn't contain newline\n    _NO_NEWLINE <- ~IDENT [ \\t]*     ",';\n\n    IDENT_NAME <- ~"__proto__" (IDENT / RESERVED_WORD);\n\n    IDENT <- < ~IMPORT_PFX [$A-Za-z_] [$A-Za-z0-9_]* > _WS;\n    IMPORT_PFX <- "$i_";\n\n    # Omit "async", "arguments", "eval", "get", and "set" from IDENT\n    # in Justin even though ES2017 considers them in IDENT.\n    RESERVED_WORD <-\n      (KEYWORD / RESERVED_KEYWORD / FUTURE_RESERVED_WORD\n    / "null" / "false" / "true"\n    / "async" / "arguments" / "eval" / "get" / "set") _WSN;\n\n    KEYWORD <-\n      ("break"\n    / "case" / "catch" / "const" / "continue"\n    / "debugger" / "default"\n    / "else" / "export"\n    / "finally" / "for" / "function"\n    / "if" / "import"\n    / "return"\n    / "switch"\n    / "throw" / "try" / "typeof"\n    / "void"\n    / "while") _WSN;\n\n    # Unused by Justin but enumerated here, in order to omit them\n    # from the IDENT token.\n    RESERVED_KEYWORD <-\n      ("class"\n    / "delete" / "do"\n    / "extends"\n    / "in" / "instanceof"\n    / "new"\n    / "super"\n    / "this"\n    / "var"\n    / "with"\n    / "yield") _WSN;\n\n    FUTURE_RESERVED_WORD <-\n      ("await" / "enum"\n    / "implements" / "package" / "protected"\n    / "interface" / "private" / "public") _WSN;\n\n    # Quasiliterals aka template literals\n    QUASI_CHAR <- "\\\\" . / ~"\\`" .;\n    QUASI_ALL <- "\\`" < (~"\\${" QUASI_CHAR)* > "\\`" _WS;\n    QUASI_HEAD <- "\\`" < (~"\\${" QUASI_CHAR)* > "\\${" _WS;\n    QUASI_MID <- "}" < (~"\\${" QUASI_CHAR)* > "\\${" _WS;\n    QUASI_TAIL <- "}" < (~"\\${" QUASI_CHAR)* > "\\`" _WS;\n\n\n    # A.2 Expressions\n\n    dataStructure <-\n      "undefined" _WSN     ',"\n    / super.dataStructure;\n\n    # Optional trailing commas.\n    record <-\n      super.record\n    / LEFT_BRACE propDef ** _COMMA _COMMA? RIGHT_BRACE      ",";\n\n    array <-\n      super.array\n    / LEFT_BRACKET element ** _COMMA _COMMA? RIGHT_BRACKET  ",";\n\n    useVar <- IDENT                                       ",";\n\n    # Justin does not contain variable definitions, only uses. However,\n    # multiple languages that extend Justin will contain defining\n    # occurrences of variable names, so we put the defVar production\n    # here.\n    defVar <- IDENT                                       ",";\n\n\n    primaryExpr <-\n      super.primaryExpr\n    / quasiExpr\n    / LEFT_PAREN expr RIGHT_PAREN                         ","\n    / useVar;\n\n    pureExpr <-\n      super.pureExpr\n    / LEFT_PAREN pureExpr RIGHT_PAREN                     ","\n    / useVar;\n\n    element <-\n      super.element\n    / ELLIPSIS assignExpr                                 ",";\n\n    propDef <-\n      super.propDef\n    / useVar                                              ","\n    / ELLIPSIS assignExpr                                 ",";\n\n    purePropDef <-\n      super.purePropDef\n    / useVar                                              ","\n    / ELLIPSIS assignExpr                                 ",";\n\n    # No computed property name\n    propName <-\n      super.propName\n    / IDENT_NAME\n    / NUMBER;\n\n    quasiExpr <-\n      QUASI_ALL                                            ","\n    / QUASI_HEAD expr ** QUASI_MID QUASI_TAIL              ",";\n\n    # to be extended\n    memberPostOp <-\n      LEFT_BRACKET indexExpr RIGHT_BRACKET                 ","\n    / DOT IDENT_NAME                                       ","\n    / quasiExpr                                            ",";\n\n    # to be extended\n    callPostOp <-\n      memberPostOp\n    / args                                                 ",';\n\n    # Because Justin and Jessie have no "new" or "super", they don\'t need\n    # to distinguish callExpr from memberExpr. So justin omits memberExpr\n    # and newExpr. Instead, in Justin, callExpr jumps directly to\n    # primaryExpr and updateExpr jumps directly to callExpr.\n\n    # to be overridden.\n    callExpr <- primaryExpr callPostOp*                   ',";\n\n    # To be overridden rather than inherited.\n    # Introduced to impose a non-JS restriction\n    # Restrict index access to number-names, including\n    # floating point, NaN, Infinity, and -Infinity.\n    indexExpr <-\n      NUMBER                                               ","\n    / PLUS unaryExpr                                       ",";\n\n    args <- LEFT_PAREN arg ** _COMMA RIGHT_PAREN            ",";\n\n    arg <-\n      assignExpr\n    / ELLIPSIS assignExpr                                  ",";\n\n    # to be overridden\n    updateExpr <- callExpr;\n\n    unaryExpr <-\n      preOp unaryExpr                                      ",'\n    / updateExpr;\n\n    # to be extended\n    # No prefix or postfix "++" or "--".\n    # No "delete".\n    preOp <- (("void" / "typeof") _WSN / prePre);\n    prePre <- ("+" / "-" / "~" / "!") _WS                 ',";\n\n    # Different communities will think -x**y parses in different ways,\n    # so the EcmaScript grammar forces parens to disambiguate.\n    powExpr <-\n      updateExpr STARSTAR powExpr                          ","\n    / unaryExpr;\n\n    multExpr <- powExpr (multOp powExpr)*                  ",";\n    addExpr <- multExpr (addOp multExpr)*                  ",";\n    shiftExpr <- addExpr (shiftOp addExpr)*                ",";\n\n    # Non-standard, to be overridden\n    # In C-like languages, the precedence and associativity of the\n    # relational, equality, and bitwise operators is surprising, and\n    # therefore hazardous. Here, none of these associate with the\n    # others, forcing parens to disambiguate.\n    eagerExpr <- shiftExpr (eagerOp shiftExpr)?            ",";\n\n    andThenExpr <- eagerExpr (andThenOp eagerExpr)*       ",";\n    orElseExpr <- andThenExpr (orElseOp andThenExpr)*     ",';\n\n    multOp <- ("*" / "/" / "%") _WS;\n    addOp <- ("+" / "-") _WS;\n    shiftOp <- ("<<" / ">>>" / ">>") _WS;\n    relOp <- ("<=" / "<" / ">=" / ">") _WS;\n    eqOp <- ("===" / "!==") _WS;\n    bitOp <- ("&" / "^" / "|") _WS;\n\n    eagerOp <- relOp / eqOp / bitOp;\n\n    andThenOp <- "&&" _WS;\n    orElseOp <- "||" _WS;\n\n    condExpr <-\n      orElseExpr QUESTION assignExpr COLON assignExpr   ',"\n    / orElseExpr;\n\n    # override, to be extended\n    assignExpr <- condExpr;\n\n    # The comma expression is not in Jessie because we\n    # opt to pass only immunized expressions as the this-binding.\n    expr <- assignExpr;\n  "]);return e=function(){return n},n}function r(n,e){return e||(e=n.slice(0)),Object.freeze(Object.defineProperties(n,{raw:{value:Object.freeze(e)}}))}function t(n,e){return p(n)||a(n,e)||i()}function i(){throw new TypeError("Invalid attempt to destructure non-iterable instance")}function a(n,e){var r=[],t=!0,i=!1,a=void 0;try{for(var p,s=n[Symbol.iterator]();!(t=(p=s.next()).done)&&(r.push(p.value),!e||r.length!==e);t=!0);}catch(o){i=!0,a=o}finally{try{t||null==s.return||s.return()}finally{if(i)throw a}}return r}function p(n){if(Array.isArray(n))return n}var s=immunize(n.qunpack),o=immunize(function(n,e){return e.reduce(function(n,e){var r=t(e,2);return[r[0],n,r[1]]},n)}),E=immunize(function(n){for(var e=0,r="";e<n.length;){var t=n.slice(e,e+1);"\\"===t?(r+=n.slice(e,e+2),e+=2):'"'===t?(r+='\\"',e++):(r+=t,e++)}return'"'.concat(r,'"')}),u=immunize(function(n){var r=n.SKIP;return n(e(),function(n){return function(){return n}},function(n){return r},function(n){return E(n)},function(n){return r},function(n){return["data",void 0]},function(n,e,r){return["record",e]},function(n,e,r){return["array",e]},function(n){return["use",n]},function(n){return["def",n]},function(n,e,r){return e},function(n,e,r){return e},function(n,e){return["spread",e]},function(n){return["prop",n[1],n]},function(n,e){return["spreadObj",e]},function(n){return["prop",n[1],n]},function(n,e){return["spreadObj",e]},function(n){return["quasi",[n]]},function(n,e,r){return["quasi",s(n,e,r)]},function(n,e,r){return["index",e]},function(n,e){return["get",e]},function(n){return["tag",n]},function(n){return["call",n]},o,function(n){return["data",JSON.parse(n)]},function(n,e){return["pre:+",e]},function(n,e,r){return e},function(n,e){return["spread",e]},function(n,e){return[n,e]},function(n){return"pre:".concat(n)},function(n,e,r){return[e,n,r]},o,o,o,o,o,o,function(n,e,r,t,i){return["cond",n,r,i]})}),d=immunize(u);exports.default=d;
},{"./quasi-utils.mjs":"fln+"}],"ZHvC":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.default=void 0;var r=immunize(function(e,n){function t(t){for(var u=arguments.length,i=new Array(u>1?u-1:0),o=1;o<u;o++)i[o-1]=arguments[o];if("string"==typeof t)return r(e(t),n);var a=t,s=a.reduce(function(r,e,n){return r.push(e,String(i[n])),r},[]);s.push(a[a.length-1]);var c=s.join(""),f=i.reduce(function(r,e,n){return r.push(String(e),a.raw[n+1]),r},[a.raw[0]]).join(""),p={byte:0,column:1,line:1,uri:n},d=[c];return d.raw=[f],d.sources=[p],e(d)}return t.parserCreator=e.parserCreator,t._asExtending=e._asExtending,t}),e=immunize(r);exports.default=e;
},{}],"HlfI":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.translate=void 0;var e=a(require("./boot-peg.mjs")),r=a(require("./boot-pegast.mjs")),t=a(require("./quasi-peg.mjs")),n=a(require("./quasi-jessie.mjs")),i=a(require("./quasi-json.mjs")),u=a(require("./quasi-justin.mjs")),o=a(require("./tag-string.mjs"));function a(e){return e&&e.__esModule?e:{default:e}}function s(e){for(var r=1;r<arguments.length;r++){var t=null!=arguments[r]?arguments[r]:{},n=Object.keys(t);"function"==typeof Object.getOwnPropertySymbols&&(n=n.concat(Object.getOwnPropertySymbols(t).filter(function(e){return Object.getOwnPropertyDescriptor(t,e).enumerable}))),n.forEach(function(r){m(e,r,t[r])})}return e}function m(e,r,t){return r in e?Object.defineProperty(e,r,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[r]=t,e}function f(){var e=l(["",""]);return f=function(){return e},e}function l(e,r){return r||(r=e.slice(0)),Object.freeze(Object.defineProperties(e,{raw:{value:Object.freeze(r)}}))}function c(e,r){return j(e)||b(e,r)||d()}function d(){throw new TypeError("Invalid attempt to destructure non-iterable instance")}function b(e,r){var t=[],n=!0,i=!1,u=void 0;try{for(var o,a=e[Symbol.iterator]();!(n=(o=a.next()).done)&&(t.push(o.value),!r||t.length!==r);n=!0);}catch(s){i=!0,u=s}finally{try{n||null==a.return||a.return()}finally{if(i)throw u}}return t}function j(e){if(Array.isArray(e))return e}var p=immunize(e.default),y=immunize(r.default),v=immunize(t.default),z=immunize(n.default),O=immunize(i.default),g=immunize(u.default),q=immunize(o.default),w=immunize(p(v,y)),h=immunize(O(w)),x=immunize(g(w.extends(h))),P=immunize(z(w,w.extends(x))),_=c(P,1),S=_[0],k=immunize(function(e,r){return makePromise(function(t){q(S,r.sourceURL)(f(),e),t(s({},r,{translatedText:e}))})});exports.translate=k;
},{"./boot-peg.mjs":"QgFk","./boot-pegast.mjs":"joiS","./quasi-peg.mjs":"3zTw","./quasi-jessie.mjs":"NMVp","./quasi-json.mjs":"My9u","./quasi-justin.mjs":"X5zO","./tag-string.mjs":"ZHvC"}],"lr5t":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),require("../nodejs/globalEnv.mjs");var e=require("../../lib/index.mjs");Object.keys(e).forEach(function(r){"default"!==r&&"__esModule"!==r&&Object.defineProperty(exports,r,{enumerable:!0,get:function(){return e[r]}})});
},{"../nodejs/globalEnv.mjs":"fc7A","../../lib/index.mjs":"HlfI"}]},{},["lr5t"], "jessica")
//# sourceMappingURL=/jessica.js.map