{"version":3,"sources":["../nodejs/sesshim.mjs","../../lib/immunize.mjs","../nodejs/jessieDefaults.mjs","globalEnv.mjs","../../lib/indent.mjs","../../lib/boot-peg.mjs","../../lib/boot-pegast.mjs","../../lib/quasi-peg.mjs","../../lib/quasi-jessie-module.mjs","../../lib/quasi-jessie.mjs","../../lib/quasi-json.mjs","../../lib/quasi-utils.mjs","../../lib/quasi-justin.mjs","../../lib/rewrite-define.mjs","../../lib/tag-string.mjs","../../lib/translate.mjs","jessica.mjs"],"names":["harden","Object","freeze","confine","exprSrc","env","names","getOwnPropertyNames","closedFuncSrc","join","encodeURIComponent","slice","closedFunc","eval","map","n","window","global","immunize","makeImmunize","makeHarden","makeWrapper","setComputedIndex","immunizeHardener","tryWrapMethods","obj","entries","key","value","wrapped","wrap","e","_wrapperMap","makeWeakMap","fn","wrapper","get","newImmunize","set","root","wrapRoot","globalEnv","sesshim","applyMethod","thisObj","method","args","apply","index","val","slog","error","ret","iargs","ithis","prepareObject","hardMap","WeakMap","newHarden","type","has","frozen","values","makeMap","Map","makeSet","Set","makePromise","executor","Promise","makeWeakSet","WeakSet","jessieDefaults","keys","forEach","vname","indent","template","substs","result","newnewline","i","ilen","length","segment","startsWith","lastnl","lastIndexOf","j","push","String","split","subst","$i_indent","LEFT_RECUR","toString","RUN","self","ruleOrPatt","pos","name","_debug","info","posm","_memo","_hits","_misses","EAT","lastFailures","maxPos","fails","posArr","fail","JSON","stringify","newPos","FAIL","indexOf","ERROR","_pos","last","found","FIND","tokStr","Array","isArray","makeTokStr","failStr","sources","raw","reduce","prior","r","s","uri","line","DONE","notice","v","debug","numSubs","relpos","segnum","seglen","ACCEPT","_self","str","HOLE","SKIP","lHexDigits","uHexDigits","hexDigit","c","unescape","cs","q","ord","fromCharCode","bootPeg","makePeg","bootPegAst","compile","sexp","alphaCount","vars","nextVar","prefix","nextLabel","vtable","peg","rules","rulesSrc","peval","paramSrcs","def","body","bodySrc","empty","or","choices","labelSrc","choicesSrc","cSrc","seq","terms","posSrc","sSrc","vSrc","termsSrc","termSrc","pred","hole","Math","max","val0","act","patt","sep","startSrc","pattSrc","sepSrc","sepValSrc","starSrc","super","ident","begin","end","cls","classStr","invert","c2","min","charCodeAt","k","op","srcCs","dot","lit","peek","peekNot","expr","nameStr","quasifyParser","parserCreator","quasiMemo","quasiCurry","wm","templateTag","templateOrFlag","quasiRest","subs","baseCurry","parser","undefined","pair","start","done","defaultBaseGrammar","_template","metaCompile","baseRules","baseAST","parserTraitMakerSrc","makeParserTrait","parserTrait","_asExtending","quasiParser","ext","baseQuasiParser","tag0","flags","tag","tmplOrFlag","boundParser","parserBase","p","flag","extends","pegTag","closedDefaultBaseGrammar","actionExtractorTag","actions","bootPegActions","bootPegTag","astExtractorTag","defs","reparsedPegAst","a","b","finalPegTag","panic","simple","list","flatArgs","flatSeq","term","kind","_","_2","optHole","optQ","makeJessieModule","jessiePeg","d","terminatedBlock","manyBodies","bs","t","makeJessie","justinPeg","jessieTag","_3","id","lv","rv","pe","_4","label","stat","f","o","_5","decls","ps","parse","h","tb","pfx","fname","d2","makeJSON","es","js","qunpack","ms","qrepack","parts","argExprs","len","reduceElisions","reduced","$i_qunpack","binary","left","rights","prev","transformSingleQuote","qs","makeJustin","u","x","y","hide","separate","strs","actualSep","moduleRewriteDefine","moduleAST","DEFINE","starName","EXPORTS","imports","exportVars","nImport","rewriters","as","imp","sym","bind","doRewrite","add","exportDefaultX","exportX","qual","binds","clear","bindings","assign","import","clause","fromModule","importBind","matchArray","matchProp","kw","prop","rewrite","matchRecord","moduleX","cur","modules","mod","rest","restObj","node","rewriter","tagString","tagged","cooked","cooked0","raw0","sources0","byte","column","tmpl","$i_bootPeg","$i_bootPegAst","$i_makePeg","$i_makeJessieModule","$i_makeJessie","$i_makeJSON","$i_makeJustin","rewriteModuleDefine","$i_rewriteModuleDefine","$i_tagString","jsonTag","justinTag","jessieModuleTag","translate","sourceText","parameters","resolve","sourceType","target","targetType","moduleAst","sourceURL","translatedText","src"],"mappings":"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SAAS,CACxB,CACA,MACA,UACA,CACA,MACA,EACA,WACA,CACA,IACA,cAEA,eAGA,CACA,MACA,aACA,CACA,MACA,EACA,aACA,YACA,aACA,OACA,CACA,OACA,KAIA,CACA,MACA,aACA,CACA,MACA,EACA,CACA,KACA,WACA,YAIA,CACA,MACA,WACA,CACA,MACA,EACA,CACA,MACA,EACA,CACA,IACA,WAGA,CACA,IACA,UAIA,CACA,MACA,SACA,CACA,KACA,CACA,MACA,EACA,MACA,QAEA,CACA,MACA,EACA,MACA,UAEA,CACA,MACA,EACA,MACA,UAEA,CACA,OACA,YAIA,CACA,MACA,SACA,CACA,KACA,CACA,MACA,EACA,UACA,CACA,KACA,CACA,OACA,YAEA,CACA,OACA,aAGA,WAEA,CACA,MACA,GACA,UACA,CACA,KACA,CACA,OACA,YAEA,CACA,OACA,QAEA,CACA,OACA,UAIA,CACA,OACA,aAIA,CACA,MACA,UACA,CACA,KACA,CACA,OACA,SAEA,CACA,OACA,aACA,CACA,UACA,cAGA,CACA,MACA,GACA,OACA,aACA,SAEA,CACA,MACA,GACA,WAEA,CACA,MACA,GACA,SAEA,CACA,MACA,GACA,OAEA,CACA,MACA,GACA,SAEA,CACA,MACA,GACA,SAIA,CACA,MACA,QACA,CACA,MACA,GACA,CACA,MACA,UAEA,eAGA,CACA,MACA,aACA,CACA,OACA,CACA,SAEA,aACA,CACA,IACA,aAEA,CACA,OAEA,aAGA,CACA,MACA,aACA,CACA,OACA,CACA,MACA,aAIA,CACA,MACA,YACA,CACA,KACA,CACA,OACA,cAEA,CACA,OACA,CACA,MACA,UAKA,CACA,MACA,UACA,CACA,KACA,CACA,OACA,CACA,MACA,KAEA,CACA,SAEA,CACA,IACA,CACA,OACA,CACA,UACA,CACA,MACA,MAGA,SAGA,CACA,OAEA,CACA,MACA,KAEA,YAEA,CACA,OACA,CACA,MACA,KAEA,CACA,SAEA,CACA,IACA,CACA,OACA,CACA,UACA,CACA,MACA,MAGA,SAGA,CACA,OAEA,CACA,MACA,KAEA,cAIA,CACA,MACA,QACA,CACA,OACA,CACA,MACA,KAEA,CACA,SAEA,CACA,IACA,CACA,OACA,CACA,UACA,CACA,MACA,MAGA,UAGA,CACA,OAEA,CACA,MACA,KAEA,aAGA,CACA,MACA,QACA,CACA,KACA,CACA,OACA,OACA,CACA,MACA,KAEA,QAEA,CACA,OACA,UAIA,CACA,MACA,OACA,CACA,KACA,CACA,OACA,CACA,MACA,QAEA,CACA,MACA,gCAGA,CACA,OACA,CACA,MACA,SAEA,CACA,MACA,aAEA,CACA,MACA,cAGA,CACA,OACA,CACA,MACA,QAEA,CACA,MACA,MAGA,CACA,OACA,CACA,UACA,CACA,MACA,SAGA,CACA,UAKA,CACA,MACA,YACA,CACA,OACA,CACA,MACA,MAEA,aAGA,CACA,MACA,SACA,CACA,MACA,GACA,CACA,MACA,KAEA,aAGA,CACA,MACA,OACA,CACA,OACA,CACA,MACA,KAEA,aAGA,CACA,MACA,MACA,CACA,OACA,CACA,MACA,KAEA,aAGA,CACA,MACA,MACA,CACA,OACA,CACA,MACA,KAEA,aAGA,CACA,MACA,WACA,CACA,OACA,CACA,MACA,KAEA,aAGA,CACA,MACA,OACA,CACA,OACA,CACA,MACA,KAEA,aAGA,CACA,MACA,OACA,CACA,OACA,CACA,MACA,KAEA,aAGA,CACA,MACA,OACA,CACA,OACA,CACA,MACA,KAEA,aAGA,CACA,MACA,QACA,CACA,OACA,CACA,MACA,KAEA,aAGA,CACA,MACA,MACA,CACA,OACA,CACA,MACA,KAEA,aAGA,CACA,MACA,WACA,CACA,MACA,GACA,CACA,IACA,CACA,KACA,CACA,OACA,SAEA,CACA,OACA,eAMA,CACA,MACA,UACA,CACA,OACA,CACA,MACA,KAEA,CACA,IACA,CACA,OACA,CACA,UACA,aAEA,CACA,SAIA,cAGA,CACA,MACA,QACA,CACA,KACA,CACA,OACA,CACA,MACA,MAGA,CACA,OACA,CACA,MACA,QAGA,CACA,OACA,eAI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","file":"jessica.js","sourceRoot":"","sourcesContent":["/**\n * By requiring sesshim.js, if you are not already in a SES\n * environment, you obtain a trivial polyfil of a small bit of SES's\n * API with none of its security. At the moment, you get only\n * <tt>def</tt> and <tt>confine</tt>, but with little of their\n * functionality. More API and more functionality will be provided on\n * an as-needed basis by my current uses, though I will try not to\n * break old clients that were compatible with both SES and\n * sesshim.js.\n *\n * <p>Currently, even if you are already in a SES environment,\n * sesshim.js will ignore that and do the same thing. Once actual SES\n * works on node/iojs/ES6, sesshim.js should test if it is in such an\n * environment, and re-export SES's versions of the APIs that\n * sesshim.js does provide, or wrappings that adapt them to ES6.\n */\n/**\n * The faux version of SES's <tt>harden</tt> is currently just a\n * synonym for Object.freeze.\n */\nconst harden = Object.freeze;\n/**\n * The faux version of SES's <tt>confine</tt> evals an\n * expression in an environment consisting of the global environment\n * as enhanced and shadowed by the own properties of the\n * <tt>env</tt> object. Unlike real <tt>confine</tt>, <ul>\n * <li>The faux <tt>confine</tt> does not have a third\n *     <tt>opt_options</tt> parameter. An options argument can of\n *     course be provided by the caller, but it will be ignored.\n * <li>The expression can be in the subset of ES6 supported by\n *     Babel.\n * <li>All dangerous globals that are not shadowed, such as \"window\"\n *     or \"document\", are still accessible by the evaled expression.\n * <li>The current binding of these properties at the time that\n *     <tt>confine</tt> is called are used as the initial\n *     bindings. Further changes to either the properties or the\n *     bindings are not tracked by the other.\n * <li>In the evaled expression, <tt>this</tt> is bound to\n *     <tt>undefined</tt>.\n * </ul>\n * When sesshim.js is enhanced to use SES if present, this confine\n * should wrap SES's confine rather than export it directly, in\n * order to continue to support ES6 expressions.\n */\nfunction confine(exprSrc, env) {\n    exprSrc = '' + exprSrc;\n    const names = Object.getOwnPropertyNames(env);\n    // Note: no newline prior to ${exprSrc}, so that line numbers for\n    // errors within exprSrc are accurate. Column numbers on the first\n    // line won't be, but will on following lines.\n    const closedFuncSrc = `(function(${names.join(',')}) { \"use strict\"; return (${exprSrc}\n);\n})\n//# sourceURL=data:${encodeURIComponent(exprSrc).slice(0, 48)}...\n`;\n    // tslint:disable-next-line:no-unused-expression\n    const closedFunc = (1, eval)(closedFuncSrc);\n    return closedFunc(...names.map(n => env[n]));\n}\n// For bootstrapping Jessie modules.\n(typeof window === 'undefined' ? global : window).immunize = harden;\nexport default { confine: harden(confine), harden: harden(harden) };\n","// DO NOT EDIT - Generated automatically from immunize.mjs.ts by tessc\n// Create an `immunize` function for use in Jessie endowments.\n//\n// Recursively freeze the root, a la harden.  If it is a function\n// or contains a reachable property that is an function, that\n// function will be replaced by a memoized hardened wrapper that\n// immunizes its argumens, return value, and any thrown exception.\n//\n// A baroque Proxy or frozen object cannot be immunized, but will still be\n// hardened.  These are objects that cannot possibly contain mutable Jessie\n// objects (since all Jessie objects have been immunized before export), so\n// this incompleteness does not compromise Jessie.\n\n\nconst makeImmunize = immunize((\nmakeHarden,\nmakeWrapper,\nsetComputedIndex) => {\n\n  // Create a hardener that attempts to immunize functions on the way.\n  const immunizeHardener = makeHarden(tryWrapMethods);\n  function tryWrapMethods(obj) {\n    // Just do a best-effort immunizing the object's methods.\n    for (const [key, value] of Object.entries(obj)) {\n      if (typeof value !== 'function') {\n        continue;\n      }\n      const wrapped = wrap(value);\n      try {\n        // This means: obj[key] = wrapper;\n        setComputedIndex(obj, key, wrapped);\n      } catch (e) {\n        // obj is a Proxy, or frozen object that blocked\n        // our attempt to set its property.\n\n        // It can't have originated from Jessie, so this is an\n        // endowment or primitive from the parent environment\n        // which wasn't added to harden's initialFringe.\n\n        // We go on, as a best-effort attempt to try immunizing the\n        // properties we can.\n        continue;\n      }\n    }\n  }\n\n  const _wrapperMap = makeWeakMap();\n\n  // FIXME: Needed for bootstrap.\n  _wrapperMap.set(setComputedIndex, setComputedIndex);\n\n  function wrap(fn) {\n    let wrapper = _wrapperMap.get(fn);\n    if (!wrapper) {\n      wrapper = makeWrapper(newImmunize, fn);\n\n      // Memoize our results.\n      _wrapperMap.set(fn, wrapper);\n      _wrapperMap.set(wrapper, wrapper);\n\n      // Copy in the wrapped function's properties (if any).\n      // These are immunized in the next traversal.\n      for (const [key, value] of Object.entries(fn)) {\n        setComputedIndex(wrapper, key, value);\n      }\n    }\n    return wrapper;\n  }\n\n  function newImmunize(root) {\n    // We may need to wrap the root before immunizing its children.\n    if (typeof root === 'function') {\n      const wrapRoot = wrap(root);\n      return immunizeHardener(wrapRoot);\n    }\n    return immunizeHardener(root);\n  }\n\n  return newImmunize;\n});\n\nexport default immunize(makeImmunize);","/// <reference path=\"../../typings/ses.d.ts\"/>\n/// <reference path=\"node_modules/@types/node/ts3.1/index.d.ts\"/>\nimport sesshim from './sesshim.mjs';\nconst { confine } = sesshim;\nconst globalEnv = {};\nglobalEnv.confine = confine;\nexport const applyMethod = Object.freeze((thisObj, method, args) => method.apply(thisObj, args));\nexport const setComputedIndex = Object.freeze((obj, index, val) => {\n    if (index === '__proto__') {\n        slog.error `Cannot set ${{ index }} object member`;\n    }\n    return obj[index] = val;\n});\nexport const makeWrapper = Object.freeze((newImmunize, fn) => function wrapper(...args) {\n    let ret;\n    try {\n        // Immunize `this` and arguments before calling.\n        const iargs = args.map(newImmunize);\n        const ithis = newImmunize(this);\n        ret = fn.apply(ithis, iargs);\n    }\n    catch (e) {\n        // Immunize exception, and rethrow.\n        throw newImmunize(e);\n    }\n    // Immunize return value.\n    return newImmunize(ret);\n});\n// TODO: Need to use @agoric/make-hardener.\nconst makeHarden = (prepareObject) => {\n    const hardMap = new WeakMap();\n    // FIXME: Needed for bootstrap.\n    hardMap.set(setComputedIndex, setComputedIndex);\n    if (typeof window !== 'undefined') {\n        hardMap.set(window, window);\n    }\n    function newHarden(root) {\n        if (root === null) {\n            return root;\n        }\n        const type = typeof root;\n        if (type !== 'object' && type !== 'function') {\n            return root;\n        }\n        if (hardMap.has(root)) {\n            return hardMap.get(root);\n        }\n        prepareObject(root);\n        const frozen = Object.freeze(root);\n        hardMap.set(root, frozen);\n        for (const value of Object.values(root)) {\n            newHarden(value);\n        }\n        return frozen;\n    }\n    return newHarden;\n};\nimport makeImmunize from '../../lib/immunize.mjs';\n// Need to bootstrap makeImmunize.\nglobal.makeWeakMap = Object.freeze((...args) => Object.freeze(new WeakMap(...args)));\nconst immunize = makeImmunize(makeHarden, makeWrapper, setComputedIndex);\nglobalEnv.immunize = immunize;\nglobalEnv.makeMap = immunize((...args) => new Map(...args));\nglobalEnv.makeSet = immunize((...args) => new Set(...args));\nglobalEnv.makePromise = immunize((executor) => new Promise(executor));\nglobalEnv.makeWeakMap = immunize((...args) => new WeakMap(...args));\nglobalEnv.makeWeakSet = immunize((...args) => new WeakSet(...args));\nexport default globalEnv;\n","import jessieDefaults from '../nodejs/jessieDefaults.mjs';\n\n(function(global) {\nObject.keys(jessieDefaults).forEach(vname => {\n    global[vname] = jessieDefaults[vname];\n});\n}(typeof window === 'undefined' ? global : window));\n\nexport default jessieDefaults;\n","// DO NOT EDIT - Generated automatically from indent.mjs.ts by tessc\nconst indent = immunize((template, ...substs) => {\n  const result = [];\n  let newnewline = '\\n';\n  for (let i = 0, ilen = substs.length; i < ilen; i++) {\n    let segment = template[i];\n    if (i === 0 && segment[0].startsWith('\\n')) {\n      segment = segment.slice(1);\n    }\n    const lastnl = segment.lastIndexOf('\\n');\n    if (lastnl >= 0) {\n      newnewline = '\\n';\n      for (let j = segment.length - lastnl; j > 0; j--) {\n        newnewline += ' ';\n      }\n    }\n    result.push(segment);\n    // We don't have regexps at our disposal in Jessie.\n    String(substs[i]).split('\\n').forEach((subst, j) => {\n      if (j !== 0) {\n        result.push(newnewline);\n      }\n      result.push(subst);\n    });\n  }\n  result.push(template[substs.length]);\n  return result.join('');\n});\n\nexport default immunize(indent);","// DO NOT EDIT - Generated automatically from boot-peg.mjs.ts by tessc\n// A lot of this code is lifted from:\n// https://github.com/erights/quasiParserGenerator/tree/master/src/bootbnf.js\n\n/// <reference path=\"peg.d.ts\"/>\n\nimport $i_indent from './indent.mjs';const indent = immunize($i_indent);\n\nconst LEFT_RECUR = immunize({ toString: () => 'LEFT_RECUR' });\n\nconst RUN = immunize((self, ruleOrPatt, pos, name) => {\n  if (self._debug) {\n    slog.info`run(f, ${pos}, ${name})`;\n  }\n  let posm = self._memo.get(pos);\n  if (!posm) {\n    posm = makeMap();\n    self._memo.set(pos, posm);\n  }\n  let result = posm.get(ruleOrPatt);\n  if (result) {\n    if (result === LEFT_RECUR) {\n      slog.error`Left recursion on rule: ${{ name }}`;\n    }\n    self._hits(1);\n  } else {\n    posm.set(ruleOrPatt, LEFT_RECUR);\n    self._misses(1);\n    if (typeof ruleOrPatt === 'function') {\n      result = ruleOrPatt(self, pos);\n    } else if (ruleOrPatt === void 0) {\n      slog.error`Rule missing: ${name}`;\n    } else {\n      result = EAT(self, pos, ruleOrPatt);\n    }\n    posm.set(ruleOrPatt, result);\n  }\n  return result;\n});\n\nconst lastFailures = immunize(self => {\n  let maxPos = 0;\n  let fails = [];\n  for (const posArr of self._memo) {\n    const posm = posArr[1];\n    for (const [ruleOrPatt, result] of posm) {\n      if (result !== LEFT_RECUR) {\n        const fail = typeof ruleOrPatt === 'function' ?\n        ruleOrPatt.name.slice(5) :\n        JSON.stringify('' + ruleOrPatt);\n        const [newPos, v] = result;\n        if (v === FAIL) {\n          if (newPos > maxPos) {\n            maxPos = newPos;\n            fails = [fail];\n          } else if (newPos === maxPos && fails.indexOf(fail) < 0) {\n            fails.push(fail);\n          }\n        }\n      }\n    }\n  }\n  return [maxPos, fails];\n});\n\nconst ERROR = immunize((self, _pos) => {\n  const [last, fails] = lastFailures(self);\n  const found = FIND(self.template, last);\n  const tokStr = Array.isArray(found) ?\n  `at ${last} ${makeTokStr(self, found)}` :\n  `unexpected EOF after ${makeTokStr(self, FIND(self.template, last - 1))}`;\n\n  const failStr = fails.length === 0 ?\n  `stuck` : `looking for ${fails.join(', ')}`;\n  const { sources } = self.template;\n  slog.info`-------template--------\n    ${self.template.raw.reduce((prior, r, i) => {\n    if (sources) {\n      const s = sources[i];\n      prior += `    ${s.uri}:${s.line}: `;\n    }\n    prior += JSON.stringify(r).slice(0, 50) + '\\n';\n    return prior;\n  }, '')}\n    -------\n    ${failStr}`;\n  slog.error`Syntax error ${tokStr}`;\n});\n\nconst makeTokStr = immunize((self, found) => {\n  if (Array.isArray(found)) {\n    const segment = self.template[found[0]];\n    return `${JSON.stringify(segment[found[1]])} #${found[0]}:${found[1]}`;\n  }\n  if (typeof found === 'number') {\n    return `hole #${found}`;\n  }\n  return undefined;\n});\n\nconst DONE = immunize(self => {\n  if (self._debug) {\n    for (const [pos, posm] of self._memo) {\n      const fails = [];\n      for (const [ruleOrPatt, result] of posm) {\n        const name = typeof ruleOrPatt === 'function' ?\n        ruleOrPatt.name : JSON.stringify(ruleOrPatt);\n        if (result === LEFT_RECUR) {\n          slog.notice`${name}(${pos}) => left recursion detector`;\n        } else {\n          const [newPos, v] = result;\n          if (v === FAIL) {\n            fails.push(name);\n          } else {\n            slog.debug`${name}(${pos}) => [${newPos}, ${v}]`;\n          }\n        }\n      }\n      if (fails.length >= 1) {\n        slog.debug`@${pos} => FAIL [${fails}]`;\n      }\n    }\n    slog.info`hits: ${self._hits(0)}, misses: ${self._misses(0)}`;\n  }\n});\n\nconst FIND = immunize((template, pos) =>\n{\n  const { raw } = template;\n  const numSubs = raw.length - 1;\n  let relpos = pos;\n  for (let segnum = 0; segnum <= numSubs; segnum++) {\n    const segment = raw[segnum];\n    const seglen = segment.length;\n    if (relpos < seglen) {\n      return [segnum, relpos];\n    } else if (relpos === seglen && segnum < numSubs) {\n      return segnum; // as hole number\n    }\n    relpos -= seglen + 1; // \"+1\" for the skipped hole\n  }\n});\n\nconst ACCEPT = immunize((_self, pos) => {\n  // Not really needed: useful for incremental compilation.\n  return [pos, []];\n});\n\nconst EAT = immunize((self, pos, str) => {\n  // if (self._debug) {\n  //    slog.warn`Have ${self.template}`;\n  // }\n  const found = FIND(self.template, pos);\n  if (Array.isArray(found)) {\n    const segment = self.template.raw[found[0]];\n    if (typeof str === 'string') {\n      if (segment.startsWith(str, found[1])) {\n        return [pos + str.length, str];\n      }\n    } else {\n      // Just return the next character.\n      return [pos + 1, segment[found[1]]];\n    }\n  }\n  return [pos, FAIL];\n});\n\nconst HOLE = immunize((self, pos) => {\n  const found = FIND(self.template, pos);\n  if (typeof found === 'number') {\n    return [pos + 1, found];\n  }\n  return [pos, FAIL];\n});\n\nconst FAIL = immunize({ toString: () => 'FAIL' });\nconst SKIP = immunize({ toString: () => 'SKIP' });\n\nconst lHexDigits = '0123456789abcdef';\nconst uHexDigits = 'ABCDEF';\n\nconst hexDigit = immunize(c => {\n  let i = lHexDigits.indexOf(c);\n  if (i < 0) {\n    i = uHexDigits.indexOf(c) + 10;\n  }\n  if (i < 0) {\n    slog.error`Invalid hexadecimal number ${{ c }}`;\n  }\n  return i;\n});\n\nconst unescape = immunize(cs => {\n  if (cs[0] !== '\\\\') {\n    return [cs[0], 1];\n  }\n\n  // It's an escape.\n  let q = cs[1];\n  switch (q) {\n    case 'b':{\n        q = '\\b';\n        break;\n      }\n    case 'f':{\n        q = '\\f';\n        break;\n      }\n    case 'n':{\n        q = '\\n';\n        break;\n      }\n    case 'r':{\n        q = '\\r';\n        break;\n      }\n    case 't':{\n        q = '\\t';\n        break;\n      }\n    case 'x':{\n        const ord = hexDigit(cs[2]) * 16 + hexDigit(cs[3]);\n        q = String.fromCharCode(ord);\n        return [q, 4];\n      }}\n\n\n  return [q, 2];\n});\n\nconst bootPeg = immunize((makePeg, bootPegAst) => {\n  function compile(sexp) {\n    let numSubs = 0; // # of holes implied by sexp, so far\n\n    // generated names\n    // act_${i}      action parameter\n    // rule_${name}  method from peg rule\n    // seq_${i}      sequence failure label\n    // or_${i}       choice success label\n    // pos_${i}      backtrack token index\n    // s_${i}        accumulated list of values\n    // v_${i}        set to s_${i} on fall thru path\n\n    let alphaCount = 0;\n    const vars = ['let value = FAIL'];\n    function nextVar(prefix) {\n      const result = `${prefix}_${alphaCount++}`;\n      vars.push(result);\n      return result;\n    }\n    function takeVarsSrc() {\n      const result = `${vars.join(', ')};`;\n      vars.length = 1;\n      return result;\n    }\n    function nextLabel(prefix) {\n      return `${prefix}_${alphaCount++}`;\n    }\n\n    const vtable = {\n      peg(...rules) {\n        // The following line also initializes numSubs\n        const rulesSrc = rules.map(peval).join('\\n');\n\n        const paramSrcs = [];\n        for (let i = 0; i < numSubs; i++) {\n          paramSrcs.push(`act_${i}`);\n        }\n        // rules[0] is the ast of the first rule, which has the form\n        // [\"def\", ruleName, body], so rules[0][1] is the name of\n        // the start rule. We prepend \"rule_\" to get the name of the\n        // JS method that implements the start rule. We invoke it\n        // with (0) so that it will parse starting at position 0. It\n        // returns a pair of the final position (after the last\n        // non-EOF token parsed), and the semantic value. On failure\n        // to parse, the semantic value will be FAIL.\n        const name = rules[0][1];\n        return indent`\n    (function(${paramSrcs.join(', ')}) {\n      let myHits = 0, myMisses = 0;\n      return baseMemo => (template, debug) => {\n          const BaseParser = baseMemo({});\n          return {...BaseParser,\n        template,\n        _memo: makeMap(),\n        _hits: (i) => myHits += i,\n        _misses: (i) => myMisses += i,\n        _debug: debug,\n        start: (self) => {\n          const pair = RUN(self, self.rule_${name}, 0, ${JSON.stringify(name)});\n          if (pair[1] === FAIL) {\n            ERROR(self, pair[0]);\n          }\n          return pair[1];\n        },\n        done: DONE,\n        ${rulesSrc}\n    }};\n    })\n    `;\n      },\n      def(name, body) {\n        const bodySrc = peval(body);\n        return indent`\n    rule_${name}: (self, pos) => {\n      ${takeVarsSrc()}\n      ${bodySrc}\n      return [pos, value];\n    },`;\n      },\n      empty() {\n        return `value = SKIP;`;\n      },\n      fail() {\n        return `value = FAIL;`;\n      },\n      or(...choices) {\n        const labelSrc = nextLabel('or');\n        const choicesSrc = choices.map(peval).map(cSrc => indent`\n    ${cSrc}\n    if (value !== FAIL) break ${labelSrc};`).join('\\n');\n\n        return indent`\n    ${labelSrc}: {\n      ${choicesSrc}\n    }`;\n      },\n      seq(...terms) {\n        const posSrc = nextVar('pos');\n        const labelSrc = nextLabel('seq');\n        const sSrc = nextVar('s');\n        const vSrc = nextVar('v');\n        const termsSrc = terms.map(peval).map(termSrc => indent`\n    ${termSrc}\n    if (value === FAIL) break ${labelSrc};\n    if (value !== SKIP) ${sSrc}.push(value);`).join('\\n');\n\n        return indent`\n    ${sSrc} = [];\n    ${vSrc} = FAIL;\n    ${posSrc} = pos;\n    ${labelSrc}: {\n      let beginPos, yytext;\n      ${termsSrc}\n      if (yytext !== undefined) {\n          ${vSrc} = [yytext];\n      }\n      else {\n        ${vSrc} = ${sSrc};\n      }\n    }\n    if ((value = ${vSrc}) === FAIL) pos = ${posSrc};`;\n      },\n      pred(hole) {\n        numSubs = Math.max(numSubs, hole + 1);\n        return `[pos, value] = act_${hole}(self, pos);`;\n      },\n      val0(...terms) {\n        // FIXME: Find a better way to specify where < foo > can\n        // provide a default semantic action, and to warn\n        // when it is in the wrong context.\n        const termsSrc = vtable.seq(...terms);\n        return indent`\n    ${termsSrc}\n    if (value !== FAIL && value.length === 1) value = value[0];`;\n      },\n      act(hole, ...terms) {\n        const posSrc = nextVar('pos');\n        numSubs = Math.max(numSubs, hole + 1);\n        const termsSrc = vtable.seq(...terms);\n        return indent`\n    ${posSrc} = pos;\n    ${termsSrc}\n    if (value !== FAIL) {\n        value = act_${hole}(...value);\n        if (Array.isArray(value)) {\n            value = [...value];\n            value._pegPosition = makeTokStr(self, FIND(self.template, ${posSrc}));\n        }\n    }`;\n      },\n      '**'(patt, sep) {\n        // for backtracking\n        const posSrc = nextVar('pos');\n        // a non-advancing success only repeats once.\n        const startSrc = nextVar('pos');\n        const sSrc = nextVar('s');\n        const pattSrc = peval(patt);\n        const sepSrc = peval(sep);\n        const sepValSrc = nextVar('sepVal');\n        // after first iteration, backtrack to before the separator\n        return indent`\n    ${sSrc} = [];\n    ${posSrc} = pos;\n    ${sepValSrc} = SKIP;\n    while (true) {\n      ${startSrc} = pos;\n      ${pattSrc}\n      if (value === FAIL) {\n        pos = ${posSrc};\n        break;\n      }\n      if (${sepValSrc} !== SKIP) ${sSrc}.push(${sepValSrc});\n      if (value !== SKIP) ${sSrc}.push(value);\n      ${posSrc} = pos;\n      ${sepSrc}\n      if (value === FAIL) break;\n      ${sepValSrc} = value;\n      if (pos === ${startSrc}) break;\n    }\n    value = ${sSrc};`;\n      },\n      '++'(patt, sep) {\n        const starSrc = vtable['**'](patt, sep);\n        return indent`\n    ${starSrc}\n    if (value.length === 0) value = FAIL;`;\n      },\n      '?'(patt) {\n        return vtable['**'](patt, ['fail']);\n      },\n      '*'(patt) {\n        return vtable['**'](patt, ['empty']);\n      },\n      '+'(patt) {\n        return vtable['++'](patt, ['empty']);\n      },\n      super(ident) {\n        return `[pos, value] = RUN(self, BaseParser.rule_${ident}, pos, ${\n        JSON.stringify(`super.${ident}`)});`;\n      },\n      // PEG extensions.\n      begin() {\n        // Mark the current pos.\n        return `beginPos = pos; value = [];`;\n      },\n      end() {\n        // Use the specified beginPos to extract a string\n        return indent`\n    if (beginPos !== undefined) {\n        yytext = '';\n        while (beginPos < pos) {\n            [beginPos, value] = EAT(self, beginPos);\n            if (value === FAIL) {\n                break;\n            }\n            yytext += value;\n        }\n        beginPos = undefined;\n        value = [];\n    }`;\n      },\n      cls(cs) {\n        // Character class.\n        let classStr = '',i = 0;\n        const invert = cs[i] === '^';\n        if (invert) {\n          ++i;\n        }\n        while (i < cs.length) {\n          const [c, j] = unescape(cs.slice(i));\n          i += j;\n          if (cs[i] === '-') {\n            // It's a range.\n            ++i;\n            const [c2, j2] = unescape(cs.slice(i));\n            i += j2;\n            const min = c.charCodeAt(0);\n            const max = c2.charCodeAt(0);\n            for (let k = min; k <= max; k++) {\n              classStr += String.fromCharCode(k);\n            }\n          } else {\n            classStr += c;\n          }\n        }\n        const op = invert ? '>=' : '<';\n        const srcCs = JSON.stringify(classStr);\n        return indent`\n    [pos, value] = EAT(self, pos);\n    if (value !== FAIL) {\n        value = ${srcCs}.indexOf(value) ${op} 0 ? FAIL : value;\n    }\n                `;\n      },\n      dot() {\n        return indent`\n    [pos, value] = EAT(self, pos);\n                `;\n      },\n      lit(cs) {\n        let str = '',i = 0;\n        while (i < cs.length) {\n          const [c, j] = unescape(cs.slice(i));\n          i += j;\n          str += c;\n        }\n        return indent`\n    [pos, value] = EAT(self, pos, ${JSON.stringify(str)});\n    `;\n      },\n      peek(patt) {\n        // for backtracking\n        const posSrc = nextVar('pos');\n        const pattSrc = peval(patt);\n        // if the pattern matches, restore, else FAIL\n        // always rewind.\n        return indent`\n    ${posSrc} = pos;\n    ${pattSrc}\n    if (value !== FAIL) {\n        value = SKIP;\n    }\n    pos = ${posSrc};`;\n      },\n      peekNot(patt) {\n        // for backtracking\n        const posSrc = nextVar('pos');\n        const pattSrc = peval(patt);\n        // if the pattern matches, FAIL, else success,\n        // always rewind.\n        return indent`\n    ${posSrc} = pos;\n    ${pattSrc}\n    value = (value === FAIL) ? SKIP : FAIL;\n    pos = ${posSrc};`;\n      } };\n\n\n    function peval(expr) {\n      if (typeof expr === 'string') {\n        // We only match idents... literal strings are protected\n        // by ['lit', s].\n        const nameStr = JSON.stringify(expr);\n        return `[pos, value] = RUN(self, self.rule_${expr}, pos, ${nameStr});`;\n      }\n      const op = vtable[expr[0]];\n      if (!op) {\n        slog.error`Cannot find ${expr[0]} in vtable`;\n      }\n      return op(...expr.slice(1));\n    }\n\n    return peval(sexp);\n  }\n\n\n\n  function quasiMemo(quasiCurry,\n  parserCreator) {\n    const wm = makeWeakMap();\n    let debug = false;\n    const templateTag = (templateOrFlag, ...subs) => {\n      if (typeof templateOrFlag === 'string') {\n        switch (templateOrFlag) {\n          case 'DEBUG':{\n              // Called as tag('DEBUG')`template string`\n              // Turn on debug mode.\n              debug = true;\n              break;\n            }\n          default:{\n              throw slog.error`Unrecognized tag flag ${{ templateOrFlag }}`;\n            }}\n\n        return templateTag;\n      }\n      const template = templateOrFlag;\n      let quasiRest = wm.get(template);\n      if (!quasiRest) {\n        quasiRest = quasiCurry(template, debug);\n        wm.set(template, quasiRest);\n      }\n      if (typeof quasiRest !== 'function') {\n        slog.error`${typeof quasiRest}: ${quasiRest}`;\n      }\n      return quasiRest(...subs);\n    };\n    templateTag.parserCreator = parserCreator;\n    return templateTag;\n  }\n\n  function quasifyParser(parserCreator) {\n    function baseCurry(template, debug) {\n      const parser = parserCreator(template, debug);\n      if (parser === undefined) {\n        slog.error`Cannot curry baseParserCreator`;\n      }\n      let pair = null;\n      try {\n        pair = parser.start(parser);\n      } finally {\n        parser.done(parser); // hook for logging debug output\n      }\n      return pair;\n    }\n    return quasiMemo(baseCurry, parserCreator);\n  }\n\n  const defaultBaseGrammar = quasifyParser(_template => undefined);\n\n  function metaCompile(baseRules) {\n    const baseAST = ['peg', ...baseRules];\n    const parserTraitMakerSrc = compile(baseAST);\n    // slog.trace`SOURCES: ${parserTraitMakerSrc}\\n`;\n\n    const makeParserTrait = confine(parserTraitMakerSrc, {\n      DONE,\n      EAT,\n      ERROR,\n      FAIL,\n      FIND,\n      RUN,\n      SKIP,\n      makeTokStr });\n\n\n    return function parserTag(...baseActions) {\n      const parserTrait = makeParserTrait(...baseActions);\n      let _asExtending;\n      let quasiParser;\n      const ext = baseQuasiParser => {\n\n\n        function tag0(templateOrFlag, ...substs)\n        {\n          const flags = [];\n\n\n          function tag(tmplOrFlag, ...subs)\n          {\n            if (typeof tmplOrFlag === 'string') {\n              flags.push(tmplOrFlag);\n              return tag;\n            }\n            const boundParser = quasiParser(tmplOrFlag, ...subs);\n            const parserBase = boundParser._asExtending(baseQuasiParser);\n            const parser = flags.reduce((p, flag) => p(flag), parserBase);\n            return parser;\n          }\n\n          tag.ACCEPT = ACCEPT;\n          tag.EAT = EAT;\n          tag.FAIL = FAIL;\n          tag.HOLE = HOLE;\n          tag.SKIP = SKIP;\n          tag._asExtending = _asExtending;\n          tag.extends = ext;\n          tag.parserCreator = quasiParser.parserCreator;\n\n          if (typeof templateOrFlag === 'string') {\n            return tag(templateOrFlag);\n          }\n          return tag(templateOrFlag, ...substs);\n        }\n        tag0.ACCEPT = ACCEPT;\n        tag0.EAT = EAT;\n        tag0.FAIL = FAIL;\n        tag0.HOLE = HOLE;\n        tag0.SKIP = SKIP;\n        tag0._asExtending = _asExtending;\n        tag0.extends = ext;\n        tag0.parserCreator = quasiParser.parserCreator;\n        return tag0;\n      };\n      _asExtending = baseQuasiParser => {\n        const parserCreator = parserTrait(baseQuasiParser.parserCreator);\n        const parser = quasifyParser(parserCreator);\n        const pegTag = parser;\n        pegTag.ACCEPT = ACCEPT;\n        pegTag.EAT = EAT;\n        pegTag.FAIL = FAIL;\n        pegTag.HOLE = HOLE;\n        pegTag.SKIP = SKIP;\n        pegTag._asExtending = _asExtending;\n        pegTag.extends = ext;\n        return pegTag;\n      };\n      defaultBaseGrammar._asExtending = _asExtending;\n      const closedDefaultBaseGrammar =\n      defaultBaseGrammar;\n      closedDefaultBaseGrammar._asExtending = _asExtending;\n      quasiParser = _asExtending(closedDefaultBaseGrammar);\n      return quasiParser;\n    };\n  }\n\n  // Bootstrap the compiler with the precompiled pegAst.\n  const actionExtractorTag = (_template, ...actions) => actions;\n  actionExtractorTag.ACCEPT = ACCEPT;\n  actionExtractorTag.HOLE = HOLE;\n  actionExtractorTag.SKIP = SKIP;\n\n  // Extract the actions, binding them to the metaCompile function.\n  const bootPegActions = makePeg(actionExtractorTag, metaCompile);\n\n  // Create the parser tag from the AST and the actions.\n  const compiledAst = metaCompile(bootPegAst);\n  const bootPegTag = compiledAst(...bootPegActions);\n\n  // Use the parser tag to create another parser tag that returns the AST.\n  const astExtractorTag = makePeg(\n  bootPegTag, defs => (..._) => defs);\n  const reparsedPegAst = makePeg(astExtractorTag, undefined);\n\n  // Compare our bootPegTag output to bootPegAst, to help ensure it is\n  // correct.  This doesn't defend against a malicious bootPeg,\n  // but it does prevent silly mistakes.\n  const a = JSON.stringify(bootPegAst, undefined, '  ');\n  const b = JSON.stringify(reparsedPegAst, undefined, '  ');\n  if (a !== b) {\n    slog.info`// boot-pegast.mjs.ts - AUTOMATICALLY GENERATED by boot-peg.mjs.ts\\nexport default ${{ b }};`;\n    slog.panic`reparsedPegAst does not match src/boot-pegast.mjs.ts`;\n  }\n\n  // Use the metaCompiler to generate another parser.\n  const finalPegTag = makePeg(bootPegTag, metaCompile);\n  return finalPegTag;\n});\n\nexport default immunize(bootPeg);","// DO NOT EDIT - Generated automatically from boot-pegast.mjs.ts by tessc\n// boot-pegast.mjs.ts - AUTOMATICALLY GENERATED by boot-env.mjs.ts\nexport default immunize([\n[\n\"def\",\n\"Grammar\",\n[\n\"act\",\n0,\n\"_Spacing\",\n[\n\"+\",\n\"Definition\"],\n\n\"_EndOfFile\"]],\n\n\n[\n\"def\",\n\"Definition\",\n[\n\"act\",\n2,\n\"Identifier\",\n\"LEFTARROW\",\n\"Expression\",\n\"SEMI\",\n[\n\"pred\",\n1]]],\n\n\n\n[\n\"def\",\n\"Expression\",\n[\n\"act\",\n3,\n[\n\"**\",\n\"Sequence\",\n\"_SLASH\"]]],\n\n\n\n[\n\"def\",\n\"Sequence\",\n[\n\"act\",\n5,\n[\n\"act\",\n4,\n[\n\"*\",\n\"Prefix\"]],\n\n\n[\n\"?\",\n\"HOLE\"]]],\n\n\n\n[\n\"def\",\n\"Prefix\",\n[\n\"or\",\n[\n\"act\",\n6,\n\"AND\",\n\"HOLE\"],\n\n[\n\"act\",\n7,\n\"AND\",\n\"Suffix\"],\n\n[\n\"act\",\n8,\n\"NOT\",\n\"Suffix\"],\n\n[\n\"val0\",\n\"Suffix\"]]],\n\n\n\n[\n\"def\",\n\"Suffix\",\n[\n\"or\",\n[\n\"act\",\n9,\n\"Primary\",\n[\n\"or\",\n[\n\"val0\",\n\"STARSTAR\"],\n\n[\n\"val0\",\n\"PLUSPLUS\"]],\n\n\n\"Primary\"],\n\n[\n\"act\",\n10,\n\"Primary\",\n[\n\"or\",\n[\n\"val0\",\n\"QUESTION\"],\n\n[\n\"val0\",\n\"STAR\"],\n\n[\n\"val0\",\n\"PLUS\"]]],\n\n\n\n[\n\"val0\",\n\"Primary\"]]],\n\n\n\n[\n\"def\",\n\"Primary\",\n[\n\"or\",\n[\n\"val0\",\n\"Super\"],\n\n[\n\"val0\",\n\"Identifier\",\n[\n\"peekNot\",\n\"LEFTARROW\"]],\n\n\n[\n\"act\",\n11,\n\"OPEN\",\n\"Expression\",\n\"CLOSE\"],\n\n[\n\"act\",\n12,\n\"Literal\"],\n\n[\n\"act\",\n13,\n\"Class\"],\n\n[\n\"act\",\n14,\n\"DOT\"],\n\n[\n\"act\",\n15,\n\"BEGIN\"],\n\n[\n\"act\",\n16,\n\"END\"]]],\n\n\n\n[\n\"def\",\n\"Super\",\n[\n\"act\",\n17,\n[\n\"lit\",\n\"super.\"],\n\n\"Identifier\"]],\n\n\n[\n\"def\",\n\"Identifier\",\n[\n\"val0\",\n[\n\"begin\"],\n\n\"IdentStart\",\n[\n\"*\",\n\"IdentCont\"],\n\n[\n\"end\"],\n\n\"_Spacing\"]],\n\n\n[\n\"def\",\n\"IdentStart\",\n[\n\"val0\",\n[\n\"cls\",\n\"a-zA-Z_\"]]],\n\n\n\n[\n\"def\",\n\"IdentCont\",\n[\n\"or\",\n[\n\"val0\",\n\"IdentStart\"],\n\n[\n\"val0\",\n[\n\"cls\",\n\"0-9\"]]]],\n\n\n\n\n[\n\"def\",\n\"Literal\",\n[\n\"or\",\n[\n\"val0\",\n[\n\"cls\",\n\"'\"],\n\n[\n\"begin\"],\n\n[\n\"*\",\n[\n\"val0\",\n[\n\"peekNot\",\n[\n\"cls\",\n\"'\"]],\n\n\n\"Char\"]],\n\n\n[\n\"end\"],\n\n[\n\"cls\",\n\"'\"],\n\n\"_Spacing\"],\n\n[\n\"val0\",\n[\n\"cls\",\n\"\\\"\"],\n\n[\n\"begin\"],\n\n[\n\"*\",\n[\n\"val0\",\n[\n\"peekNot\",\n[\n\"cls\",\n\"\\\"\"]],\n\n\n\"Char\"]],\n\n\n[\n\"end\"],\n\n[\n\"cls\",\n\"\\\"\"],\n\n\"_Spacing\"]]],\n\n\n\n[\n\"def\",\n\"Class\",\n[\n\"val0\",\n[\n\"lit\",\n\"[\"],\n\n[\n\"begin\"],\n\n[\n\"*\",\n[\n\"val0\",\n[\n\"peekNot\",\n[\n\"lit\",\n\"]\"]],\n\n\n\"Range\"]],\n\n\n[\n\"end\"],\n\n[\n\"lit\",\n\"]\"],\n\n\"_Spacing\"]],\n\n\n[\n\"def\",\n\"Range\",\n[\n\"or\",\n[\n\"val0\",\n\"Char\",\n[\n\"lit\",\n\"-\"],\n\n\"Char\"],\n\n[\n\"val0\",\n\"Char\"]]],\n\n\n\n[\n\"def\",\n\"Char\",\n[\n\"or\",\n[\n\"val0\",\n[\n\"lit\",\n\"\\\\\\\\\"],\n\n[\n\"cls\",\n\"abefnrtv'\\\"\\\\[\\\\]\\\\\\\\\\\\`\\\\$\"]],\n\n\n[\n\"val0\",\n[\n\"lit\",\n\"\\\\\\\\x\"],\n\n[\n\"cls\",\n\"0-9a-fA-F\"],\n\n[\n\"cls\",\n\"0-9a-fA-F\"]],\n\n\n[\n\"val0\",\n[\n\"lit\",\n\"\\\\\\\\\"],\n\n[\n\"lit\",\n\"-\"]],\n\n\n[\n\"val0\",\n[\n\"peekNot\",\n[\n\"lit\",\n\"\\\\\\\\\"]],\n\n\n[\n\"dot\"]]]],\n\n\n\n\n[\n\"def\",\n\"LEFTARROW\",\n[\n\"val0\",\n[\n\"lit\",\n\"<-\"],\n\n\"_Spacing\"]],\n\n\n[\n\"def\",\n\"_SLASH\",\n[\n\"act\",\n18,\n[\n\"lit\",\n\"/\"],\n\n\"_Spacing\"]],\n\n\n[\n\"def\",\n\"SEMI\",\n[\n\"val0\",\n[\n\"lit\",\n\";\"],\n\n\"_Spacing\"]],\n\n\n[\n\"def\",\n\"AND\",\n[\n\"val0\",\n[\n\"lit\",\n\"&\"],\n\n\"_Spacing\"]],\n\n\n[\n\"def\",\n\"NOT\",\n[\n\"val0\",\n[\n\"lit\",\n\"~\"],\n\n\"_Spacing\"]],\n\n\n[\n\"def\",\n\"QUESTION\",\n[\n\"val0\",\n[\n\"lit\",\n\"?\"],\n\n\"_Spacing\"]],\n\n\n[\n\"def\",\n\"STAR\",\n[\n\"val0\",\n[\n\"lit\",\n\"*\"],\n\n\"_Spacing\"]],\n\n\n[\n\"def\",\n\"PLUS\",\n[\n\"val0\",\n[\n\"lit\",\n\"+\"],\n\n\"_Spacing\"]],\n\n\n[\n\"def\",\n\"OPEN\",\n[\n\"val0\",\n[\n\"lit\",\n\"(\"],\n\n\"_Spacing\"]],\n\n\n[\n\"def\",\n\"CLOSE\",\n[\n\"val0\",\n[\n\"lit\",\n\")\"],\n\n\"_Spacing\"]],\n\n\n[\n\"def\",\n\"DOT\",\n[\n\"val0\",\n[\n\"lit\",\n\".\"],\n\n\"_Spacing\"]],\n\n\n[\n\"def\",\n\"_Spacing\",\n[\n\"act\",\n19,\n[\n\"*\",\n[\n\"or\",\n[\n\"val0\",\n\"Space\"],\n\n[\n\"val0\",\n\"Comment\"]]]]],\n\n\n\n\n\n[\n\"def\",\n\"Comment\",\n[\n\"val0\",\n[\n\"lit\",\n\"#\"],\n\n[\n\"*\",\n[\n\"val0\",\n[\n\"peekNot\",\n\"EndOfLine\"],\n\n[\n\"dot\"]]],\n\n\n\n\"EndOfLine\"]],\n\n\n[\n\"def\",\n\"Space\",\n[\n\"or\",\n[\n\"val0\",\n[\n\"lit\",\n\" \"]],\n\n\n[\n\"val0\",\n[\n\"lit\",\n\"\\\\t\"]],\n\n\n[\n\"val0\",\n\"EndOfLine\"]]],\n\n\n\n[\n\"def\",\n\"EndOfLine\",\n[\n\"or\",\n[\n\"val0\",\n[\n\"lit\",\n\"\\\\r\\\\n\"]],\n\n\n[\n\"val0\",\n[\n\"lit\",\n\"\\\\n\"]],\n\n\n[\n\"val0\",\n[\n\"lit\",\n\"\\\\r\"]]]],\n\n\n\n\n[\n\"def\",\n\"_EndOfFile\",\n[\n\"val0\",\n[\n\"peekNot\",\n[\n\"dot\"]]]],\n\n\n\n\n[\n\"def\",\n\"HOLE\",\n[\n\"val0\",\n[\n\"pred\",\n20],\n\n\"_Spacing\"]],\n\n\n[\n\"def\",\n\"BEGIN\",\n[\n\"val0\",\n[\n\"lit\",\n\"<\"],\n\n\"_Spacing\"]],\n\n\n[\n\"def\",\n\"END\",\n[\n\"val0\",\n[\n\"lit\",\n\">\"],\n\n\"_Spacing\"]],\n\n\n[\n\"def\",\n\"PLUSPLUS\",\n[\n\"val0\",\n[\n\"lit\",\n\"++\"],\n\n\"_Spacing\"]],\n\n\n[\n\"def\",\n\"STARSTAR\",\n[\n\"val0\",\n[\n\"lit\",\n\"**\"],\n\n\"_Spacing\"]]]);","// DO NOT EDIT - Generated automatically from quasi-peg.mjs.ts by tessc\n// PEG quasi Grammar for PEG quasi Grammars\n// Michael FIG <michael+jessica@fig.org>, 2019-01-05\n//\n// This grammar is adapted from:\n// http://piumarta.com/software/peg/peg-0.1.18/src/peg.peg\n//\n// Modified for Jessica to support:\n//   Semantic actions provided in tagged template HOLEs\n//   '~' for negative lookahead (instead of '!')\n//   ';' terminator for definitions\n//   '**' and '++' for separators\n//   'super.RULE' syntax for extended grammars\n//   '\\xFF' instead of octal character literals\n// which are adapted from:\n// https://github.com/erights/quasiParserGenerator\n\n/// <reference path=\"peg.d.ts\"/>\n\nconst makePeg = immunize((\npegTag,\nmetaCompile) => {\n  const { ACCEPT, HOLE, SKIP } = pegTag;\n\n  function simple(prefix, list) {\n    if (list.length === 0) {return ['empty'];}\n    if (list.length === 1) {return list[0];}\n    return [prefix, ...list];\n  }\n\n  function flatArgs(args) {\n    return args.reduce((prior, a) => {\n      prior.push(...flatSeq(a));\n      return prior;\n    }, []);\n  }\n\n  function flatSeq(term) {\n    if (Array.isArray(term)) {\n      if (term.length === 0) {\n        return [];\n      }\n      const [kind, ...terms] = term;\n      if (kind === 'seq') {\n        return flatArgs(terms);\n      } else if (terms.length === 0 && Array.isArray(kind)) {\n        return flatSeq(kind);\n      } else {\n        return [[kind, ...flatArgs(terms)]];\n      }\n    }\n\n    return [term];\n  }\n\n  return pegTag`\n# Hierarchical syntax\n\nGrammar      <- _Spacing Definition+ _EndOfFile\n                    ${metaCompile};\n\nDefinition   <- Identifier LEFTARROW Expression SEMI &${ACCEPT}\n                    ${(i, _, e, _2) => ['def', i, e]};\nExpression   <- Sequence ** _SLASH\n                    ${list => simple('or', list)};\nSequence     <- (Prefix*\n                    ${list => simple('seq', list)})\n                 HOLE?\n                    ${(seq, optHole) => optHole.length === 0 ?\n  ['val0', ...flatSeq(seq)] :\n  ['act', optHole[0], ...flatSeq(seq)]};\nPrefix       <- AND HOLE\n                    ${(_, a) => ['pred', a]}\n              / AND Suffix\n                    ${(_, s) => ['peek', s]}\n              / NOT Suffix\n                    ${(_, s) => ['peekNot', s]}\n              /     Suffix;\nSuffix       <- Primary (STARSTAR\n                        / PLUSPLUS) Primary\n                    ${(patt, q, sep) => [q, patt, sep]}\n              / Primary (QUESTION\n                        / STAR\n                        / PLUS)\n                    ${(patt, optQ) => [optQ[0], patt]}\n              / Primary;\nPrimary      <- Super\n              / Identifier ~LEFTARROW\n              / OPEN Expression CLOSE\n                    ${(_, e, _2) => e}\n              / Literal\n                    ${s => ['lit', s]}\n              / Class\n                    ${c => ['cls', c]}\n              / DOT\n                    ${() => ['dot']}\n              / BEGIN\n                    ${() => ['begin']}\n              / END\n                    ${() => ['end']}\n              ;\n\nSuper        <- 'super.' Identifier\n                    ${(_, i) => ['super', i]};\n\n# Lexical syntax\n\nIdentifier   <- < IdentStart IdentCont* > _Spacing;\nIdentStart   <- [a-zA-Z_];\nIdentCont    <- IdentStart / [0-9];\nLiteral      <- ['] < (~['] Char )* > ['] _Spacing\n              / [\"] < (~[\"] Char )* > [\"] _Spacing;\nClass        <- '[' < (~']' Range)* > ']' _Spacing;\nRange        <- Char '-' Char / Char;\nChar         <- '\\\\' [abefnrtv'\"\\[\\]\\\\\\`\\$]\n              / '\\\\x' [0-9a-fA-F][0-9a-fA-F]\n              / '\\\\' '-'\n              / ~'\\\\' .;\nLEFTARROW    <- '<-' _Spacing;\n_SLASH        <- '/' _Spacing              ${_ => SKIP};\nSEMI         <- ';' _Spacing;\nAND          <- '&' _Spacing;\nNOT          <- '~' _Spacing;\nQUESTION     <- '?' _Spacing;\nSTAR         <- '*' _Spacing;\nPLUS         <- '+' _Spacing;\nOPEN         <- '(' _Spacing;\nCLOSE        <- ')' _Spacing;\nDOT          <- '.' _Spacing;\n_Spacing      <- (Space / Comment)*        ${_ => SKIP};\nComment      <- '#' (~EndOfLine .)* EndOfLine;\nSpace        <- ' ' / '\\t' / EndOfLine;\nEndOfLine    <- '\\r\\n' / '\\n' / '\\r';\n_EndOfFile    <- ~.;\n\nHOLE         <- &${HOLE} _Spacing;\nBEGIN        <- '<' _Spacing;\nEND          <- '>' _Spacing;\nPLUSPLUS     <- '++' _Spacing;\nSTARSTAR     <- '**' _Spacing;\n`;\n});\n\nexport default immunize(makePeg);","// DO NOT EDIT - Generated automatically from quasi-jessie-module.mjs.ts by tessc\n// An extension of the Jessie grammar to facilitate rewriting\n// imports/exports as AMD.\n\n/// <reference path=\"peg.d.ts\"/>\n\nconst makeJessieModule = immunize(jessiePeg => {\n  return jessiePeg`\n    # Override rather than inherit start production.\n    # Only module syntax is permitted.\n    start <- _WS moduleBody _EOF               ${b => (..._a) => ['moduleX', b]};\n\n    # A.5 Scripts and Modules\n\n    immunizedExpr <- < super.immunizedExpr >;\n\n    moduleBody <- moduleItem*;\n    moduleItem <-\n      < SEMI >\n    / importDecl    # Same AST as in Jessie.\n    / exportDecl    # Similar AST, but immunizedExpr is source string.\n    / < moduleDeclaration >;  # Source string.\n\n    exportDecl <-\n      EXPORT DEFAULT < exportableExpr > SEMI    ${e => ['exportDefaultX', e]}\n    / EXPORT moduleDeclaration                  ${(_, d) => ['exportX', ...d]};\n    `;\n});\n\nexport default immunize(makeJessieModule);","// DO NOT EDIT - Generated automatically from quasi-jessie.mjs.ts by tessc\n// Subsets of JavaScript, starting from the grammar as defined at\n// http://www.ecma-international.org/ecma-262/9.0/#sec-grammar-summary\n\n// See https://github.com/Agoric/Jessie/blob/master/README.md\n// for documentation of the Jessie grammar defined here.\n\n/// <reference path=\"peg.d.ts\"/>\n\n\nconst terminatedBlock = immunize(manyBodies => {\n  const stmts = manyBodies.reduce((prior, body) => {\n    const [bs, t] = body;\n    bs.forEach(b => prior.push(b));\n    prior.push(t);\n    return prior;\n  }, []);\n  return ['block', stmts];\n});\n\nconst makeJessie = immunize((peg, justinPeg) => {\n  const { SKIP } = justinPeg;\n  const jessieTag = justinPeg`\n    # Override rather than inherit start production.\n    # Only module syntax is permitted.\n    start <- _WS moduleBody _EOF               ${b => (..._a) => ['module', b]};\n\n    # A.1 Lexical Grammar\n\n    # For proposed eventual send expressions\n    LATER <- _NO_NEWLINE \"!\" _WS;\n\n    # A.2 Expressions\n\n    # Jessie primaryExpr does not include \"this\", ClassExpression,\n    # GeneratorExpression, AsyncFunctionExpression,\n    # AsyncGenerarorExpression, or RegularExpressionLiteral.\n    primaryExpr <-\n      super.primaryExpr\n    / functionExpr;\n\n    propDef <-\n      methodDef\n    / super.propDef;\n\n    purePropDef <-\n      methodDef\n    / super.purePropDef;\n\n    # Recognize pre-increment/decrement.\n    prePre <-\n      (PLUSPLUS / MINUSMINUS)                          ${op => `pre:${op}`}\n    / super.prePre;\n\n    # Extend to recognize proposed eventual get syntax,\n    # as well as computed indices and postfix increment/decrement.\n    memberPostOp <-\n      super.memberPostOp\n    / LEFT_BRACKET assignExpr RIGHT_BRACKET        ${(_, e, _2) => ['index', e]}\n    / LATER LEFT_BRACKET assignExpr RIGHT_BRACKET  ${(_, _2, e, _3) => ['indexLater', e]}\n    / LATER IDENT_NAME                             ${(_, id) => ['getLater', id]};\n\n    # Extend to recognize proposed eventual send syntax.\n    # We distinguish b!foo(x) from calling b!foo by a post-parsing pass\n    callPostOp <-\n      super.callPostOp\n    / LATER args                                           ${(_, args) => ['callLater', args]};\n\n    postOp <- (PLUSPLUS / MINUSMINUS) _WS;\n\n    # to be extended\n    assignExpr <-\n      arrowFunc\n    / functionExpr\n    / lValue postOp                                        ${(lv, op) => [op, lv]}\n    / lValue (EQUALS / assignOp) assignExpr                ${(lv, op, rv) => [op, lv, rv]}\n    / super.assignExpr\n    / primaryExpr;\n\n    # An expression without side-effects.\n    pureExpr <-\n      arrowFunc\n    / super.pureExpr;\n\n    # In Jessie, an lValue is only a variable, a computed index-named\n    # property (an array element), or a statically string-named\n    # property.\n    # We allow assignment to statically string-named fields, since it\n    # is useful during initialization and prevented thereafter by\n    # mandatory tamper-proofing.\n\n    # to be overridden or extended\n    lValue <-\n      primaryExpr LEFT_BRACKET indexExpr RIGHT_BRACKET     ${(pe, _, e, _2) => ['index', pe, e]}\n    / primaryExpr LATER LEFT_BRACKET indexExpr RIGHT_BRACKET ${(pe, _, _2, e, _3) => ['indexLater', pe, e]}\n    / primaryExpr DOT IDENT_NAME                           ${(pe, _, id) => ['get', pe, id]}\n    / primaryExpr LATER IDENT_NAME                         ${(pe, _, id) => ['getLater', pe, id]}\n    / useVar;\n\n    assignOp <-\n      (\"*=\" / \"/=\" / \"%=\" / \"+=\" / \"-=\"\n    / \"<<=\" / \">>=\" / \">>>=\"\n    / \"&=\" / \"^=\" / \"|=\"\n    / \"**=\") _WS;\n\n\n    # A.3 Statements\n\n    # to be extended.\n    # The exprStatement production must go last, so PEG's prioritized\n    # choice will interpret {} as a block rather than an expression.\n    statement <-\n      block\n    / IF LEFT_PAREN expr RIGHT_PAREN arm ELSE elseArm      ${(_, _2, c, _3, t, _4, e) => ['if', c, t, e]}\n    / IF LEFT_PAREN expr RIGHT_PAREN arm                   ${(_, _2, c, _3, t) => ['if', c, t]}\n    / breakableStatement\n    / terminator\n    / IDENT COLON statement                                ${(label, _, stat) => ['label', label, stat]}\n    / TRY block catcher finalizer                          ${(_, b, c, f) => ['try', b, c, f]}\n    / TRY block catcher                                    ${(_, b, c) => ['try', b, c]}\n    / TRY block finalizer                                  ${(_, b, f) => ['try', b, undefined, f]}\n    / DEBUGGER SEMI                                        ${(_, _2) => ['debugger']}\n    / exprStatement;\n\n    # to be overridden.  In Jessie, only blocks are accepted as arms\n    # of flow-of-control statements.\n    arm <- block;\n\n    # Allows for\n    # if (...) {} else if (...) {} else if (...) {};\n    elseArm <-\n      arm\n    / IF LEFT_PAREN expr RIGHT_PAREN arm ELSE elseArm      ${(_, _2, c, _3, t, _4, e) => ['if', c, t, e]}\n    / IF LEFT_PAREN expr RIGHT_PAREN arm                   ${(_, _2, c, _3, t) => ['if', c, t]};\n\n    breakableStatement <-\n      FOR LEFT_PAREN declOp forOfBinding OF expr RIGHT_PAREN arm\n            ${(_, _2, o, d, _3, e, _4, b) => ['forOf', o, d, e, b]}\n    / FOR LEFT_PAREN declaration expr? SEMI expr? RIGHT_PAREN arm ${(_, _2, d, c, _3, i, _4, b) => ['for', d, c, i, b]}\n    / WHILE LEFT_PAREN expr RIGHT_PAREN arm                       ${(_, _2, c, _3, b) => ['while', c, b]}\n    / SWITCH LEFT_PAREN expr RIGHT_PAREN LEFT_BRACE clause* RIGHT_BRACE\n            ${(_, _2, e, _3, _4, bs, _5) => ['switch', e, bs]};\n\n    # Each case clause must end in a terminating statement.\n    terminator <-\n      \"continue\" _NO_NEWLINE IDENT SEMI                ${(_, label, _3) => ['continue', label]}\n    / \"continue\" _WS SEMI                              ${(_, _2) => ['continue']}\n    / \"break\" _NO_NEWLINE IDENT SEMI                   ${(_, label, _2) => ['break', label]}\n    / \"break\" _WS SEMI                                 ${(_, _2) => ['break']}\n    / \"return\" _NO_NEWLINE expr SEMI                   ${(_, e, _2) => ['return', e]}\n    / \"return\" _WS SEMI                                ${(_, _2) => ['return']}\n    / \"throw\" _NO_NEWLINE expr SEMI                    ${(_, e, _3) => ['throw', e]};\n\n    block <- LEFT_BRACE body RIGHT_BRACE              ${(_, b, _2) => ['block', b]};\n    body <- statementItem*;\n\n    # declaration must come first, so that PEG will prioritize\n    # function declarations over exprStatement.\n    statementItem <-\n      declaration\n    / statement;\n\n    # No \"class\" declaration.\n    # No generator, async, or async iterator function.\n    declaration <-\n      declOp binding ** _COMMA SEMI                    ${(op, decls, _) => [op, decls]}\n    / functionDecl;\n\n    declOp <- (\"const\" / \"let\") _WSN;\n\n    forOfBinding <- bindingPattern / defVar;\n    binding <-\n      bindingPattern EQUALS assignExpr                ${(p, _, e) => ['bind', p, e]}\n    / defVar EQUALS assignExpr                        ${(p, _, e) => ['bind', p, e]}\n    / defVar;\n\n    bindingPattern <-\n      LEFT_BRACKET elementParam ** _COMMA RIGHT_BRACKET     ${(_, ps, _2) => ['matchArray', ps]}\n    / LEFT_BRACE propParam ** _COMMA RIGHT_BRACE            ${(_, ps, _2) => ['matchRecord', ps]};\n\n    pattern <-\n      bindingPattern\n    / defVar\n    / dataLiteral                                     ${n => ['matchData', JSON.parse(n)]}\n    / HOLE                                            ${h => ['patternHole', h]};\n\n    # to be overridden\n    elementParam <- param;\n\n    param <-\n      ELLIPSIS pattern                                ${(_, p) => ['rest', p]}\n    / defVar EQUALS assignExpr                        ${(v, _, e) => ['optional', v, e]}\n    / pattern;\n\n    propParam <-\n      ELLIPSIS pattern                                ${(_, p) => ['restObj', p]}\n    / propName COLON pattern                          ${(k, _, p) => ['matchProp', k, p]}\n    / defVar EQUALS assignExpr                        ${(id, _, e) => ['optionalProp', id[1], id, e]}\n    / defVar                                          ${id => ['matchProp', id[1], id]};\n\n    # Use PEG prioritized choice.\n    # TODO emit diagnostic for failure cases.\n    exprStatement <-\n      ~cantStartExprStatement expr SEMI               ${(e, _2) => e};\n\n    cantStartExprStatement <-\n      (\"{\" / \"function\" / \"async\" _NO_NEWLINE \"function\"\n    / \"class\" / \"let\" / \"[\") _WSN;\n\n    # to be overridden\n    terminatedBody <- ((~terminator statementItem)* terminator)+   ${tb => terminatedBlock(tb)};\n    clause <-\n      caseLabel+ LEFT_BRACE terminatedBody RIGHT_BRACE ${(cs, _, b, _2) => ['clause', cs, b]};\n    caseLabel <-\n      CASE expr COLON                                 ${(_, e) => ['case', e]}\n    / DEFAULT _WS COLON                                ${(_, _2) => ['default']};\n\n    catcher <- CATCH LEFT_PAREN pattern RIGHT_PAREN block ${(_, _2, p, _3, b) => ['catch', p, b]};\n    finalizer <- FINALLY block                        ${(_, b) => ['finally', b]};\n\n\n    # A.4 Functions and Classes\n\n    functionDecl <-\n      FUNCTION defVar LEFT_PAREN param ** _COMMA RIGHT_PAREN block\n                                                      ${(_, n, _2, p, _3, b) => ['functionDecl', n, p, b]};\n\n    functionExpr <-\n      FUNCTION defVar? LEFT_PAREN param ** _COMMA RIGHT_PAREN block\n                                                      ${(_, n, _2, p, _3, b) => ['functionExpr', n[0], p, b]};\n\n    # The assignExpr form must come after the block form, to make proper use\n    # of PEG prioritized choice.\n    arrowFunc <-\n      arrowParams _NO_NEWLINE ARROW block              ${(ps, _2, b) => ['arrow', ps, b]}\n    / arrowParams _NO_NEWLINE ARROW assignExpr         ${(ps, _2, e) => ['lambda', ps, e]};\n\n    arrowParams <-\n      IDENT                                           ${id => [['def', id]]}\n    / LEFT_PAREN param ** _COMMA RIGHT_PAREN           ${(_, ps, _2) => ps};\n\n    # to be extended\n    methodDef <-\n      method\n    / GET propName LEFT_PAREN RIGHT_PAREN block            ${(_, n, _2, _3, b) => ['getter', n, [], b]}\n    / SET propName LEFT_PAREN param RIGHT_PAREN block      ${(_, n, _2, p, _3, b) => ['setter', n, [p], b]};\n\n    method <-\n      propName LEFT_PAREN param ** _COMMA RIGHT_PAREN block ${(n, _, p, _2, b) => ['method', n, p, b]};\n\n\n    # A.5 Scripts and Modules\n\n    moduleBody <- moduleItem*;\n    moduleItem <-\n      SEMI                                               ${_ => SKIP}\n    / importDecl\n    / exportDecl\n    / moduleDeclaration;\n\n    useImport <- IMPORT_PFX IDENT                 ${(pfx, id) => ['use', pfx + id]};\n    defImport <- IMPORT_PFX IDENT                 ${(pfx, id) => ['def', pfx + id]};\n\n    moduleDeclaration <-\n      \"const\" _WSN moduleBinding ** _COMMA SEMI       ${(op, decls) => [op, decls]};\n\n    # An immunized expression without side-effects.\n    immunizedExpr <-\n      dataLiteral                                     ${d => ['data', JSON.parse(d)]}\n    / \"immunize\" _WS LEFT_PAREN (pureExpr / useImport) RIGHT_PAREN  ${(fname, _2, expr, _3) =>\n  ['call', ['use', fname], [expr]]};\n\n    # Jessie modules only allow immunized module-level bindings.\n    moduleBinding <-\n      bindingPattern EQUALS immunizedExpr       ${(p, _, e) => ['bind', p, e]}\n    / defVar EQUALS immunizedExpr               ${(p, _, e) => ['bind', p, e]}\n    / defVar;\n\n    importClause <-\n      STAR AS defImport                         ${(_, _2, d) => ['importBind', [['as', '*', d[1]]]]}\n    / namedImports                              ${n => ['importBind', n]}\n    / defImport _COMMA STAR AS defImport        ${(d, _, _2, d2) => ['importBind', [['as', 'default', d[1]],\n  ['as', '*', d2[1]]]]}\n    / defImport _COMMA namedImports             ${(d, n) => ['importBind', [['as', 'default', d[1]], ...n]]}\n    / defImport                                 ${d => ['importBind', [['as', 'default', d[1]]]]};\n\n    importSpecifier <-\n      defImport                                 ${d => ['as', d[1], d[1]]}\n    / IDENT_NAME AS defImport                   ${(i, _, d) => ['as', i, d[1]]};\n\n    namedImports <-\n      LEFT_BRACE importSpecifier ** _COMMA _COMMA? RIGHT_BRACE ${(_, s, _2) => s};\n\n    importDecl <- IMPORT importClause FROM STRING SEMI  ${(_, v, _2, s, _3) => ['import', v, JSON.parse(s)]};\n    exportDecl <-\n      EXPORT DEFAULT exportableExpr SEMI        ${(_, _2, e, _3) => ['exportDefault', e]}\n    / EXPORT moduleDeclaration                  ${(_, d) => ['export', ...d]};\n\n    # to be extended\n    exportableExpr <- immunizedExpr;\n\n    # Lexical syntax\n    ARROW <- \"=>\" _WS;\n    AS <- \"as\" _WSN;\n    DEBUGGER <- \"debugger\" _WSN;\n    PLUSPLUS <- \"++\" _WSN;\n    MINUSMINUS <- \"--\" _WSN;\n    CASE <- \"case\" _WSN;\n    IF <- \"if\" _WSN;\n    ELSE <- \"else\" _WSN;\n    FOR <- \"for\" _WSN;\n    OF <- \"of\" _WSN;\n    WHILE <- \"while\" _WSN;\n    BREAK <- \"break\" _WSN;\n    CONTINUE <- \"continue\" _WSN;\n    SWITCH <- \"switch\" _WSN;\n    TRY <- \"try\" _WSN;\n    CATCH <- \"catch\" _WSN;\n    FINALLY <- \"finally\" _WSN;\n    GET <- \"get\" _WSN;\n    SET <- \"set\" _WSN;\n    IMPORT <- \"import\" _WSN;\n    EXPORT <- \"export\" _WSN;\n    FROM <- \"from\" _WSN;\n    FUNCTION <- \"function\" _WSN;\n    DEFAULT <- \"default\" _WSN;\n    EQUALS <- \"=\" _WS;\n    SEMI <- \";\" _WS;\n    STAR <- \"*\" _WS;\n    `;\n\n  const jessieExprTag = peg.extends(jessieTag)`\n    # Jump to the expr production.\n    start <- _WS expr _EOF              ${e => (..._a) => e};\n    `;\n\n  return [jessieTag, jessieExprTag];\n});\n\nexport default immunize(makeJessie);","// DO NOT EDIT - Generated automatically from quasi-json.mjs.ts by tessc\n// Subsets of JavaScript, starting from the grammar as defined at\n// http://www.ecma-international.org/ecma-262/9.0/#sec-grammar-summary\n\n// Defined to be extended into the Jessie grammar.\n// See https://github.com/Agoric/Jessie/blob/master/README.md\n// for documentation of the Jessie grammar.\n\n// See also json.org\n\n/// <reference path=\"peg.d.ts\"/>\n\nconst makeJSON = immunize(peg => {\n  const { FAIL, HOLE, SKIP } = peg;\n  return peg`\n# to be overridden or inherited\nstart <- _WS assignExpr _EOF                ${v => (..._a) => v};\n\n# to be extended\nprimaryExpr <- dataStructure;\n\ndataStructure <-\n  dataLiteral                             ${n => ['data', JSON.parse(n)]}\n/ array\n/ record\n/ HOLE                                    ${h => ['exprHole', h]};\n\n# An expression without side-effects.\n# to be extended\npureExpr <-\n  dataLiteral                             ${n => ['data', JSON.parse(n)]}\n/ pureArray\n/ pureRecord\n/ HOLE                                    ${h => ['exprHole', h]};\n\ndataLiteral <- ((\"null\" / \"false\" / \"true\") _WSN / NUMBER / STRING) _WS;\n\npureArray <-\n  LEFT_BRACKET pureExpr ** _COMMA _COMMA? RIGHT_BRACKET ${(_, es, _2) => ['array', es]};\n\narray <-\n  LEFT_BRACKET element ** _COMMA _COMMA? RIGHT_BRACKET ${(_, es, _2) => ['array', es]};\n\n# to be extended\nelement <- assignExpr;\n\n# The JavaScript and JSON grammars calls records \"objects\"\n\npureRecord <-\n  LEFT_BRACE purePropDef ** _COMMA _COMMA? RIGHT_BRACE  ${(_, ps, _2) => ['record', ps]};\n\nrecord <-\n  LEFT_BRACE propDef ** _COMMA _COMMA? RIGHT_BRACE  ${(_, ps, _2) => ['record', ps]};\n\n# to be extended\npurePropDef <- propName COLON pureExpr     ${(k, _, e) => ['prop', k, e]};\n\n# to be extended\npropDef <- propName COLON assignExpr       ${(k, _, e) => ['prop', k, e]};\n\n# to be extended\npropName <- STRING                     ${str => {\n    const js = JSON.parse(str);\n    if (js === '__proto__') {\n      // Don't allow __proto__ behaviour attacks.\n      return FAIL;\n    }\n    return ['data', js];\n  }};\n\n# to be overridden\nassignExpr <- primaryExpr;\n\n# Lexical syntax\n\n_EOF <- ~.;\nLEFT_BRACKET <- \"[\" _WS;\nRIGHT_BRACKET <- \"]\" _WS;\nLEFT_BRACE <- \"{\" _WS;\nRIGHT_BRACE <- \"}\" _WS;\n_COMMA <- \",\" _WS                     ${_ => SKIP};\nCOLON <- \":\" _WS;\nMINUS <- \"-\" _WS;\nHOLE <- &${HOLE} _WS;\n\nSTRING <- < '\"' (~'\"' character)* '\"' > _WS;\n\nutf8 <-\n  [\\xc2-\\xdf] utf8cont\n/ [\\xe0-\\xef] utf8cont utf8cont\n/ [\\xf0-\\xf4] utf8cont utf8cont utf8cont;\n\nutf8cont <- [\\x80-\\xbf];\n\ncharacter <-\n  escape\n/ '\\\\u' hex hex hex hex\n/ ~'\\\\' ([\\x20-\\x7f] / utf8);\n\nescape <- '\\\\' ['\"\\\\bfnrt];\nhex <- digit / [a-fA-F];\n\nNUMBER <- < int frac? exp? > _WSN;\n\nint <- [1-9] digit+\n/ digit\n/ MINUS digit\n/ MINUS [1-9] digit+;\n\ndigit <- [0-9];\n\nfrac <- '.' digit+;\nexp <- [Ee] [+\\-]? digit+;\n\n# _WSN is whitespace or a non-ident character.\n_WSN <- ~[$A-Za-z_] _WS    ${_ => SKIP};\n_WS <- [\\t\\n\\r ]*          ${_ => SKIP};\n`;\n\n});\n\nexport default immunize(makeJSON);","// DO NOT EDIT - Generated automatically from quasi-utils.mjs.ts by tessc\nexport const qunpack = immunize((h, ms, t) => {\n  return [h, ...ms, t];\n});\n\nexport const qrepack = immunize(parts => {\n  // TODO bug: We only provide the raw form at this time. I\n  // apologize once again for allowing a cooked form into the\n  // standard.\n  const raw = [parts[0]];\n  const argExprs = [];\n  const len = parts.length;\n  for (let i = 1; i < len; i += 2) {\n    argExprs.push(parts[i]);\n    raw.push(parts[i + 1]);\n  }\n  const template = [...raw];\n  template.raw = raw;\n  return [['data', template], ...argExprs];\n});\n\nexport const reduceElisions = immunize(es => {\n  const reduced = [];\n  for (const e of es) {\n    if (e[0] === undefined) {\n      // Push the elisions.\n      e.forEach(_ => reduced.push(undefined));\n    } else {\n      // Push the individual expression.\n      reduced.push(e);\n    }\n  }\n  return reduced;\n});","// DO NOT EDIT - Generated automatically from quasi-justin.mjs.ts by tessc\n// Subsets of JavaScript, starting from the grammar as defined at\n// http://www.ecma-international.org/ecma-262/9.0/#sec-grammar-summary\n\n// Justin is the safe JavaScript expression language, a potentially\n// pure decidable superset of JSON and subset of Jessie, that relieves\n// many of the pain points of using JSON as a data format:\n//   * unquoted indentifier property names.\n//   * comments.\n//   * multi-line strings (via template literals).\n//   * undefined.\n//   * includes all floating point values: NaN, Infinity, -Infinity\n//   * will include BigInt once available.\n\n// Justin also includes most pure JavaScript expressions. Justin does not\n// include function expressions or variable or function\n// definitions. However, it does include free variable uses and\n// function calls; so the purity and decidability of Justin depends on\n// the endowments provided for these free variable bindings.\n\n// Justin is defined to be extended into the Jessie grammar, which is\n// defined to be extended into the JavaScript grammar.\n// See https://github.com/Agoric/Jessie/blob/master/README.md\n// for documentation of the Jessie grammar.\n\n// Justin is defined to be extended into the Chainmail grammar, to\n// provide its expression language in a JS-like style. Chainmail\n// expressions need to be pure and should be decidable.\n\n/// <reference path=\"peg.d.ts\"/>\n\nimport { qunpack as $i_qunpack } from './quasi-utils.mjs';const qunpack = immunize($i_qunpack);\n\nconst binary = immunize((left, rights) => {\n  return rights.reduce((prev, [op, right]) => [op, prev, right], left);\n});\n\nconst transformSingleQuote = immunize(s => {\n  let i = 0,qs = '';\n  while (i < s.length) {\n    const c = s.slice(i, i + 1);\n    if (c === '\\\\') {\n      // Skip one char.\n      qs += s.slice(i, i + 2);\n      i += 2;\n    } else if (c === '\"') {\n      // Quote it.\n      qs += '\\\\\"';\n      i++;\n    } else {\n      // Add it directly.\n      qs += c;\n      i++;\n    }\n  }\n  return `\"${qs}\"`;\n});\n\nconst makeJustin = immunize(peg => {\n  const { SKIP } = peg;\n  return peg`\n    # to be overridden or inherited\n    start <- _WS assignExpr _EOF                       ${v => (..._a) => v};\n\n    # A.1 Lexical Grammar\n\n    DOT <- \".\" _WS;\n    ELLIPSIS <- \"...\" _WS;\n    LEFT_PAREN <- \"(\" _WS;\n    PLUS <- \"+\" _WS;\n    QUESTION <- \"?\" _WS;\n    RIGHT_PAREN <- \")\" _WS;\n    STARSTAR <- \"**\" _WS;\n\n    # Define Javascript-style comments.\n    _WS <- super._WS (EOL_COMMENT / MULTILINE_COMMENT)?   ${_ => SKIP};\n    EOL_COMMENT <- \"//\" (~[\\n\\r] .)* _WS;\n    MULTILINE_COMMENT <- \"/*\" (~\"*/\" .)* \"*/\" _WS;\n\n    # Add single-quoted strings.\n    STRING <-\n      super.STRING\n    / \"'\" < (~\"'\" character)* > \"'\" _WS  ${s => transformSingleQuote(s)};\n\n    # Only match if whitespace doesn't contain newline\n    _NO_NEWLINE <- ~IDENT [ \\t]*     ${_ => SKIP};\n\n    IDENT_NAME <- ~(HIDDEN_PFX / \"__proto__\") (IDENT / RESERVED_WORD);\n\n    IDENT <- ~(HIDDEN_PFX / IMPORT_PFX) < [$A-Za-z_] [$A-Za-z0-9_]* > _WS;\n    HIDDEN_PFX <- \"$h_\";\n    IMPORT_PFX <- \"$i_\";\n\n    # Omit \"async\", \"arguments\", \"eval\", \"get\", and \"set\" from IDENT\n    # in Justin even though ES2017 considers them in IDENT.\n    RESERVED_WORD <-\n      (KEYWORD / RESERVED_KEYWORD / FUTURE_RESERVED_WORD\n    / \"null\" / \"false\" / \"true\"\n    / \"async\" / \"arguments\" / \"eval\" / \"get\" / \"set\") _WSN;\n\n    KEYWORD <-\n      (\"break\"\n    / \"case\" / \"catch\" / \"const\" / \"continue\"\n    / \"debugger\" / \"default\"\n    / \"else\" / \"export\"\n    / \"finally\" / \"for\" / \"function\"\n    / \"if\" / \"import\"\n    / \"return\"\n    / \"switch\"\n    / \"throw\" / \"try\" / \"typeof\"\n    / \"void\"\n    / \"while\") _WSN;\n\n    # Unused by Justin but enumerated here, in order to omit them\n    # from the IDENT token.\n    RESERVED_KEYWORD <-\n      (\"class\"\n    / \"delete\" / \"do\"\n    / \"extends\"\n    / \"in\" / \"instanceof\"\n    / \"new\"\n    / \"super\"\n    / \"this\"\n    / \"var\"\n    / \"with\"\n    / \"yield\") _WSN;\n\n    FUTURE_RESERVED_WORD <-\n      (\"await\" / \"enum\"\n    / \"implements\" / \"package\" / \"protected\"\n    / \"interface\" / \"private\" / \"public\") _WSN;\n\n    # Quasiliterals aka template literals\n    QUASI_CHAR <- \"\\\\\" . / ~\"\\`\" .;\n    QUASI_ALL <- \"\\`\" < (~\"\\${\" QUASI_CHAR)* > \"\\`\" _WS;\n    QUASI_HEAD <- \"\\`\" < (~\"\\${\" QUASI_CHAR)* > \"\\${\" _WS;\n    QUASI_MID <- \"}\" < (~\"\\${\" QUASI_CHAR)* > \"\\${\" _WS;\n    QUASI_TAIL <- \"}\" < (~\"\\${\" QUASI_CHAR)* > \"\\`\" _WS;\n\n\n    # A.2 Expressions\n\n    dataStructure <-\n      \"undefined\" _WSN     ${_ => ['data', undefined]}\n    / super.dataStructure;\n\n    # Optional trailing commas.\n    record <-\n      super.record\n    / LEFT_BRACE propDef ** _COMMA _COMMA? RIGHT_BRACE      ${(_, ps, _2) => ['record', ps]};\n\n    array <-\n      super.array\n    / LEFT_BRACKET element ** _COMMA _COMMA? RIGHT_BRACKET  ${(_, es, _2) => ['array', es]};\n\n    useVar <- IDENT                                       ${id => ['use', id]};\n\n    # Justin does not contain variable definitions, only uses. However,\n    # multiple languages that extend Justin will contain defining\n    # occurrences of variable names, so we put the defVar production\n    # here.\n    defVar <- IDENT                                       ${id => ['def', id]};\n\n\n    primaryExpr <-\n      super.primaryExpr\n    / quasiExpr\n    / LEFT_PAREN expr RIGHT_PAREN                         ${(_, e, _2) => e}\n    / useVar;\n\n    pureExpr <-\n      super.pureExpr\n    / LEFT_PAREN pureExpr RIGHT_PAREN                     ${(_, e, _2) => e}\n    / useVar;\n\n    element <-\n      super.element\n    / ELLIPSIS assignExpr                                 ${(_, e) => ['spread', e]};\n\n    propDef <-\n      super.propDef\n    / useVar                                              ${u => ['prop', u[1], u]}\n    / ELLIPSIS assignExpr                                 ${(_, e) => ['spreadObj', e]};\n\n    purePropDef <-\n      super.purePropDef\n    / useVar                                              ${u => ['prop', u[1], u]}\n    / ELLIPSIS assignExpr                                 ${(_, e) => ['spreadObj', e]};\n\n    # No computed property name\n    propName <-\n      super.propName\n    / IDENT_NAME\n    / NUMBER;\n\n    quasiExpr <-\n      QUASI_ALL                                            ${q => ['quasi', [q]]}\n    / QUASI_HEAD expr ** QUASI_MID QUASI_TAIL              ${(h, ms, t) => ['quasi', qunpack(h, ms, t)]};\n\n    # to be extended\n    memberPostOp <-\n      LEFT_BRACKET indexExpr RIGHT_BRACKET                 ${(_, e, _3) => ['index', e]}\n    / DOT IDENT_NAME                                       ${(_, id) => ['get', id]}\n    / quasiExpr                                            ${q => ['tag', q]};\n\n    # to be extended\n    callPostOp <-\n      memberPostOp\n    / args                                                 ${args => ['call', args]};\n\n    # Because Justin and Jessie have no \"new\" or \"super\", they don't need\n    # to distinguish callExpr from memberExpr. So justin omits memberExpr\n    # and newExpr. Instead, in Justin, callExpr jumps directly to\n    # primaryExpr and updateExpr jumps directly to callExpr.\n\n    # to be overridden.\n    callExpr <- primaryExpr callPostOp*                   ${binary};\n\n    # To be overridden rather than inherited.\n    # Introduced to impose a non-JS restriction\n    # Restrict index access to number-names, including\n    # floating point, NaN, Infinity, and -Infinity.\n    indexExpr <-\n      NUMBER                                               ${n => ['data', JSON.parse(n)]}\n    / PLUS unaryExpr                                       ${(_, e) => [`pre:+`, e]};\n\n    args <- LEFT_PAREN arg ** _COMMA RIGHT_PAREN            ${(_, args, _2) => args};\n\n    arg <-\n      assignExpr\n    / ELLIPSIS assignExpr                                  ${(_, e) => ['spread', e]};\n\n    # to be overridden\n    updateExpr <- callExpr;\n\n    unaryExpr <-\n      preOp unaryExpr                                      ${(op, e) => [op, e]}\n    / updateExpr;\n\n    # to be extended\n    # No prefix or postfix \"++\" or \"--\".\n    # No \"delete\".\n    preOp <- ((\"void\" / \"typeof\") _WSN / prePre);\n    prePre <- (\"+\" / \"-\" / \"~\" / \"!\") _WS                 ${op => `pre:${op}`};\n\n    # Different communities will think -x**y parses in different ways,\n    # so the EcmaScript grammar forces parens to disambiguate.\n    powExpr <-\n      updateExpr STARSTAR powExpr                          ${(x, op, y) => [op, x, y]}\n    / unaryExpr;\n\n    multExpr <- powExpr (multOp powExpr)*                  ${binary};\n    addExpr <- multExpr (addOp multExpr)*                  ${binary};\n    shiftExpr <- addExpr (shiftOp addExpr)*                ${binary};\n\n    # Non-standard, to be overridden\n    # In C-like languages, the precedence and associativity of the\n    # relational, equality, and bitwise operators is surprising, and\n    # therefore hazardous. Here, none of these associate with the\n    # others, forcing parens to disambiguate.\n    eagerExpr <- shiftExpr (eagerOp shiftExpr)?            ${binary};\n\n    andThenExpr <- eagerExpr (andThenOp eagerExpr)*       ${binary};\n    orElseExpr <- andThenExpr (orElseOp andThenExpr)*     ${binary};\n\n    multOp <- (\"*\" / \"/\" / \"%\") _WS;\n    addOp <- (\"+\" / \"-\") _WS;\n    shiftOp <- (\"<<\" / \">>>\" / \">>\") _WS;\n    relOp <- (\"<=\" / \"<\" / \">=\" / \">\") _WS;\n    eqOp <- (\"===\" / \"!==\") _WS;\n    bitOp <- (\"&\" / \"^\" / \"|\") _WS;\n\n    eagerOp <- relOp / eqOp / bitOp;\n\n    andThenOp <- \"&&\" _WS;\n    orElseOp <- \"||\" _WS;\n\n    condExpr <-\n      orElseExpr QUESTION assignExpr COLON assignExpr   ${(c, _, t, _2, e) => ['cond', c, t, e]}\n    / orElseExpr;\n\n    # override, to be extended\n    assignExpr <- condExpr;\n\n    # The comma expression is not in Jessie because we\n    # opt to pass only immunized expressions as the this-binding.\n    expr <- assignExpr;\n  `;\n});\n\nexport default immunize(makeJustin);","// DO NOT EDIT - Generated automatically from rewrite-define.mjs.ts by tessc\n\n\nconst hide = immunize(vname => `\\$h_${vname}`);\n\n// Return a string separated by separators.\nconst separate = immunize((strs, sep) => {\n  let ret = '';\n  let actualSep = '';\n  for (const str of strs) {\n    if (str !== '') {\n      ret += actualSep + str;\n      actualSep = sep;\n    }\n  }\n  return ret;\n});\n\nconst moduleRewriteDefine = immunize((moduleAST, DEFINE = hide('define')) => {\n  const EXPORTS = hide('exports');\n  const imports = makeMap();\n  const exportVars = makeSet();\n  let starName;\n  let nImport = 0;\n  const rewriters = {\n    as(imp, sym) {\n      if (imp === '*') {\n        starName = sym;\n        return '';\n      }\n      return `${imp}: ${sym}`;\n    },\n    bind(def, expr) {\n      const name = doRewrite(def);\n      return `${name} = ${doRewrite(expr)}`;\n    },\n    def(name) {\n      exportVars.add(name);\n      return name;\n    },\n    exportDefaultX(val) {\n      return `${EXPORTS}.default = ${doRewrite(val)};`;\n    },\n    exportX(qual, binds) {\n      exportVars.clear();\n      const bindings = separate(binds.map(doRewrite), ', ');\n      let assign = '';\n      for (const vname of exportVars.keys()) {\n        assign += `${EXPORTS}.${vname} = ${vname};\\n`;\n      }\n      exportVars.clear();\n      return `${qual} ${bindings};\\n${assign}`;\n    },\n    import(clause, fromModule) {\n      // Save the bindings.\n      starName = undefined;\n      const bindings = doRewrite(clause);\n      if (starName === undefined) {\n        starName = hide(`star${nImport++}`);\n      }\n      imports.set(fromModule, starName);\n      if (bindings) {\n        return `const {${bindings}} = ${starName};\\n`;\n      }\n      return '';\n    },\n    importBind(bindings) {\n      return separate(bindings.map(doRewrite), ', ');\n    },\n    matchArray(es) {\n      return `[${separate(es.map(doRewrite), ', ')}]`;\n    },\n    matchProp(kw, prop) {\n      const rewrite = doRewrite(prop);\n      if (kw === rewrite) {\n        return kw;\n      }\n      return `${kw}: ${rewrite}`;\n    },\n    matchRecord(es) {\n      return `{${separate(es.map(doRewrite), ', ')}}`;\n    },\n    moduleX(decls) {\n      const body = decls.reduce((prior, cur) => prior + doRewrite(cur), '');\n      const modules = [];\n      const names = [];\n      for (const [mod, name] of imports.entries()) {\n        modules.push(mod);\n        names.push(name);\n      }\n      const bindings = separate(names, ', ');\n      return `${DEFINE}(\n${JSON.stringify(modules)},\n(${bindings}) => {\nconst ${EXPORTS} = {};\n${body}\nreturn ${EXPORTS};\n})`;\n    },\n    rest(expr) {\n      return `...${doRewrite(expr)}`;\n    },\n    restObj(expr) {\n      return `...${doRewrite(expr)}`;\n    } };\n\n\n  const doRewrite = node => {\n    if (typeof node === 'string') {\n      return node;\n    }\n    const [name, ...args] = node;\n    const rewriter = rewriters[name];\n    if (!rewriter) {\n      throw slog.error`No rewriter for ${{ name }}`;\n    }\n    return rewriter(...args);\n  };\n  return doRewrite(moduleAST);\n});\n\nexport default immunize(moduleRewriteDefine);","// DO NOT EDIT - Generated automatically from tag-string.mjs.ts by tessc\n/// <reference path=\"./peg.d.ts\"/>\nconst tagString = immunize((tag, uri) => {\n\n\n  function tagged(templateOrFlag, ...args)\n  {\n    if (typeof templateOrFlag === 'string') {\n      return tagString(tag(templateOrFlag), uri);\n    }\n    const template = templateOrFlag;\n    const cooked = template.reduce((prior, t, i) => {\n      prior.push(t, String(args[i]));\n      return prior;\n    }, []);\n    cooked.push(template[template.length - 1]);\n    const cooked0 = cooked.join('');\n    const raw0 = args.reduce((prior, hole, i) => {\n      prior.push(String(hole), template.raw[i + 1]);\n      return prior;\n    }, [template.raw[0]]).join('');\n    const sources0 = {\n      byte: 0,\n      column: 1,\n      line: 1,\n      uri };\n\n    const tmpl = [cooked0];\n    tmpl.raw = [raw0];\n    tmpl.sources = [sources0];\n    return tag(tmpl);\n  }\n  tagged.parserCreator = tag.parserCreator;\n  tagged._asExtending = tag._asExtending;\n  return tagged;\n});\n\nexport default immunize(tagString);","// DO NOT EDIT - Generated automatically from translate.mjs.ts by tessc\nimport $i_bootPeg from './boot-peg.mjs';const bootPeg = immunize($i_bootPeg);\nimport $i_bootPegAst from './boot-pegast.mjs';const bootPegAst = immunize($i_bootPegAst);\nimport $i_makePeg from './quasi-peg.mjs';const makePeg = immunize($i_makePeg);\n\nimport $i_makeJessieModule from './quasi-jessie-module.mjs';const makeJessieModule = immunize($i_makeJessieModule);\nimport $i_makeJessie from './quasi-jessie.mjs';const makeJessie = immunize($i_makeJessie);\nimport $i_makeJSON from './quasi-json.mjs';const makeJSON = immunize($i_makeJSON);\nimport $i_makeJustin from './quasi-justin.mjs';const makeJustin = immunize($i_makeJustin);\nimport $i_rewriteModuleDefine from './rewrite-define.mjs';const rewriteModuleDefine = immunize($i_rewriteModuleDefine);\nimport $i_tagString from './tag-string.mjs';const tagString = immunize($i_tagString);\n\nconst pegTag = immunize(bootPeg(makePeg, bootPegAst));\nconst jsonTag = immunize(makeJSON(pegTag));\nconst justinTag = immunize(makeJustin(pegTag.extends(jsonTag)));\nconst [jessieTag] = immunize(makeJessie(pegTag, pegTag.extends(justinTag)));\nconst jessieModuleTag = immunize(makeJessieModule(pegTag.extends(jessieTag)));\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nexport const translate = immunize((sourceText, parameters) =>\n\nmakePromise(resolve => {\n  const { sourceType, target, targetType } = parameters;\n  if (sourceType !== 'jessie') {\n    throw slog.error`Unrecognized sourceType: ${{ sourceType }}`;\n  }\n  if (target !== 'jessie-frame') {\n    throw slog.error`Unrecognized target: ${{ target }}`;\n  }\n\n  switch (targetType) {\n    case 'function':{\n        const tag = tagString(jessieModuleTag, parameters.sourceURL);\n\n        // Throw an exception if the sourceText doesn't parse.\n        const moduleAst = tag`${sourceText}`;\n\n        // Rewrite the ESM imports/exports into an SES-honouring AMD form.\n        const translatedText = rewriteModuleDefine(moduleAst, '$h_define');\n        const result = {\n          ...parameters,\n          translatedText };\n\n        return resolve(result);\n      }\n    case 'module':{\n        const tag = tagString(jessieTag, parameters.sourceURL);\n\n        // Throw an exception if the sourceText doesn't parse.\n        tag`${sourceText}`;\n\n        // Return the sourceText verbatim.\n        const result = {\n          ...parameters,\n          translatedText: sourceText };\n\n        return resolve(result);\n      }\n    default:{\n        throw slog.error`Unrecognized targetType: ${{ targetType }}`;\n      }}\n\n\n}));","import globalEnv from './globalEnv.mjs';\nexport {translate} from '../../lib/translate.mjs';\n\nexport const confine = (src) => {\n    return globalEnv.confine(src, globalEnv);\n};\n"]}